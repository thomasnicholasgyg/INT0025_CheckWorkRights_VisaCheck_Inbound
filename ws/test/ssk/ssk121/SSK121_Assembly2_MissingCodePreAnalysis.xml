<?xml version="1.0" encoding="utf-8"?>
<Root><beans xmlns="http://www.springframework.org/schema/beans" xmlns:cc="http://www.capeclear.com/assembly/10" xmlns:cloud="urn:com.workday/esb/cloud/10.0" xmlns:ptdf="urn:com.workday/peci/tdf" xmlns:beans="http://www.springframework.org/schema/beans" xmlns:pi="urn:com.workday/picof" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:wd="urn:com.workday/bsvc" xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:peci="urn:com.workday/peci" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 
	<cc:assembly id="WorkdayAssembly" version="2019.35">
        <cc:local-out id="PIM_Debug_Stats_109" execute-when="props['globalLogCountDebug'] > 0" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'DEBUG'"/>
            <cc:set name="is.message.summary" value="props['globalLogCountDebug'] + ' debug message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Info_Stats_109" execute-when="props['globalLogCountInfo'] > 0" routes-response-to="PIM_Debug_Stats_109" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="props['globalLogCountInfo'] + ' informational message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Warning_Stats_109" execute-when="props['globalLogCountWarn'] > 0" routes-response-to="PIM_Info_Stats_109" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'WARNING'"/>
            <cc:set name="is.message.summary" value="props['globalLogCountWarn'] + ' warning(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Error_Stats_109" execute-when="props['globalLogCountError'] > 0" routes-response-to="PIM_Warning_Stats_109" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'ERROR'"/>
            <cc:set name="is.message.summary" value="props['globalLogCountError'] + ' error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Critical_Stats_109" execute-when="props['globalLogCountCritical'] > 0" routes-response-to="PIM_Error_Stats_109" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'CRITICAL'"/>
            <cc:set name="is.message.summary" value="props['globalLogCountCritical'] + ' critical error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-in id="LogStats" routes-to="PIM_Critical_Stats_109" access="private"/>
        <cc:local-out id="Call_LogStats_109" execute-when="props['inLogFinalize']" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/LogStats"/>
        <cc:async-mediation id="OutputCloudLog_109" routes-to="Call_LogStats_109" execute-steps-when="vars['cloud-log-content'] != null &amp;&amp; props['globalLogCountByLogFile'] > 0 &amp;&amp; props['globalLogCountTotal'] > 0 &amp;&amp;&#xd;&#xa;(&#xd;&#xa;&#x9;(props['inLogFinalize'] == true) ||&#xd;&#xa;&#x9;(props['globalLogMaxCountPerFile'] > 0 &amp;&amp; props['globalLogCountByLogFile'] == props['globalLogMaxCountPerFile'])&#xd;&#xa;)">
            <cc:steps>
                <cc:eval id="Setup">
                    <cc:expression>props['globalLogFilesStored'] = props['globalLogFilesStored'] + 1</cc:expression>
                    <cc:expression>props['localLogFilenameForStorage'] = (props['globalLogMaxCountPerFile'] == 0) ? props['globalLogFilename'] # ".html" : props['globalLogFilename'] # "_" # props['globalLogFilesStored'] # ".html"</cc:expression>
                </cc:eval>
                <cc:store id="StoreCloudLog" input="variable" input-variable="cloud-log-content" createDocumentReference="true" expiresIn="@{props['globalLogExpires']}" title="@{props['localLogFilenameForStorage']}"/>
                <cc:eval id="Reset">
                    <cc:expression>vars['cloud-log-content'] = null</cc:expression>
                    <cc:expression>props['globalLogCountByLogFile'] = 0</cc:expression>
                    <cc:expression>foreach (propname : ['localLogFilenameForStorage']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="StoreLog" routes-to="OutputCloudLog_109" access="public">
            <cc:parameter default="false" name="inLogFinalize" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_StoreLog_109" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/StoreLog">
            <cc:set name="inLogFinalize" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="WriteLog_109" routes-to="Call_StoreLog_109">
            <cc:steps>
                <cc:cloud-log id="LogDebugMsg" condition="props['inLogLevel'] == 'debug'" level="debug" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="HTML" reference-id="props['inLogReferenceId']">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
                <cc:cloud-log id="LogInfoMsg" condition="props['inLogLevel'] == 'info'" level="info" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="HTML" reference-id="props['inLogReferenceId']">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
                <cc:cloud-log id="LogWarnMsg" condition="props['inLogLevel'] == 'warn'" level="warn" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="HTML" reference-id="props['inLogReferenceId']">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
                <cc:cloud-log id="LogErrorMsg" condition="props['inLogLevel'] == 'error'" level="error" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="HTML" reference-id="props['inLogReferenceId']">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
                <cc:cloud-log id="LogCriticalMsg" condition="props['inLogLevel'] == 'critical'" level="critical" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="HTML" reference-id="props['inLogReferenceId']">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="LogCounts_109" routes-to="WriteLog_109">
            <cc:steps>
                <cc:eval id="UpdateLogCounts">
						<cc:expression>(props['inLogLevel'] == 'debug') ? props['globalLogCountDebug'] = props['globalLogCountDebug'] + 1;</cc:expression>
						<cc:expression>(props['inLogLevel'] == 'info') ? props['globalLogCountInfo'] = props['globalLogCountInfo'] + 1;</cc:expression>
						<cc:expression>(props['inLogLevel'] == 'warn') ? props['globalLogCountWarn'] = props['globalLogCountWarn'] + 1;</cc:expression>
						<cc:expression>(props['inLogLevel'] == 'error') ? props['globalLogCountError'] = props['globalLogCountError'] + 1;</cc:expression>
						<cc:expression>(props['inLogLevel'] == 'critical') ? props['globalLogCountCritical'] = props['globalLogCountCritical'] + 1;</cc:expression>
                    <cc:expression>props['globalLogCountTotal'] = props['globalLogCountTotal'] + 1;</cc:expression>
                    <cc:expression>props['globalLogCountByLogFile'] = props['globalLogCountByLogFile'] + 1;</cc:expression>
					</cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="CreateLogEntry" routes-to="LogCounts_109" access="public" icon="icons/CreateLogEntry.png">
            <cc:parameter name="inLogMessage" required="true" type="string"/>
            <cc:parameter default="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message" name="inLogMessageDetail" required="false" type="string"/>
            <cc:parameter name="inLogReferenceId" required="false" type="string"/>
            <cc:parameter name="inLogLevel" required="true" type="string" validation="['debug','info','warn','error','critical'] contains props['inLogLevel'].trim().toLowerCase()"/>
            <cc:parameter default="context.errorComponentId" name="inExtraLocalIn" required="false" type="string"/>
            <cc:parameter name="inExtraRecordNumber" required="false" type="string"/>
            <cc:parameter name="inExtraSupportData" required="false" type="string"/><cc:parameter name="inExtraErrorCode" required="false" type="string"/>
        </cc:local-in>
        <cc:local-out id="PIM_Info_Finish_109" endpoint="vm://wcc/PutIntegrationMessage" clone-request="true">
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="'Initialization of logging component finished.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Critical_SetupFailure_109" routes-response-to="InitializeLog_Handler_109" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'CRITICAL'"/>
            <cc:set name="is.message.summary" value="'Initialization of logging component failed.  Immediate halt to integration processing.'"/>
            <cc:set name="is.message.storage.enabled" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="InitializeLog_Handler_109">
            <cc:steps>
                <cc:eval id="Abort">
						<cc:expression>context.setAbort(true);</cc:expression>
					</cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="InitializeLog_109" routes-to="PIM_Info_Finish_109">
            <cc:steps>
                <cc:eval id="SetupLog">
						<cc:expression>props['globalLogFilename'] = intsys.getAttribute('Log File Name (Exclude File Extension)') == empty ? 'Log' : intsys.getAttribute('Log File Name (Exclude File Extension)')</cc:expression>
						<cc:expression>props['globalLogExpires'] = intsys.getAttribute('Log Retention in Days') == empty ?  'P30D' : 'P' + intsys.getAttribute('Log Retention in Days') + 'D'</cc:expression>
         <cc:expression>props['globalLogMaxCountPerFile'] = intsys.getAttribute('Max Entries per Log File') == empty ? 0 : intsys.getAttribute('Max Entries per Log File')</cc:expression>
         <cc:expression>props['globalLogCountByLogFile'] = 0</cc:expression>
						<cc:expression>props['globalLogCountDebug'] = 0</cc:expression>
						<cc:expression>props['globalLogCountInfo'] = 0</cc:expression>
						<cc:expression>props['globalLogCountWarn'] = 0</cc:expression>
						<cc:expression>props['globalLogCountError'] = 0</cc:expression>
						<cc:expression>props['globalLogCountCritical'] = 0</cc:expression>
         <cc:expression>props['globalLogCountTotal'] = 0</cc:expression>
         <cc:expression>props['globalLogFilesStored'] = 0</cc:expression>
					</cc:eval>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="PIM_Critical_SetupFailure_109"/>
        </cc:async-mediation>
        <cc:local-out id="PIM_Info_Start_109" routes-response-to="InitializeLog_109" endpoint="vm://wcc/PutIntegrationMessage" clone-request="true" propagate-abort="false">
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="'Initialization of logging component started.'"/>
        </cc:local-out>
        <cc:local-in id="SetupLog" routes-to="PIM_Info_Start_109" access="public"/>
        <cc:local-out id="Call_StoreLog_GEH" routes-response-to="Call_Debug_Finalize_GEH" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/StoreLog" propagate-abort="false">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="PIM_CriticalUnhandledException_GEH" routes-response-to="Call_StoreLog_GEH" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'CRITICAL'"/>
            <cc:set name="is.message.summary" value="'An unhandled error was encountered!'"/>
            <cc:set name="is.message.detail" value="'Error Message: ' + context.getErrorMessage()"/>
        </cc:local-out>
        <cc:send-error id="GlobalErrorHandler" routes-to="PIM_CriticalUnhandledException_GEH"/>
        <cc:async-mediation id="InitializeCoreStarterKit_109">
            <cc:steps>
                <cc:eval id="IntSystem">
                    <cc:expression>props['globalDocumentRetentionPeriod'] = 'P' # ((intsys.getAttribute('Document Retention in Days') == null) ? '30' : intsys.getAttribute('Document Retention in Days')) # 'D';</cc:expression>
                </cc:eval>
                <cc:eval id="LaunchParameters">
                    <cc:expression>props['globalIsValidationMode'] = (lp.exists('Run in Validation Mode') ? (Boolean) lp.getSimpleData('Run in Validation Mode') : false);&#xd;
props['globalIsDebugMode'] = (lp.exists('Run with Debug Logging') ? (Boolean) lp.getSimpleData('Run with Debug Logging') : false);</cc:expression>
                </cc:eval>
                <cc:eval id="Debug">
                    <cc:expression>props['globalDebugPropertyList'] = new java.util.ArrayList();</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalDocumentRetentionPeriod');&#xd;
props['globalDebugPropertyList'].add('globalIsValidationMode');&#xd;
props['globalDebugPropertyList'].add('globalIsDebugMode');</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_StoreLog" store-message="none" routes-response-to="Call_Debug_Finalize" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/StoreLog">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="Call_Main" store-message="none" endpoint="@{props['inMainEndpoint']}" propagate-abort="false"/>
        <cc:local-out id="Call_SetupGlobal" store-message="none" routes-response-to="Call_IEP_10" endpoint="@{props['inInitializationEndpoint'] == empty ? 'vm://INT200_Ceridian_Dayforce_PostProcessor/SetupGlobal' : props['inInitializationEndpoint']}" unset-properties="false"/>
        <cc:local-out id="Call_SetupLog" store-message="none" routes-response-to="Call_SetupGlobal" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/SetupLog" propagate-abort="true"/>
        <cc:async-mediation id="Initialize_Handler">
            <cc:steps>
                <cc:eval id="Abort">
                    <cc:expression>context.setAbort(true);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_Initialize_Error" store-message="none" routes-response-to="Call_StoreLog_Initialize" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="'An error occurred within the integration flow and has been caught at the top-level just before the Global Error Handler.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="'InitializeCloudCollectionReference'"/>
            
            <cc:set name="inExtraSupportData"/>
        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/></cc:local-out>
        <cc:async-mediation id="Initialize" routes-to="Call_SetupLog" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetConstantValues">
                    <cc:expression>props['globalStudioStarterKitVersion'] = 'v1.0'; //This property is set for reference purposes only.  </cc:expression>
                    <cc:expression>props['globalApiVersion'] = 'v35.0';&#xd;
props['globalDebugArchiveFilename'] = 'DebugFiles_INT200.zip';</cc:expression>
                    <cc:expression>props['globalStringDeduplicator'] = new com.workday.custom.int200.postprocessor.sa109.StringDeduplicator();</cc:expression>
                    <cc:expression>props['globalDebugTargetTypeParameterValidation'] = new java.util.HashSet();&#xd;
props['globalDebugTargetTypeParameterValidation'].add('message');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('property');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('properties');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('variable');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('map');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('list');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('set');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('finalize');</cc:expression>
                    <cc:expression>props['globalDebugTargetNameParameterValidation'] = new java.util.HashSet();&#xd;
props['globalDebugTargetNameParameterValidation'].add('message');&#xd;
props['globalDebugTargetNameParameterValidation'].add('property');&#xd;
props['globalDebugTargetNameParameterValidation'].add('properties');&#xd;
props['globalDebugTargetNameParameterValidation'].add('variable');&#xd;
props['globalDebugTargetNameParameterValidation'].add('map');&#xd;
props['globalDebugTargetNameParameterValidation'].add('list');&#xd;
props['globalDebugTargetNameParameterValidation'].add('set');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntry_Initialize_Error"/>
        </cc:async-mediation>
        <cc:workday-in id="StartHere" routes-to="Call_InitializeFrameworkThenRunMain">
            <cc:integration-system name="INT200 Ceridian Dayforce PostProcessor">
        <cloud:param name="Run in Validation Mode">
          <cloud:type>
            <cloud:simple-type>boolean</cloud:simple-type>
          </cloud:type>
          <cloud:default>
            <cloud:boolean>false</cloud:boolean>
          </cloud:default>
        </cloud:param>
        <cloud:param name="Run with Debug Logging">
          <cloud:type>
            <cloud:simple-type>boolean</cloud:simple-type>
          </cloud:type>
          <cloud:default>
            <cloud:boolean>false</cloud:boolean>
          </cloud:default>
        </cloud:param>
        <cloud:attribute-map-service name="INT200 Ceridian Dayforce PostProcessor Attribute Map Service - General">
          <cloud:attribute name="Document Retention in Days">
            <cloud:type>
              <cloud:simple-type>number</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
        </cloud:attribute-map-service>
        <cloud:attribute-map-service name="INT200 Ceridian Dayforce PostProcessor Attribute Map Service - Logging">
          <cloud:attribute name="Log File Name (Exclude File Extension)">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Log Retention in Days">
            <cloud:type>
              <cloud:simple-type>number</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Max Entries per Log File">
            <cloud:type>
              <cloud:simple-type>number</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
        </cloud:attribute-map-service>
        <cloud:attribute-map-service name="INT200 Ceridian Dayforce PostProcessor Attribute Map Service - Functional">
          <cloud:attribute name="Retrieval Document Name">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="SourceIdentifier Field Value">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
            <cloud:display-option>required-for-launch</cloud:display-option>
          </cloud:attribute>
          <cloud:attribute name="ClientXrefCode Field Value">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
            <cloud:display-option>required-for-launch</cloud:display-option>
          </cloud:attribute>
          <cloud:attribute name="BatchName Field Value">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="John Hancock Division XrefCode Field Value">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
            <cloud:display-option>required-for-launch</cloud:display-option>
          </cloud:attribute>
          <cloud:attribute name="John Hancock Union XrefCode Field Value">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
            <cloud:display-option>required-for-launch</cloud:display-option>
          </cloud:attribute>
          <cloud:attribute name="John Hancock Pension Eligibility XrefCode Field Value">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
            <cloud:display-option>required-for-launch</cloud:display-option>
          </cloud:attribute>
          <cloud:attribute name="Inactive LOA Types">
            <cloud:type>
              <cloud:class-report-field description="Leave Types" type="WID" singular="false">e001ee2bed734a8d9650aac277668d37</cloud:class-report-field>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Earning Code for Pay Period Tax">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
            <cloud:display-option>required-for-launch</cloud:display-option>
          </cloud:attribute>
          <cloud:attribute name="Pay Group for Pay Period Tax">
            <cloud:type>
              <cloud:class-report-field description="Pay Group" type="WID" singular="true">c87103150f3b4dc6a7ea7658da35029d</cloud:class-report-field>
            </cloud:type>
          </cloud:attribute>
          <cloud:map name="Pay Groups to Period Schedules">
            <cloud:internal-type>
              <cloud:class-report-field description="Pay Group" type="WID">c87103150f3b4dc6a7ea7658da35029d</cloud:class-report-field>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="Expression Code Types">
            <cloud:internal-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="Deduction Limit Code Types">
            <cloud:internal-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="Role Code Types">
            <cloud:internal-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="Earning and Deduction Types">
            <cloud:internal-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="Boolean Code Types">
            <cloud:internal-type>
              <cloud:simple-type>boolean</cloud:simple-type>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="State Codes">
            <cloud:internal-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="Contact Code Types">
            <cloud:internal-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="HSA Codes">
            <cloud:internal-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>boolean</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="Earning Expansion Codes">
            <cloud:internal-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
        </cloud:attribute-map-service>
        <cloud:sequence-generator-service name="INT200 Ceridian Dayforce PostProcessor Sequence Generator Service">
          <cloud:sequencer>INT200 Sequence Generator HRImport</cloud:sequencer>
          <cloud:sequencer>INT200 Sequence Generator EmployeeElection</cloud:sequencer>
          <cloud:sequencer>INT200 Sequence Generator PayEntryImport</cloud:sequencer>
          <cloud:sequencer>INT200 Sequence Generator PayEntryImport OffCycle</cloud:sequencer>
        </cloud:sequence-generator-service>
        <cloud:report-service name="INT200 Ceridian Dayforce PostProcessor Report Service">
          <cloud:report-alias description="CR INT200 Worker Data" name="Worker Data"/>
          <cloud:report-alias description="CR INT200 Pay Period Details" name="Period Data"/>
        </cloud:report-service>
      </cc:integration-system>
        </cc:workday-in>
        <cc:async-mediation id="InitializeAttributesAndLaunchParameters" routes-to="Call_RetrievePECI">
            <cc:steps>
                <cc:eval id="Attributes">
                    <cc:expression>props['globalRetrievalDocName'] = ((intsys.getAttribute('Retrieval Document Name') == null) ? 'Aggregate2Output.xml' : intsys.getAttribute('Retrieval Document Name'));&#xd;
props['globalSourceIdentifier'] = ((intsys.getAttribute('SourceIdentifier Field Value') == null) ? null : intsys.getAttribute('SourceIdentifier Field Value'));&#xd;
props['globalClientXrefCode'] = ((intsys.getAttribute('ClientXrefCode Field Value') == null) ? null : intsys.getAttribute('ClientXrefCode Field Value'));&#xd;
props['globalBatchName'] = ((intsys.getAttribute('BatchName Field Value') == null) ? 'Workday' : intsys.getAttribute('BatchName Field Value'));&#xd;
props['globalThirdPartyDivisionXrefCode'] = ((intsys.getAttribute('John Hancock Division XrefCode Field Value') == null) ? null : intsys.getAttribute('John Hancock Division XrefCode Field Value'));&#xd;
props['globalThirdPartyUnionXrefCode'] = ((intsys.getAttribute('John Hancock Union XrefCode Field Value') == null) ? null : intsys.getAttribute('John Hancock Union XrefCode Field Value'));&#xd;
props['globalThirdPartyPensionEligibilityXrefCode'] = ((intsys.getAttribute('John Hancock Pension Eligibility XrefCode Field Value') == null) ? null : intsys.getAttribute('John Hancock Pension Eligibility XrefCode Field Value'));&#xd;
props['globalPayPeriodTaxEarningCode'] = intsys.getAttribute('Earning Code for Pay Period Tax');&#xd;
props['globalPayPeriodTaxPayGroup'] = intsys.getAttributeReferenceData('Pay Group for Pay Period Tax', 'Organization_Reference_ID');</cc:expression>
                    <cc:expression>props['globalLoaInactiveCodes'] = util.listToCommaDelimString(intsys.getAttributeReferenceDataList('Inactive LOA Types', 'Leave_of_Absence_Type_ID'));</cc:expression>
                </cc:eval>
                <cc:eval id="LaunchParameters">
                    <cc:expression>props['globalOffCycleTimestamp'] = org.apache.commons.lang3.StringUtils.replace(com.workday.custom.int200.postprocessor.DateUtils.convertDateTimeToXmlString(new java.util.Date()), ':', '-');&#xd;
&#xd;
props['globalFilenameHRImport'] = lp.getSequencedValue('INT200 Sequence Generator HRImport');&#xd;
props['globalFilenameEmployeeElection'] = lp.getSequencedValue('INT200 Sequence Generator EmployeeElection');&#xd;
props['globalFilenamePayEntryImport'] = lp.getSequencedValue('INT200 Sequence Generator PayEntryImport');&#xd;
props['globalFilenamePayEntryImportOffCycle'] = lp.getSequencedValue('INT200 Sequence Generator PayEntryImport OffCycle') # '_' # props['globalOffCycleTimestamp'];</cc:expression>
                </cc:eval>
                <cc:eval id="Static">
                    <cc:expression>props['globalRaasPromptStart'] = 'Start';&#xd;
props['globalRaasPromptEnd'] = 'End';&#xd;
props['globalRaasPromptEarlyStart'] = 'EarlyStart';&#xd;
props['globalRaasPromptEarlyEnd'] = 'EarlyEnd';&#xd;
props['globalRaasPromptLateStart'] = 'LateStart';&#xd;
props['globalRaasPromptLateEnd'] = 'LateEnd';</cc:expression>
                    <cc:expression>props['globalRaasPromptPeriodDate'] = 'Period_Date';</cc:expression>
                    <cc:expression>props['globalPeriodScheduleHsaYearMap'] = new java.util.HashMap();</cc:expression>
                    <cc:expression>props['globalMapNamePayGroupSchedule'] = 'Pay Groups to Period Schedules';&#xd;
props['globalMapNameEarningsExpansion'] = 'Earning Expansion Codes';&#xd;
props['globalMapNameExpressionCode'] = 'Expression Code Types';&#xd;
props['globalMapNameHsaCode'] = 'HSA Codes';</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>props['globalDebugPropertyList'].add('globalApiVersion');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalRetrievalDocName');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalSourceIdentifier');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalClientXrefCode');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalBatchName');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalThirdPartyDivisionXrefCode');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalThirdPartyUnionXrefCode');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalThirdPartyPensionEligibilityXrefCode');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalPayPeriodTaxEarningCode');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalPayPeriodTaxPayGroup');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalLoaInactiveCodes');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalOffCycleTimestamp');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalFilenameHRImport');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalFilenameEmployeeElection');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalFilenamePayEntryImport');</cc:expression>
                    <cc:expression>props['globalDebugPropertyList'].add('globalFilenamePayEntryImportOffCycle');</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Results_Handler_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Results_Error_103" store-message="none" routes-response-to="Results_Handler_103" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the SOAP results from the message rootpart to variable globalSoapResults.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
         </cc:local-out>
        <cc:async-mediation id="Results_103" execute-steps-when="props['inReturnResults'] == 'variable'">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="globalSoapResults"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_103"/>
        </cc:async-mediation>
        <cc:async-mediation id="RouteError_Http_Handler_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'http';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_HttpError_Error_103" store-message="none" routes-response-to="RouteError_Http_Handler_103" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application HTTP request error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing a SOAP request for the '# props['inWebServiceApplication'] #' application.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
        </cc:local-out>
        <cc:async-mediation id="CallSoap_Catch_103" routes-to="CallSoap_103" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="RouteError_103"/>
        </cc:async-mediation>
        <cc:workday-out-soap id="CallSoap_103" routes-response-to="Call_Debug_SoapResponse_103" application="@{props['inWebServiceApplication']}" version="@{props['inApiVersion']}"/>
        <cc:async-mediation id="Transform_Handler_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Transform_Error_103" store-message="none" routes-response-to="Transform_Handler_103" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'SOAP Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a SOAP service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
         </cc:local-out>
        <cc:async-mediation id="Transform_103" routes-to="Call_Debug_SoapXslt_103">
            <cc:steps>
                <cc:xslt-plus id="WriteSoap" url="@{props['inPathToXsltFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Transform_Error_103"/>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareVariableInput_103" routes-to="Transform_103" execute-steps-when="props['localIsNonEmptyMapVariable']">
            <cc:steps>
                <cc:eval id="PrimeMessage">
                    <cc:expression>varname = props['inMapVariableName'];&#xd;
parts[0] = vars[varname];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareMapInput_103" routes-to="PrepareVariableInput_103" execute-steps-when="(!props['localIsValuedProperty'] &amp;&amp; !props['localIsValuedVariable']) || props['localIsNonEmptyMapProperty']">
            <cc:steps>
                <cc:write id="PrimeMessage">
                    <cc:message>
                        <cc:text>&lt;?xml version="1.0" encoding="UTF-8"?>&#xd;
&lt;Root/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Validation_Handler_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Validation_Error_103" store-message="none" routes-response-to="Validation_Handler_103" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'SOAP Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating the parameters for a SOAP service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            
            
            
         </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_103" routes-to="Call_BuildRequest_103" routes-response-to="Call_Finally_103">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outIsSoapError'] = '';</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_103">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsValuedProperty','localIsDefinedProperty','localIsCorrectTypeProperty','localIsNonEmptyMapProperty','localIsValuedVariable','localIsDefinedVariable','localIsCorrectTypeVariable','localIsNonEmptyMapVariable']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_103" routes-to="Teardown_103"/>
        <cc:local-out id="Call_Finally_103" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_103"/>
        <cc:local-in id="CallSoap" routes-to="InitializeAndFinalize_103" access="public" icon="icons/CallSoap.png">
            <cc:parameter default="props['globalApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;." name="inWebServiceApplication" required="true" type="string"/>
            <cc:parameter default="true" documentation="Sub-assembly supports pre-built, on-message requests as well as facilities to construct the request dynamically.  Set this parameter to true to bypass the dynamic request construction and use the message root part as the request.  If set to false, then the inPathToXsltFile and the inMapPropertyName or inMapVariableName parameters should be set." name="inUseMessageRootPartAsRequest" required="true" type="boolean"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;." name="inPathToXsltFile" required="!props['inUseMessageRootPartAsRequest']" type="string"/>
            <cc:parameter documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inMapPropertyName" required="false" type="string"/>
            <cc:parameter documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example." name="inMapVariableName" required="false" type="string"/>
            <cc:parameter default="'variable'" documentation="How the SOAP results are returned to the caller, either on the message if the value is 'message', or in the 'globalSoapResults' variable if the value is 'variable', which is the default." name="inReturnResults" required="true" type="string" validation="props['inReturnResults'] == 'variable' || props['inReturnResults'] == 'message'"/>
            <cc:parameter default="props['globalIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['globalIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
        	<cc:out-parameter documentation="A string to indicate that the request resulted in an error and identify the type.  If the error was at the API level, then outIsSoapError == 'http'.  If the error was at the tenant/application level, then outIsSoapError == 'soap'.  If there was an error unrelated to the API call, then outIsSoapError == 'logic'.  If there is no error, , then outIsSoapError == empty.  Further individual errors determined by Get_Event_Details or Get_Import_Processes are not handled here." name="outIsSoapError"/>
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntry_Error_105" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            
        <cc:set name="inLogMessage" value="'Error generated during loading of Java Map'"/><cc:set name="inLogMessageDetail" value="parts[0].xpath('/Error')"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_Error_105'"/></cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Warn_105" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry"><cc:set name="inLogMessage" value="'Warning generated during loading of Java Map'"/><cc:set name="inLogMessageDetail" value="parts[0].xpath('/Warning')"/><cc:set name="inLogLevel" value="'warn'"/><cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_Warn_105'"/>
        </cc:local-out>
        <cc:route id="RouteMessages_105">
            <cc:xpath-strategy>
                <cc:choose-route expression="exists( /Warning )" route="Warning"/>
                <cc:choose-route expression="exists( /Error )" route="Error"/>
            </cc:xpath-strategy>
            <cc:sub-route name="Warning" routes-to="Call_CreateLogEntry_Warn_105"/>
            <cc:sub-route name="Error" routes-to="Call_CreateLogEntry_Error_105"/>
        </cc:route>
        <cc:splitter id="Splitter_105" no-split-message-error="false">
            <cc:sub-route name="RouteResult" routes-to="RouteMessages_105"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:sync-mediation id="LoadMap_105" routes-to="Splitter_105">
            <cc:request-steps>
                <cc:xslt-plus id="LoadMap" url="mctx:vars/localPjmXslt"/>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_LoadMap_Error_105"/>
        </cc:sync-mediation>
        <cc:sync-mediation id="PrepareForLoadMap_105" routes-to="LoadMap_105" routes-response-to="Call_Finally_105">
            <cc:request-steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10500" failure-message="Property 'inMap' does not contain a Java Map">map = props['inMap'];
return (map == null ) ||
	(( map != null) &amp;&amp; (map instanceof java.util.Map));</cc:expression>
                </cc:validate-exp>
                <cc:eval id="SetValues">
                    <cc:expression>props['outMap'] = props['inMap'];</cc:expression>
                    <cc:expression>// If the map property is not current assigned then create a new HashMap in it
if (props['outMap'] == empty) {&#xd;
	props['outMap'] = new java.util.HashMap();&#xd;
}</cc:expression>
                    <cc:expression>props['localMapPropertyName'] = 'outMap'</cc:expression>
                </cc:eval>
                <cc:write id="LoadXslt" output="variable" output-variable="localPjmXslt">
                    <cc:message>
                        <cc:text>&lt;?xml version="1.0" encoding="UTF-8"?>&#xd;
&lt;xsl:stylesheet version="3.0" &#xd;
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&#xd;
    xmlns:tube="java:com.capeclear.mediation.impl.cc.MediationTube"&#xd;
    xmlns:ctx="java:com.capeclear.mediation.MediationContext"&#xd;
    xmlns:xs="http://www.w3.org/2001/XMLSchema"&#xd;
    xmlns:jmap="java:java.util.Map"&#xd;
    xmlns:jt="http://saxon.sf.net/java-type"&#xd;
    xmlns:this="urn:this">&#xd;
    &#xd;
    &lt;xsl:param name="inStoreDataAs" as="xs:string"/>&#xd;
    &lt;xsl:param name="inQueryToEntry" as="xs:string"/>&#xd;
    &lt;xsl:param name="inQueryToKey" as="xs:string"/>&#xd;
    &lt;xsl:param name="inQueryToValue" as="xs:string"/>&#xd;
    &lt;xsl:param name="localMapPropertyName" as="xs:string"/>&#xd;
    &lt;xsl:param name="inEmptyValueIsError" as="xs:boolean" select="true()"/>&#xd;
    &#xd;
    &lt;!-- This stylesheet is designed to be streamable so that only one record is held in memory at any one time -->&#xd;
    &lt;xsl:mode streamable="yes" on-no-match="shallow-skip"/>&#xd;
    &lt;xsl:mode streamable="no" name="in-memory"/>&#xd;
    &#xd;
    &lt;!-- Obtain the current MediationContext in use in the assembly -->&#xd;
    &lt;xsl:variable name="ctx" select="tube:getCurrentMediationContext()"/>&#xd;
    &#xd;
    &lt;!-- Retrieve the Java Map stored in the context property named HashMap -->&#xd;
    &lt;xsl:variable name="Map" select="ctx:getProperty($ctx, $localMapPropertyName)" as="jt:java.util.Map"/>&#xd;
    &#xd;
    &lt;!-- Based on the configuration of the StoreDataAs property determine the function which will be used to store the values in the map.  Using the function reference allows us to avoid the inefficiency of comparing the value of StoreDataAs for each entry -->&#xd;
    &lt;xsl:variable name="StoreDataInMap" select="if ( $inStoreDataAs = 'SimpleString') then this:StoreDataAsSimpleString#2 else if ($inStoreDataAs = 'DOM') then this:StoreDataAsDOM#2 else this:StoreDataAsXMLString#2" />&#xd;
    &#xd;
    &lt;xsl:template match="/">&#xd;
        &lt;MapHelper>&#xd;
            &lt;xsl:if test="$inStoreDataAs = 'XMLString'">&#xd;
                &lt;Warning>Map entries are configured to be stored as XMLStrings.  Using this will require that data is re-parsed every time the data is used.  This could impose a significant runtime performance overhead if each entry is, on average, accessed more than once&lt;/Warning>&#xd;
            &lt;/xsl:if>&#xd;
            &lt;xsl:if test="$inStoreDataAs = 'DOM'">&#xd;
                &lt;Warning>Map entries are configured to be stored as an XML DOM.  Using this option may require large amounts of memory.  Consider transforming the data before storage so as to only store the minimum required.  For very large documents consider moving to a custom Java solution with optimized data storage&lt;/Warning>&#xd;
            &lt;/xsl:if>&#xd;
            &#xd;
            &lt;!-- Now process the input file.  The EntryFilter variable can then be optionally used to only select those entries matching that value.  The filter can only navigate the descendant axis since only the node and and descendants returned by the QueryToEntry expression are brought into memory -->&#xd;
            &lt;xsl:apply-templates select="copy-of(@{props['inQueryToEntry']}@if{props['inEntryFilter'] != empty}[@{props['inEntryFilter']}]@end{})" mode="in-memory"/>    		&#xd;
        &lt;/MapHelper>&#xd;
    &lt;/xsl:template>&#xd;
    &#xd;
    &lt;!-- Process each entry -->&#xd;
    &lt;xsl:template match="*" mode="in-memory">&#xd;
        &lt;xsl:variable name="key"	select="@{props['inQueryToKey']}"/>&#xd;
        &lt;xsl:variable name="value"	select="@{props['inQueryToValue']}"/>&#xd;
        &#xd;
        &lt;xsl:choose>&#xd;
            &lt;!-- If we've no key then we have no option but to generate an error -->&#xd;
            &lt;xsl:when test="not(exists($key))">&#xd;
                &lt;Error>&#xd;
                    &lt;Message>&lt;xsl:text expand-text="yes">No key matching {$inQueryToKey} found in record&lt;/xsl:text>&lt;/Message>&#xd;
                    &lt;Record>&lt;xsl:copy-of select="."/>&lt;/Record>&#xd;
                &lt;/Error>&#xd;
            &lt;/xsl:when>&#xd;
            &#xd;
            &lt;!-- If we've no value and we're configured to treat no value as an error then output that error, otherwise we'll put the empty value into the map -->&#xd;
            &lt;xsl:when test="not(exists($value)) and $inEmptyValueIsError">&#xd;
                &lt;Error>&#xd;
                    &lt;Message>&lt;xsl:text expand-text="yes">No value matching {$inQueryToValue} found in record&lt;/xsl:text>&lt;/Message>&#xd;
                    &lt;Record>&lt;xsl:copy-of select="."/>&lt;/Record>&#xd;
                &lt;/Error>				&#xd;
            &lt;/xsl:when>&#xd;
            &#xd;
            &lt;!-- Store the value in the map -->&#xd;
            &lt;xsl:otherwise>&#xd;
                &lt;xsl:value-of select="$StoreDataInMap($key,$value)"/>&#xd;
            &lt;/xsl:otherwise>&#xd;
        &lt;/xsl:choose>&#xd;
    &lt;/xsl:template>&#xd;
    &#xd;
    &lt;xsl:function name="this:StoreDataAsSimpleString">&#xd;
        &lt;xsl:param name="key" as="xs:string"/>&#xd;
        &lt;xsl:param name="value" as="item()"/>&#xd;
        &lt;xsl:value-of select="jmap:put($Map, string($key), string($value))"/>&#xd;
    &lt;/xsl:function>&#xd;
    &#xd;
    &lt;xsl:function name="this:StoreDataAsXMLString">&#xd;
        &lt;xsl:param name="key" as="xs:string"/>&#xd;
        &lt;xsl:param name="value" as="item()"/>&#xd;
        &lt;xsl:value-of select="jmap:put($Map, string($key), serialize($value))"/>&#xd;
    &lt;/xsl:function>&#xd;
    &#xd;
    &lt;!-- &#xd;
    	This function is provided for future expansion.  There is no native way to export DOM information through Saxon Java extension functions such that the DOM (or NodeInfo) information can be processed&#xd;
    	elsewhere in the assembly since the Saxon Processor which was used to produce this information is not available to us outside of the XsltPlus step.&#xd;
    	&#xd;
    	In future, access to parsed DOM of the data will be provided through a Java extension function and a DOM implementation optimized for Workday-like data and map configurations.&#xd;
     -->&#xd;
    &lt;xsl:function name="this:StoreDataAsDOM" >&#xd;
        &lt;xsl:param name="key" as="xs:string"/>&#xd;
        &lt;xsl:param name="value" as="item()"/>&#xd;
		&lt;xsl:value-of select="jmap:put($Map, string($key), $value)"/>&#xd;
		&lt;xsl:message terminate="yes" select="'Storage of DOM values in the map are not yet implemented'"/>&#xd;
	&lt;/xsl:function>&#xd;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
            </cc:request-steps>
            <cc:response-steps>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-in id="PopulateJavaMap" routes-to="PrepareForLoadMap_105" access="public" icon="icons/PopulateJavaMap.png">
            
            
            
            
            <cc:parameter documentation="The Java Map which is to be populated with the current message" name="inMap" required="false"/>
            
            <cc:parameter default="'SimpleString'" documentation="Determines whether the map will be populated with simple string values, an in-memory DOM or an XML String" name="inStoreDataAs" required="false" validation="['SimpleString','XMLString'].contains(props['inStoreDataAs'])"/><cc:parameter documentation="The XPath expression selecting the records which contain the information to be put into the Map" name="inQueryToEntry" required="true" type="string" validation="props['inQueryToEntry'].trim().length() > 0"/><cc:parameter documentation="XPath expression which can optionally be executed against the elements returned by QueryToEntry in order to determine if those entries should be stored in the map" name="inEntryFilter" required="false" type="string"/>
            
            <cc:parameter documentation="The XPath expression to select the Map key from each record.  This expression is executed against the element returned by the QueryToEntry expression" name="inQueryToKey" required="true" type="string" validation="props['inQueryToKey'].trim().length() > 0"/>
            <cc:parameter documentation="The XPath expression which returns the value to be stored in the map when executed against the element returned by the QueryToEntry expression" name="inQueryToValue" required="true" type="string" validation="props['inQueryToValue'].trim().length() > 0"/><cc:parameter default="true" documentation="Controls whether empty map values are to be treated as errors" name="inEmptyValueIsError" required="false" type="boolean"/><cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:out-parameter documentation="The Java Map which will have been populated with the data in the current message" name="outMap"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_Results_Error_102" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the RaaS results from the message rootpart to variable globalRaaSResults.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="Results_102" routes-to="Call_Debug_Result_102" execute-steps-when="props['inReturnResults'] == 'variable'">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="globalRaaSResults"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_102"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_CallRaaS_Error_102" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="CallRaaS_Catch_102" routes-to="CallRaaS_102" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CallRaaS_Error_102"/>
        </cc:async-mediation>
        <cc:workday-out-rest id="CallRaaS_102" extra-path="@{props['localRestUrl']}" method="GET"/>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_102" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_102" routes-to="ChooseProtocol_102" continue-after-error="rewind" handle-downstream-errors="true" routes-response-to="Call_Finally_102">
            <cc:request-steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsPromptsProvided'] = props['inPropertyNameReportPromptMap'] != empty;</cc:expression>
                    <cc:expression>props['localIsPromptsMap'] = (props['localIsPromptsProvided']) ? (context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map) : false;&#xd;
props['localIsPromptsEmpty'] = (props['localIsPromptsProvided']) ? (context.getProperty(props['inPropertyNameReportPromptMap']).isEmpty()) : false;</cc:expression>
                    <cc:expression>props['localIsPromptsValid'] = (!props['localIsPromptsProvided']) || (props['localIsPromptsMap'] &amp;&amp; !props['localIsPromptsEmpty']);</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10200" failure-message="The map contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap was either empty, or it was not a map.">props['localIsPromptsValid']</cc:expression>
                </cc:validate-exp>
                <cc:eval id="BuildURL">
                    <cc:expression>props['localRestUrl'] = intsys.reportService.getExtrapath(props['inReportServiceAlias']);</cc:expression>
                    <cc:expression>props['localQuerystring'] = '';</cc:expression>
                    <cc:expression>if (props['localIsPromptsProvided']) {&#xd;
	props['localKeyValueMap'] = context.getProperty(props['inPropertyNameReportPromptMap']);&#xd;
&#xd;
	foreach (mapKey : props['localKeyValueMap'].keySet()) {&#xd;
		if (props['localQuerystring'] != empty) {props['localQuerystring'] = props['localQuerystring'] # '&amp;';}&#xd;
&#xd;
		mapValue = props['localKeyValueMap'].get(String.valueOf(mapKey));&#xd;
		if (mapValue instanceof java.util.AbstractCollection) {&#xd;
			props['localQuerystring'] = props['localQuerystring'] # String.valueOf(mapKey) # '=' # com.workday.custom.int200.postprocessor.sa102.ParameterMapHelper.transformCollectionParameterToQueryString(mapValue, props.inIsUseJavaUrlEncoder);&#xd;
		} else {&#xd;
			props['localQuerystring'] = props['localQuerystring'] # String.valueOf(mapKey) # '=' # com.workday.custom.int200.postprocessor.sa102.ParameterMapHelper.urlEscapeValue(String.valueOf(mapValue), props.inIsUseJavaUrlEncoder);&#xd;
		}&#xd;
	}&#xd;
	props['localRestUrl'] = props['localRestUrl'] # '?' # props['localQuerystring'];&#xd;
}</cc:expression>
                    <cc:expression>props['localIsValidUrlLength'] = props['localRestUrl'].getBytes().length &lt;= 16000;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_102"/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_102">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsPromptsProvided','localIsPromptsValid','localRestUrl','localQuerystring','localKeyValueMap','localIsPromptsMap','localIsPromptsEmpty','localFilename','localProgressedToAPI','localIsValidUrlLength']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_102" routes-to="Teardown_102"/>
        <cc:local-out id="Call_Finally_102" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_102"/>
        <cc:local-in id="CallRaaS" routes-to="InitializeAndFinalize_102" access="public" icon="icons/CallRaaS.png">
            <cc:parameter documentation="The Report Service configuration from which to retrieve results." name="inReportServiceAlias" required="true" type="string"/>
            <cc:parameter default="false" documentation="Controls whether or not the RaaS results are saved to a file that is then attached to the Integration Event for support purposes." name="inSaveResultsToIntegrationEvent" required="true" type="boolean"/>
            <cc:parameter documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  If the report is not parameterized, then leave this input parameter empty.  If setting this input parameter though, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap." name="inPropertyNameReportPromptMap" required="false" type="string"/><cc:parameter default="false" documentation="Parameter decides how the prompt values are URLEncoded.  True = use java.net.URLEncoder, which encodes the most characters possible.  False = use implementation in ParameterMapHelper that encodes the minimum characters necessary." name="inIsUseJavaUrlEncoder" required="true" type="boolean"/><cc:parameter default="'variable'" documentation="How the RaaS results are returned to the caller, either on the message if the value is 'message', or in the 'globalRaaSResults' variable if the value is 'variable', which is the default." name="inReturnResults" required="true" type="string" validation="props['inReturnResults'] == 'variable' || props['inReturnResults'] == 'message'"/>
            <cc:parameter default="props['globalIsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_LoadFile_Error_111" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'File Read Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while reading file ' # props['inFilename'] # ' into the globalInputData variable.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['inFileCounter'])"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
         </cc:local-out>
        <cc:async-mediation id="LoadFile_111">
            <cc:steps>
                <cc:eval id="ReadFileIntoVar">
                    <cc:expression>da.toVar(props['inFilename'], 'globalInputData');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_LoadFile_Error_111"/>
        </cc:async-mediation>
        <cc:local-in id="LoadFile" routes-to="LoadFile_111" access="public" icon="icons/LoadFile.png">
            <cc:parameter default="1" documentation="The numeric position of the file in the set of input files to be loaded.  This will match to the /Metadata/File/Counter value in vars[globalDAMetadata] as constructed by GetDocumentList.  If there is only one file, then this should be passed as a 1." name="inFileCounter" required="true" type="integer" validation="props['inFileCounter'] > 0"/><cc:parameter name="inFilename" required="true" type="string"/><cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="PIM_Tag_106" execute-when="props['inOutputIsDeliverable'] == true || props['inOutputDocumentTag'] != empty" endpoint="vm://wcc/PutIntegrationMessage">
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="'Saved file '# props['localFilename'] #' to the Integration Event.'"/>
            <cc:set name="is.document.file.name" value="props['localFilename']"/>
            <cc:set name="is.document.deliverable" value="props['inOutputIsDeliverable'] ? 'true' : 'false'"/>
            <cc:set name="is.message.storage.enabled" value="false"/>
            <cc:set name="is.document.labels" value="props['inOutputDocumentTag']"/>
            <cc:set name="is.document.variable.name" value="'localStoreResult'"/>
        <cc:set name="is.event.wid" value="props['inTargetEventWID']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_StoreVariable_Error_106" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Storage Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while storing data to the Integration Event.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:local-in id="GenerateOutput" routes-to="InitializeAndFinalize_106" access="public" icon="icons/GenerateOutput.png">
            <cc:parameter default="lp.isSet() ? lp.getIntegrationEventWID() : null" name="inTargetEventWID" required="true" type="string"/><cc:parameter default="props['globalOutputFilename']" name="inOutputFilename" required="true" type="string"/>
            <cc:parameter default="props['globalDocumentRetentionPeriod']" documentation="The duration to keep the output file.  Value is of the format &quot;P&quot; followed by a number followed by &quot;D&quot;.  This evaluates to a number of days." name="inDocumentRetentionPeriod" required="true" type="string"/><cc:parameter name="inOutputDocumentTag" required="false" type="string"/><cc:parameter name="inOutputIsDeliverable" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/><cc:parameter default="'message'" documentation="Where to find the data to be output.  If the value is 'variable', then the contents of globalOutputData will be written.  Otherwise, the contents of the message root part will be output." name="inDataSource" required="true" type="string" validation="['variable', 'message'] contains props['inDataSource'].trim().toLowerCase()"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_SingleFileProceed_InitializeAndFinalize_Error_110" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'File Metadata Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while reading the input file and generating the metadata.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:sync-mediation id="SingleFileProceed_InitializeAndFinalize_110">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localRetrievedFilename'] = (props['inRetrievalDocTag'] == empty) ? da.allFileNames.get(0) : da.getFileNames(props['inRetrievalDocTag']).get(0);</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>props['globalDebugPropertyList'].add('localRetrievedFilename');</cc:expression>
                </cc:eval>
                <cc:write id="WriteDocumentAccessorMetadata" output="variable" output-mimetype="text/xml" output-variable="globalDAMetadata">
                    <cc:message>
                        <cc:text>&lt;Metadata>&#xd;
	&lt;File>&#xd;
		&lt;Counter>0&lt;/Counter>&#xd;
		&lt;Name>@{props['localRetrievedFilename']}&lt;/Name>&#xd;
	&lt;/File>&#xd;
&lt;/Metadata>	</cc:text>
                    </cc:message>
                </cc:write>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localRetrievedFilename']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                </cc:eval>
                <cc:eval id="ReduceDebug">
                    <cc:expression>props['globalDebugPropertyList'].add('localRetrievedFilename');</cc:expression>
                </cc:eval>
            </cc:response-steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_SingleFileProceed_InitializeAndFinalize_Error_110"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_CreateLogEntry_SingleFileProceed_Info_110" store-message="none" routes-response-to="SingleFileProceed_InitializeAndFinalize_110" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="'A Document Retrieval Service file was found and loaded.'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(SingleFileProceed)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['localDACount'])"/>
            <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
        </cc:local-out>
        <cc:local-out id="Call_AggregateMetadata_Append_110" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/AggregateMetadata_110">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="MultipleFilesProceed_Iterate_Handler_110">
            <cc:steps>
                <cc:eval id="ClearError">
                    <cc:expression>context.setException(null);</cc:expression>
                    <cc:expression>context.setErrorComponentId(null);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_MultipleFilesProceed_Iterate_Error_110" store-message="none" routes-response-to="MultipleFilesProceed_Iterate_Handler_110" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'File Metadata Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred on iteration loop '# String.valueOf(props['localFileCounter']) #'.  This file will be skipped and processing will attempt to resume with the next file.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="MultipleFilesProceed_Iterate_110" routes-to="Call_AggregateMetadata_Append_110" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localRetrievedFilename'] = props['localRetrievedFilenames'].get(props['localFileCounter']);</cc:expression>
                </cc:eval>
                <cc:write id="WriteDocumentAccessorMetadata">
                    <cc:message>
                        <cc:text>&lt;File>&#xd;
	&lt;Counter>@{props['localFileCounter']}&lt;/Counter>&#xd;
	&lt;Name>@{props['localRetrievedFilename']}&lt;/Name>&#xd;
&lt;/File></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_MultipleFilesProceed_Iterate_Error_110"/>
        </cc:async-mediation>
        <cc:route id="MultipleFilesProceed_ForLoop_110">
            <cc:loop-strategy condition="props['localFileCounter'] &lt; props['localDACount']" increment="props['localFileCounter'] = props['localFileCounter'] + 1" init="props['localFileCounter'] = 0"/>
            <cc:sub-route name="Iterate" routes-to="MultipleFilesProceed_Iterate_110"/>
        </cc:route>
        <cc:local-out id="Call_AggregateMetadata_Finalize_110" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/AggregateMetadata_110">
            <cc:set name="inCollate" value="false"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:sync-mediation id="MultipleFilesProceed_InitializeAndFinalize_110" routes-to="MultipleFilesProceed_ForLoop_110" routes-response-to="Call_AggregateMetadata_Finalize_110">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localRetrievedFilenames'] = (props['inRetrievalDocTag'] == empty) ? da.allFileNames : da.getFileNames(props['inRetrievalDocTag']);</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>props['globalDebugPropertyList'].add('localRetrievedFilenames');</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localRetrievedFilenames','localRetrievedFilename','localFileCounter']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                </cc:eval>
                <cc:eval id="ReduceDebug">
                    <cc:expression>props['globalDebugPropertyList'].remove('localRetrievedFilenames');</cc:expression>
                </cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-out id="Call_CreateLogEntry_MultipleFilesProceed_Info_110" store-message="none" routes-response-to="MultipleFilesProceed_InitializeAndFinalize_110" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Multiple retrieved files were found.'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
            <cc:set name="inLogReferenceId" value="String.valueOf(props['localDACount'])"/>
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(MultipleFilesProceed)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['localDACount'])"/>
            <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_MultipleFilesCountError_Error_110" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'The expected number of files was not found!'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  However, '# props['inExactFileCountExpected'] #' files(s) were expected.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(MultipleFilesCountError)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['localDACount'])"/>
            <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
        	<cc:set name="inExtraErrorCode" value="'11002'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_MultipleFilesError_Error_110" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Too many retrieved files were found!'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  Only a single file is expected.  A multiple-data condition is an error and the output of the Document Retrieval Service should be investigated.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(MultipleFilesError)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['localDACount'])"/>
            <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
        	<cc:set name="inExtraErrorCode" value="'11001'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="NoFileProceed_EmptyMetadata_110">
            <cc:steps>
                <cc:write id="WriteDocumentAccessorMetadata" output="variable" output-mimetype="text/xml" output-variable="globalDAMetadata">
                    <cc:message>
                        <cc:text>&lt;Metadata/>&#xd;
</cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_NoFileProceed_Info_110" store-message="none" routes-response-to="NoFileProceed_EmptyMetadata_110" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="'No retrieved file was found.'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(NoFileProceed)'"/>
            <cc:set name="inExtraRecordNumber" value="'0'"/>
            <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_NoFileError_Error_110" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'No retrieved file was found!'"/>
            <cc:set name="inLogMessageDetail" value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  Data is expected.  A no-data condition is an error and the output of the Document Retrieval Service should be investigated.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(NoFileError)'"/>
            <cc:set name="inExtraRecordNumber" value="'0'"/>
            <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
        	<cc:set name="inExtraErrorCode" value="'11000'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:route id="RouteOnCount_110">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inNoFileThrowsException'] == true &amp;&amp; props['localDACount'] == 0" route="NoFileError"/>
                <cc:choose-route expression="props['inNoFileThrowsException'] == false &amp;&amp; props['localDACount'] == 0" route="NoFileProceed"/>
                <cc:choose-route expression="props['inMultipleFilesThrowsException'] == true &amp;&amp; props['localDACount'] > 1" route="MultipleFilesError"/>
                <cc:choose-route expression="props['inMultipleFilesThrowsException'] == false &amp;&amp; props['inExactFileCountExpected'] > 0 &amp;&amp; (props['localDACount'] != props['inExactFileCountExpected'])" route="MultipleFilesCountError"/>
                <cc:choose-route expression="props['inMultipleFilesThrowsException'] == false &amp;&amp; (props['inExactFileCountExpected'] == -1 || props['localDACount'] == props['inExactFileCountExpected']) &amp;&amp; props['localDACount'] > 1" route="MultipleFilesProceed"/>
                <cc:choose-route expression="true" route="SingleFileProceed"/>
            </cc:mvel-strategy>
            <cc:sub-route name="NoFileError" routes-to="Call_HandleError_NoFileError_Error_110"/>
            <cc:sub-route name="NoFileProceed" routes-to="Call_CreateLogEntry_NoFileProceed_Info_110"/>
            <cc:sub-route name="MultipleFilesError" routes-to="Call_HandleError_MultipleFilesError_Error_110"/>
            <cc:sub-route name="MultipleFilesCountError" routes-to="Call_HandleError_MultipleFilesCountError_Error_110"/>
            <cc:sub-route name="MultipleFilesProceed" routes-to="Call_CreateLogEntry_MultipleFilesProceed_Info_110"/>
            <cc:sub-route name="SingleFileProceed" routes-to="Call_CreateLogEntry_SingleFileProceed_Info_110"/>
        </cc:route>
        <cc:async-mediation id="DocumentAccessor_110" routes-to="RouteOnCount_110" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localDACount'] = (props['inRetrievalDocTag'] == empty) ? da.size() : da.size(props['inRetrievalDocTag']);</cc:expression>
                    <cc:expression>props['localExtraSupportData'] = (props['inRetrievalDocTag'] != empty) ? 'Document Tag filter = ['# props['inRetrievalDocTag'] #']' : '';</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>props['globalDebugPropertyList'].add('localDACount');&#xd;
props['globalDebugPropertyList'].add('localExtraSupportData');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DocumentAccessor_Error_110"/>
        </cc:async-mediation>
        <cc:local-out id="GetEventDocuments_110" routes-response-to="DocumentAccessor_110" endpoint="vm://wcc/GetEventDocuments">
            <cc:set name="ie.event.wid" value="props['inEventWID']"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_110" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'GetEventDocuments Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while calling Get_Event_Documents.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_110" routes-to="GetEventDocuments_110" handle-downstream-errors="true" routes-response-to="Call_Finally_110">
            <cc:request-steps/>
            <cc:response-steps>
            </cc:response-steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_110"/>
        </cc:sync-mediation>
        <cc:aggregator id="AggregateRows_110" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-mimetype="text/xml" output-variable="globalDAMetadata">
        <cc:header-text>&lt;Metadata></cc:header-text>
        <cc:footer-text>&lt;/Metadata></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-in id="AggregateMetadata_110" routes-to="AggregateRows_110"><cc:parameter default="true" name="inCollate" required="true" type="boolean"/><cc:parameter default="false" name="inBatch" required="true" type="boolean"/></cc:local-in>
        <cc:async-mediation id="Teardown_110">
            <cc:steps>
                <cc:eval id="CleanUp">
						<cc:expression>foreach (propname : ['localDACount','localExtraSupportData']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
					</cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_110" routes-to="Teardown_110"/>
        <cc:local-out id="Call_Finally_110" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_110">
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:local-in id="GetDocumentList" routes-to="InitializeAndFinalize_110" access="public" icon="icons/GetDocumentList.png">
            <cc:parameter default="lp.isSet() ? lp.getIntegrationEventWID() : null" documentation="WID of the Integration Event from which the documents will be queried.  This is typically the current event, and as such, is defaulted to the current event WID.  However, changing this WID enables retrieving documents from another related event for processing." name="inEventWID" required="true" type="string"/>
            <cc:parameter default="true" documentation="Controls whether or not an exception is thrown when there are no input files to the Integration Event.  TRUE means an exception will be thrown.  FALSE means no exception will be thrown." name="inNoFileThrowsException" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not an exception is thrown when there are multiple input files to the Integration Event.  TRUE means an exception will be thrown.  FALSE means no exception will be thrown." name="inMultipleFilesThrowsException" required="true" type="boolean"/>
            <cc:parameter default="-1" documentation="Specifies an exact number of files to be expected on the Integration Event.  If a variable number of input files is supported, then this should be passed as -1." name="inExactFileCountExpected" required="false" type="integer" validation="props['inExactFileCountExpected'] == -1 || props['inExactFileCountExpected'] > 0"/>
            <cc:parameter default="props['globalRetrievalDocTag']" documentation="Specifies a Document Tag for filtering the input files on the Integration Event.  If not specified, parameter will try to use the value of the Retrieval Document Tag Integration Attribute." name="inRetrievalDocTag" required="false" type="string"/>
            <cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
        </cc:local-in>
        <cc:local-in id="Main" routes-to="InitializeAttributesAndLaunchParameters"/>
        <cc:local-out id="Call_HandleError_SoapError_Error_103" store-message="none" routes-response-to="RouteError_Soap_Handler_103" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application SOAP request error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing a soap request for the '# props['inWebServiceApplication'] #' application.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="'10307'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
        </cc:local-out>
        <cc:async-mediation id="RouteError_Soap_Handler_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'soap';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_StoreLog_Initialize" store-message="none" routes-response-to="Call_Debug_Initialize_Finalize" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/StoreLog">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-in id="Debug" routes-to="Initialize_109" access="public" icon="icons/Debug.png">
        	<cc:parameter default="'message'" documentation="The type of information to be output to the log." name="inTargetType" required="true" type="string" validation="props['globalDebugTargetTypeParameterValidation'].contains(props['inTargetType'])"/>
        	<cc:parameter documentation="The reference name to use for single-named output types selected on inTargetType.  Required when inTargetType is one of: property, variable, list, map, or set." name="inTargetName" required="false" type="string" validation="props['globalDebugTargetNameParameterValidation'].contains(props['inTargetType']) &amp;&amp;&#xd;&#xa;(props['inTargetName'] != empty || props['inEntityName'] != empty)"/>
        	<cc:parameter documentation="A specific filename to use when exporting the message or variable content to a file zipped in a consolidated archive.  This is optional and only used when inTargetType is &quot;message&quot; or &quot;variable&quot;." name="inEntityName" required="false" type="string"/>
        	<cc:out-parameter name="outEntityName"/>
        </cc:local-in>
        <cc:route id="RouteType_109">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inTargetType'] == 'message'" route="Message"/>
                <cc:choose-route expression="props['inTargetType'] == 'property'" route="Property"/>
                <cc:choose-route expression="props['inTargetType'] == 'properties'" route="Properties"/>
                <cc:choose-route expression="props['inTargetType'] == 'variable'" route="Variable"/>
                <cc:choose-route expression="props['inTargetType'] == 'map'" route="Map"/>
                <cc:choose-route expression="props['inTargetType'] == 'list'" route="List"/>
                <cc:choose-route expression="props['inTargetType'] == 'set'" route="Set"/>
                <cc:choose-route expression="props['inTargetType'] == 'finalize'" route="Finalize"/>
                <cc:choose-route expression="true" route="Undefined"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Message" routes-to="Call_Aggregate_Message_109"/>
            <cc:sub-route name="Property" routes-to="Call_CreateLogEntry_Debug_Property_109"/>
            <cc:sub-route name="Properties" routes-to="Properties_InitializeAndFinalize_109"/>
            <cc:sub-route name="Variable" routes-to="Variable_InitializeAndFinalize_109"/>
            <cc:sub-route name="Map" routes-to="Map_InitializeAndFinalize_109"/>
            <cc:sub-route name="List" routes-to="List_InitializeAndFinalize_109"/>
            <cc:sub-route name="Set" routes-to="Set_InitializeAndFinalize_109"/>
            <cc:sub-route name="Finalize" routes-to="Call_Aggregate_Finalize_109"/>
            <cc:sub-route name="Undefined" routes-to="Call_CreateLogEntry_Warn_Undefined_109"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntry_Warn_Undefined_109" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Undefined Debug Log'"/>
            <cc:set name="inLogMessageDetail" value="'RouteType_109 was not able to correctly process the inTargetType input parameter.'"/>
            
            <cc:set name="inLogLevel" value="'warn'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Variable_109" store-message="none" routes-response-to="Variable_Name_109" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Variable ' # props['inTargetName']"/>
            <cc:set name="inLogMessageDetail" value="'Variable '# props['inTargetName'] #' saved to debug file with name of ' # props['outEntityName']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Property_109" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Property ' # props['inTargetName']"/>
            <cc:set name="inLogMessageDetail" value="propname = props['inTargetName'];&#xd;&#xa;String.valueOf(props[propname]);"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Message_109" store-message="none" routes-response-to="Message_Name_109" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message RootPart'"/>
            <cc:set name="inLogMessageDetail" value="'Message root part saved to debug file with name of ' # props['outEntityName']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Properties_109" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="parts[0].xpath('/p/k')"/>
            <cc:set name="inLogMessageDetail" value="parts[0].xpath('/p/v')"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:splitter id="Properties_Splitter_109" no-split-message-error="false">
            <cc:sub-route name="Iterate" routes-to="Call_CreateLogEntry_Debug_Properties_109"/>
            <cc:xml-stream-splitter xpath="/root/p"/>
        </cc:splitter>
        <cc:local-out id="Call_CreateLogEntry_Debug_Map_109" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="parts[0].xpath('/p/k')"/>
            <cc:set name="inLogMessageDetail" value="parts[0].xpath('/p/v')"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:splitter id="Map_Splitter_109" no-split-message-error="false">
            <cc:sub-route name="Iterate" routes-to="Call_CreateLogEntry_Debug_Map_109"/>
            <cc:xml-stream-splitter xpath="/root/p"/>
        </cc:splitter>
        <cc:local-out id="Call_CreateLogEntry_Debug_List_109" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="props.inTargetName # ' Element'"/>
            <cc:set name="inLogMessageDetail" value="parts[0].xpath('/root/e')"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:splitter id="List_Splitter_109" no-split-message-error="false">
            <cc:sub-route name="Iterate" routes-to="Call_CreateLogEntry_Debug_List_109"/>
            <cc:xml-stream-splitter xpath="/root"/>
        </cc:splitter>
        <cc:local-out id="Call_CreateLogEntry_Debug_Set_109" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="props.inTargetName # ' Element'"/>
            <cc:set name="inLogMessageDetail" value="parts[0].xpath('/root/e')"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:splitter id="Set_Splitter_109" no-split-message-error="false">
            <cc:sub-route name="Iterate" routes-to="Call_CreateLogEntry_Debug_Set_109"/>
            <cc:xml-stream-splitter xpath="/root"/>
        </cc:splitter>
        <cc:local-out id="Call_Debug_SoapRequest_103" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallSoap_Catch_103" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            
            
            
            
            
            
            
        <cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication']"/></cc:local-out>
        <cc:local-out id="Call_Debug_RaaSRequest_102" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallRaaS_Catch_102" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="'property'"/>
        <cc:set name="inTargetName" value="'localRestUrl'"/></cc:local-out>
        <cc:local-out id="Call_Debug_SoapXslt_103" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="'variable'"/>
        <cc:set name="inTargetName" value="'localXsltSoapGenerator'"/><cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/></cc:local-out>
        <cc:route id="RouteError_103">
            <cc:mvel-strategy>
                <cc:choose-route expression="parts[0].isXml() &amp;&amp; (Integer.valueOf(parts[0].xpath('count(/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault)')) > 0)" route="SoapError"/>
                <cc:choose-route expression="true" route="HttpError"/>
            </cc:mvel-strategy>
            <cc:sub-route name="SoapError" routes-to="Call_HandleError_SoapError_Error_103"/>
            <cc:sub-route name="HttpError" routes-to="Call_HandleError_HttpError_Error_103"/>
        </cc:route>
        <cc:async-mediation id="ProcessResult_Handler_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_ProcessResult_Warn_104" store-message="none" routes-response-to="ProcessResult_Handler_104" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while extracing the results from the SOAP response using xpath['# props['inXpathToResultsToAggregate'] #'].  Processing of the remaining results will continue...'"/>
            
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="false"/>
       	<cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="ProcessResult_104" routes-to="RouteDestination_104" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ProcessResult_Warn_104"/>
        </cc:async-mediation>
        <cc:async-mediation id="HttpError_Handler_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'http';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_HttpError_Error_104" store-message="none" routes-response-to="HttpError_Handler_104" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application HTTP request error'"/>
            <cc:set name="inLogMessageDetail" value="'A transport protocol error occurred and the request was not evaluated or processed by the tenant.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_104'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            
	    </cc:local-out>
        <cc:async-mediation id="SoapError_Handler_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'soap';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_SoapError_Error_104" store-message="none" routes-response-to="SoapError_Handler_104" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application SOAP request error'"/>
            <cc:set name="inLogMessageDetail" value="'The API call resulted in the following SOAP fault: '# String.valueOf(parts[0].xpath('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault/faultstring'))"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="'10407'"/>
	        <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_104'"/>
	        <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
	        <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
	        <cc:set name="inTargetType" value="'property'"/>
	        <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
	        <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
	        
	    </cc:local-out>
        <cc:route id="RouteError_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="parts[0].isXml() &amp;&amp; (parts[0].xpath('count(/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault)') > 0)" route="SoapError"/>
                <cc:choose-route expression="true" route="HttpError"/>
            </cc:mvel-strategy>
            <cc:sub-route name="SoapError" routes-to="Call_HandleError_SoapError_Error_104"/>
            <cc:sub-route name="HttpError" routes-to="Call_HandleError_HttpError_Error_104"/>
        </cc:route>
        <cc:async-mediation id="CallSoap_Catch_104" routes-to="CallSoap_104" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="RouteError_104"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_SoapRequest_104" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallSoap_Catch_104" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="'message'"/>
        <cc:set name="inEntityName" value="'SOAP-Request'"/></cc:local-out>
        <cc:local-out id="Call_Debug_SoapXslt_104" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localXsltSoapGenerator'"/>
        <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/></cc:local-out>
        <cc:async-mediation id="Transform_Handler_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Transform_Error_104" store-message="none" routes-response-to="Transform_Handler_104" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Transformation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a SOAP service call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_104'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            
        </cc:local-out>
        <cc:async-mediation id="Transform_104" routes-to="Call_Debug_SoapXslt_104">
            <cc:steps>
                <cc:xslt-plus id="WriteSoap" url="@{props['inPathToXsltFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Transform_Error_104"/>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareVariableInput_104" routes-to="Transform_104" execute-steps-when="props['localIsNonEmptyMapVariable']">
            <cc:steps>
                <cc:eval id="PrimeMessage">
                    <cc:expression>varname = props['inMapVariableName'];&#xd;
parts[0] = vars[varname];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareMapInput_104" routes-to="PrepareVariableInput_104" execute-steps-when="(!props['localIsValuedProperty'] &amp;&amp; !props['localIsValuedVariable']) || props['localIsNonEmptyMapProperty']">
            <cc:steps>
                <cc:write id="PrimeMessage">
                    <cc:message>
                        <cc:text>&lt;?xml version="1.0" encoding="UTF-8"?>&#xd;
&lt;Root/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Validation_Handler_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Validation_Error_104" store-message="none" routes-response-to="Validation_Handler_104" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Validation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating parameters for a SOAP service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_104'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_104" routes-to="Call_BuildRequest_104" routes-response-to="Call_Finally_104">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outIsSoapError'] = '';</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_104">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsValuedProperty','localIsDefinedProperty','localIsCorrectTypeProperty','localIsNonEmptyMapProperty','localIsValuedVariable','localIsDefinedVariable','localIsCorrectTypeVariable','localIsNonEmptyMapVariable']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_104" routes-to="Teardown_104"/>
        <cc:local-out id="Call_Finally_104" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_104"/>
        <cc:local-in id="CallSoapPaged" routes-to="InitializeAndFinalize_104" access="public" icon="icons/CallSoapPaged.png">
            <cc:parameter default="props['globalApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;." name="inWebServiceApplication" required="true" type="string"/>
            <cc:parameter default="true" documentation="Sub-assembly supports pre-built, on-message requests as well as facilities to construct the request dynamically.  Set this parameter to true to bypass the dynamic request construction and use the message root part as the request.  If set to false, then the inPathToXsltFile and the inMapPropertyName or inMapVariableName parameters should be set." name="inUseMessageRootPartAsRequest" required="true" type="boolean"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;." name="inPathToXsltFile" required="!props['inUseMessageRootPartAsRequest']" type="string"/>
            <cc:parameter documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inMapPropertyName" required="false" type="string"/>
            <cc:parameter documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example." name="inMapVariableName" required="false" type="string"/>
            <cc:parameter documentation="Xpath to the elements in the response that are to be aggregated into the globalSoapResults variable." name="inXpathToResultsToAggregate" required="true" type="string"/>
            <cc:parameter default="'&lt;SoapResults xmlns:wd=&quot;urn:com.workday/bsvc&quot;>'" documentation="In order to aggregate multiple XML elements at the same level into a final, returned document, a new root node is required.  This parameter defines that node including the namespaces required in the results, e.g. &lt;SoapResults xmlns:wd=&quot;urn:com.workday/bsvc&quot;>" name="inAggregatedResultsHeader" required="true" type="string" validation="props['inAggregatedResultsHeader'] != empty"/>
            <cc:parameter default="'&lt;/SoapResults>'" documentation="In order to aggregate multiple XML elements at the same level into a final, returned document, a new root node is required.  This parameter defines the matching, terminating element as was defined on the inAggregatedResults parameter." name="inAggregatedResultsFooter" required="true" type="string" validation="props['inAggregatedResultsFooter'] != empty"/>
            <cc:parameter default="'variable'" documentation="How the SOAP results are returned to the caller, either on the message if the value is 'message', or in the 'globalSoapResults' variable if the value is 'variable', which is the default." name="inReturnResults" required="true" type="string" validation="props['inReturnResults'] == 'variable' || props['inReturnResults'] == 'message'"/>
            <cc:parameter default="props['globalIsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['globalIsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:out-parameter documentation="A string to indicate that the request resulted in an error and identify the type.  If the error was at the API level, then outIsSoapError == 'http'.  If the error was at the tenant/application level, then outIsSoapError == 'soap'.  If there was an error unrelated to the API call, then outIsSoapError == 'logic'.  If there is no error, , then outIsSoapError == empty.  Further individual errors determined by Get_Event_Details or Get_Import_Processes are not handled here." name="outIsSoapError"/>
        </cc:local-in>
        <cc:local-out id="CallSoap_104" endpoint="vm://wcc/PagedGet"><cc:set name="is.paged.get.request.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Filter/wd:Page'"/><cc:set name="is.paged.get.response.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Page'"/><cc:set name="is.paged.get.response.total.pages.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Pages'"/><cc:set name="is.paged.get.response.total.results.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Results'"/><cc:set name="is.paged.get.process.endpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/ProcessPage_104'"/><cc:set name="is.paged.get.application" value="props['inWebServiceApplication']"/><cc:set name="is.paged.get.version" value="props['inApiVersion']"/><cc:set name="is.paged.get.page.zero" value="false"/><cc:set name="is.paged.get.store.requests" value="true"/></cc:local-out>
        <cc:aggregator id="AggregateVariable_104" force-batch-on-last-message="false" force-batch-when="props['is.paged.get.last.page']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-mimetype="text/xml" output-variable="globalSoapResults" xpath="@{props['inXpathToResultsToAggregate']}">
        <cc:header-text>@{props['inAggregatedResultsHeader']}</cc:header-text>
        <cc:footer-text>@{props['inAggregatedResultsFooter']}</cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-in id="ProcessPage_104" routes-to="ProcessResult_104">
        	<cc:parameter default="props['inAggregatedResultsHeader']" name="inAggregatedResultsHeader" required="true" type="string" validation="props['inAggregatedResultsHeader'] != empty"/>
        	<cc:parameter default="props['inAggregatedResultsFooter']" name="inAggregatedResultsFooter" required="true" type="string" validation="props['inAggregatedResultsFooter'] != empty"/>
        	<cc:parameter default="props['inXpathToResultsToAggregate']" documentation="Xpath to the elements in the response that are to be aggregated into the globalSoapResults variable." name="inXpathToResultsToAggregate" required="true" type="string"/>
            <cc:parameter default="props['inReturnResults']" documentation="How the SOAP results are returned to the caller, either on the message if the value is 'message', or in the 'globalSoapResults' variable if the value is 'variable', which is the default." name="inReturnResults" required="true" type="string" validation="props['inReturnResults'] == 'variable' || props['inReturnResults'] == 'message'"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_LoadMap_Error_105" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">            
            <cc:set name="inLogMessage" value="'XSLT3 Map Load Error'"/>
            <cc:set name="inLogMessageDetail" value="'The XML data failed to be converted into a Java Map'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_105'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localPjmXslt'"/>
            <cc:set name="inEntityName" value="'PopulateJavaMap-Transform'"/>
        </cc:local-out>
        <cc:async-mediation id="Teardown_105">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>// Remove properties that are purely internal to the subassembly
foreach (propname : ['localMapPropertyName']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    <cc:expression>// And remove local variables that are no longer required&#xd;
foreach (varname : ['localPjmXslt', 'localPjmXsltBlob']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_105" routes-to="Teardown_105"/>
        <cc:local-out id="Call_Finally_105" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_105"/>
        <cc:local-in id="IntegrationEventProgress" routes-to="PIM_108" access="public" icon="icons/IntegrationEventProgress0.png">
            <cc:parameter documentation="The overall completion percentage of the studio execution." name="inProgressPercentage" required="true" type="string"/>
            <cc:parameter documentation="The optional message to output on the Integration Event to indicate at what stage of the processing the Studio is." name="inProgressMessage" required="false" type="string"/>
        </cc:local-in>
        <cc:local-out id="PIM_108" execute-when="props['inProgressMessage'] != empty" routes-response-to="PIE_108" endpoint="vm://wcc/PutIntegrationMessage"><cc:set name="is.message.severity" value="'INFO'"/><cc:set name="is.message.summary" value="props['inProgressMessage']"/><cc:set name="is.message.storage.enabled" value="false"/></cc:local-out>
        <cc:local-out id="PIE_108" routes-response-to="Call_CreateLogEntry_Info_108" endpoint="vm://wcc/PutIntegrationEvent"><cc:set name="is.percent.complete" value="props['inProgressPercentage']"/></cc:local-out>
        <cc:local-out id="Call_IEP_10" store-message="none" routes-response-to="MainFlowControl" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/IntegrationEventProgress" clone-request="true" propagate-abort="false"><cc:set name="inProgressPercentage" value="'10'"/><cc:set name="inProgressMessage" value="'Initialization Complete.  Cloud Log, integration attributes, and launch parameters have been loaded.'"/></cc:local-out>
        <cc:local-out id="Call_IEP_90" store-message="none" routes-response-to="Call_StoreLog" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/IntegrationEventProgress" clone-request="true" propagate-abort="false">
            <cc:set name="inProgressPercentage" value="'90'"/>
            <cc:set name="inProgressMessage" value="'Integration functional behavior complete.  Finalizing logs...'"/>
        </cc:local-out>
        <cc:local-out id="Call_IEP_99" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/IntegrationEventProgress" clone-request="true" propagate-abort="false">
            <cc:set name="inProgressPercentage" value="'99'"/>
            <cc:set name="inProgressMessage" value="'Logs Finalized.  Awaiting any background process to complete Integration Event...'"/>
        </cc:local-out>
        <cc:aggregator id="AggregateToArchive_109" routes-to="StoreArchive_109" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:zip-file-collater output-mimetype="application/zip" message-entity-name="@{props['outEntityName']}"/>
        </cc:aggregator>
        <cc:local-in id="Aggregate_109" routes-to="DedupeName_109">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/><cc:parameter default="(props['inEntityName'] != empty) ? props['inEntityName'] : props['inTargetName']" name="inEntityName" required="props['inCollate']" type="string"/>
        <cc:out-parameter name="outEntityName"/></cc:local-in>
        <cc:async-mediation id="DedupeName_109" routes-to="AggregateToArchive_109">
            <cc:steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10900" failure-message="DebugFile Aggregator (Aggregator_109) parameter failure.  The inCollate and inBatch arguments cannot both be false.">(!props['inCollate'] &amp;&amp; props['inBatch']) ||&#xd;
	(props['inCollate'] &amp;&amp; !props['inBatch']) ||&#xd;
	(props['inCollate'] &amp;&amp; props['inBatch'])</cc:expression>
                </cc:validate-exp>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outEntityName'] = (props['inEntityName'] != empty) ? props['globalStringDeduplicator'].dedupeString(props['inEntityName']) : '';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_Finalize_109" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Aggregate_109"><cc:set name="inCollate" value="false"/><cc:set name="inBatch" value="true"/></cc:local-out>
        <cc:local-out id="Call_Aggregate_Message_109" store-message="none" routes-response-to="Call_CreateLogEntry_Debug_Message_109" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Aggregate_109">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        <cc:set name="inEntityName" value="(props['inEntityName'] != empty) ? props['inEntityName'] : props['inTargetName']"/></cc:local-out>
        <cc:async-mediation id="Message_Name_109">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outEntityName'] = props['outEntityName'];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Variable_PrepareValue_109" routes-to="Call_Aggregate_Variable_109">
            <cc:steps>
                <cc:eval id="CopyVarToMsg">
                    <cc:expression>parts[0] = vars[props.inTargetName];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_Variable_109" store-message="none" routes-response-to="Call_CreateLogEntry_Debug_Variable_109" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Aggregate_109">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
            <cc:set name="inEntityName" value="(props['inEntityName'] != empty) ? props['inEntityName'] : props['inTargetName']"/>
        </cc:local-out>
        <cc:async-mediation id="Variable_Name_109">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outEntityName'] = props['outEntityName'];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Validation_103" routes-to="PrepareMapInput_103">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsValuedProperty'] = props['inMapPropertyName'] != empty;&#xd;
propname = props['inMapPropertyName'];&#xd;
props['localIsDefinedProperty'] = props['localIsValuedProperty'] &amp;&amp; context.containsProperty(propname);&#xd;
props['localIsCorrectTypeProperty'] = props['localIsDefinedProperty'] &amp;&amp; (context.getProperty(propname) instanceof java.util.Map);&#xd;
props['localIsNonEmptyMapProperty'] = props['localIsCorrectTypeProperty'] &amp;&amp; !(((java.util.Map)(context.getProperty(propname))).isEmpty());</cc:expression>
                    <cc:expression>props['localIsValuedVariable'] = props['inMapVariableName'] != empty;&#xd;
varname = props['inMapVariableName'];&#xd;
props['localIsDefinedVariable'] = props['localIsValuedVariable'] &amp;&amp; vars.isVariable(varname);&#xd;
props['localIsCorrectTypeVariable'] = props['localIsDefinedVariable'] &amp;&amp; (vars[varname].isXml());&#xd;
props['localIsNonEmptyMapVariable'] = props['localIsCorrectTypeVariable'] &amp;&amp; (vars[varname] != null);</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10300" failure-message="Only one (or neither) of the inMapPropertyName and inMapVariableName input parameters should be set.  However, both were provided.">!(props['localIsValuedProperty'] &amp;&amp; props['localIsValuedVariable'])</cc:expression>
                    <cc:expression error-number="10301" failure-message="The inMapPropertyName input parameter was set.  However, a context property with the referenced name [@{props['inMapPropertyName']}] could not be found.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsDefinedProperty'])</cc:expression>
                    <cc:expression error-number="10302" failure-message="The inMapPropertyName input parameter was set.  However, the referenced context property [@{props['inMapPropertyName']}] was not an instance of java.util.Map.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsCorrectTypeProperty'])</cc:expression>
                    <cc:expression error-number="10303" failure-message="The inMapPropertyName input parameter was set.  However, the referenced context property [@{props['inMapPropertyName']}] contained no data.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsNonEmptyMapProperty'])</cc:expression>
                    <cc:expression error-number="10304" failure-message="The inMapVariableName input parameter was set.  However, a context variable with the referenced name [@{props['inMapVariableName']}] could not be found.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsDefinedVariable'])</cc:expression>
                    <cc:expression error-number="10305" failure-message="The inMapVariableName input parameter was set.  However, the referenced context variable [@{props['inMapVariableName']}] was not XML.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsCorrectTypeVariable'])</cc:expression>
                    <cc:expression error-number="10306" failure-message="The inMapVariableName input parameter was set.  However, the referenced context variable [@{props['inMapVariableName']}] was null.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsNonEmptyMapVariable'])</cc:expression>
                </cc:validate-exp></cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Validation_Error_103"/>
        </cc:async-mediation>
        <cc:async-mediation id="SetHeaders_103" routes-to="Call_Debug_SoapRequest_103">
            <cc:steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] == true ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers></cc:steps>
        </cc:async-mediation>
        <cc:local-in id="BuildRequest_103" routes-to="Validation_103"><cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/><cc:parameter default="props['inPathToXsltFile']" documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;." name="inPathToXsltFile" required="true" type="string"/><cc:parameter documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inMapPropertyName" required="false" type="string"/><cc:parameter documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example." name="inMapVariableName" required="false" type="string"/><cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/><cc:parameter default="props['inIsAbortOnError']" name="inIsAbortOnError" required="true" type="boolean"/></cc:local-in>
        <cc:local-out id="Call_BuildRequest_103" store-message="none" execute-when="!props['inUseMessageRootPartAsRequest']" routes-response-to="SetHeaders_103" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/BuildRequest_103" propagate-abort="true"><cc:set name="inApiVersion" value="props['inApiVersion']"/><cc:set name="inPathToXsltFile" value="props['inPathToXsltFile']"/><cc:set name="inMapPropertyName" value="props['inMapPropertyName']"/><cc:set name="inMapVariableName" value="props['inMapVariableName']"/><cc:set name="inDebugMode" value="props['inDebugMode']"/><cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/></cc:local-out>
        <cc:async-mediation id="StoreArchive_109" execute-steps-when="props['inBatch']">
            <cc:steps>
                <cc:store id="StoreArchive" output="variable" output-variable="localDebugArchive" createDocumentReference="true" expiresIn="@{props['globalDocumentRetentionPeriod']}" title="@{props['globalDebugArchiveFilename']}"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="BuildRequest_104" routes-to="Validation_104">
            <cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['inPathToXsltFile']" documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;." name="inPathToXsltFile" required="true" type="string"/>
            <cc:parameter documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inMapPropertyName" required="false" type="string"/>
            <cc:parameter documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example." name="inMapVariableName" required="false" type="string"/>
            <cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/><cc:parameter default="props['inIsAbortOnError']" name="inIsAbortOnError" required="true" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="Validation_104" routes-to="PrepareMapInput_104">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsValuedProperty'] = props['inMapPropertyName'] != empty;&#xd;
propname = props['inMapPropertyName'];&#xd;
props['localIsDefinedProperty'] = props['localIsValuedProperty'] &amp;&amp; context.containsProperty(propname);&#xd;
props['localIsCorrectTypeProperty'] = props['localIsDefinedProperty'] &amp;&amp; (context.getProperty(propname) instanceof java.util.Map);&#xd;
props['localIsNonEmptyMapProperty'] = props['localIsCorrectTypeProperty'] &amp;&amp; !(((java.util.Map)(context.getProperty(propname))).isEmpty());</cc:expression>
                    <cc:expression>props['localIsValuedVariable'] = props['inMapVariableName'] != empty;&#xd;
varname = props['inMapVariableName'];&#xd;
props['localIsDefinedVariable'] = props['localIsValuedVariable'] &amp;&amp; vars.isVariable(varname);&#xd;
props['localIsCorrectTypeVariable'] = props['localIsDefinedVariable'] &amp;&amp; (vars[varname].isXml());&#xd;
props['localIsNonEmptyMapVariable'] = props['localIsCorrectTypeVariable'] &amp;&amp; (vars[varname] != null);</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10400" failure-message="Only one (or neither) of the inMapPropertyName and inMapVariableName input parameters should be set.  However, both were provided.">!(props['localIsValuedProperty'] &amp;&amp; props['localIsValuedVariable'])</cc:expression>
                    <cc:expression error-number="10401" failure-message="The inMapPropertyName input parameter was set.  However, a context property with the referenced name [@{props['inMapPropertyName']}] could not be found.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsDefinedProperty'])</cc:expression>
                    <cc:expression error-number="10402" failure-message="The inMapPropertyName input parameter was set.  However, the referenced context property [@{props['inMapPropertyName']}] was not an instance of java.util.Map.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsCorrectTypeProperty'])</cc:expression>
                    <cc:expression error-number="10403" failure-message="The inMapPropertyName input parameter was set.  However, the referenced context property [@{props['inMapPropertyName']}] contained no data.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsNonEmptyMapProperty'])</cc:expression>
                    <cc:expression error-number="10404" failure-message="The inMapVariableName input parameter was set.  However, a context variable with the referenced name [@{props['inMapVariableName']}] could not be found.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsDefinedVariable'])</cc:expression>
                    <cc:expression error-number="10405" failure-message="The inMapVariableName input parameter was set.  However, the referenced context variable [@{props['inMapVariableName']}] was not XML.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsCorrectTypeVariable'])</cc:expression>
                    <cc:expression error-number="10406" failure-message="The inMapVariableName input parameter was set.  However, the referenced context variable [@{props['inMapVariableName']}] was null.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsNonEmptyMapVariable'])</cc:expression>
                </cc:validate-exp></cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Validation_Error_104"/>
        </cc:async-mediation>
        <cc:async-mediation id="SetHeaders_104" routes-to="Call_Debug_SoapRequest_104">
            <cc:steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] == true ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers></cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_BuildRequest_104" store-message="none" execute-when="!props['inUseMessageRootPartAsRequest']" routes-response-to="SetHeaders_104" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/BuildRequest_104" propagate-abort="true">
            <cc:set name="inApiVersion" value="props['inApiVersion']"/>
            <cc:set name="inPathToXsltFile" value="props['inPathToXsltFile']"/>
            <cc:set name="inMapPropertyName" value="props['inMapPropertyName']"/>
            <cc:set name="inMapVariableName" value="props['inMapVariableName']"/>
            <cc:set name="inDebugMode" value="props['inDebugMode']"/><cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Finalize" store-message="none" routes-response-to="Call_IEP_99" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="'finalize'"/>
            
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_DocumentAccessor_Error_110" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'GetEventDocuments Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while parsing the Get_Event_Documents response.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Info_108" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Integration '# String.valueOf(props['inProgressPercentage']) #'% Complete'"/>
            <cc:set name="inLogMessageDetail" value="props['inProgressMessage']"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Finalize_GEH" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="'finalize'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_SoapResponse_103" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Results_103" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inWebServiceApplication']"/>
        </cc:local-out>
        <cc:sync-mediation id="Properties_InitializeAndFinalize_109" routes-to="Properties_PrepareValue_109" execute-steps-when="!message.isNullContentRootPart()">
            <cc:request-steps>
                <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage"/>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                </cc:eval>
                <cc:copy id="RestoreMsg" output="message" input="variable" input-variable="debugTemporaryStorage"/>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:sync-mediation id="Map_InitializeAndFinalize_109" routes-to="Map_PrepareValue_109" execute-steps-when="!message.isNullContentRootPart()">
            <cc:request-steps>
                <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage"/>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                </cc:eval>
                <cc:copy id="RestoreMsg" output="message" input="variable" input-variable="debugTemporaryStorage"/>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:sync-mediation id="List_InitializeAndFinalize_109" routes-to="List_PrepareValue_109" execute-steps-when="!message.isNullContentRootPart()">
            <cc:request-steps>
                <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage"/>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                </cc:eval>
                <cc:copy id="RestoreMsg" output="message" input="variable" input-variable="debugTemporaryStorage"/>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:sync-mediation id="Set_InitializeAndFinalize_109" routes-to="Set_PrepareValue_109" execute-steps-when="!message.isNullContentRootPart()">
            <cc:request-steps>
                <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage"/>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                </cc:eval>
                <cc:copy id="RestoreMsg" output="message" input="variable" input-variable="debugTemporaryStorage"/>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:async-mediation id="Initialize_109" routes-to="RouteType_109">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outEntityName'] = '';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Initialize_Finalize" store-message="none" routes-response-to="Initialize_Handler" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="'finalize'"/>
        </cc:local-out>
        <cc:async-mediation id="Teardown_107">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>// And remove local variables that are no longer required&#xd;
foreach (varname : ['localPreTransformData107', 'localPayload107', 'localXslt107']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_107" routes-to="Teardown_107"/>
        <cc:sync-mediation id="Validation_107" routes-to="SavePayloadData_107" routes-response-to="Call_Finally_107">
            <cc:request-steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10700" failure-message="Input parameters inPayloadDataLocation and inEnrichmentDataLocation were both set to message.  This implies that the message contains both the data payload as well as the mapping data.  Only one can be on the message.">!(props['inPayloadDataLocation'] == 'message' &amp;&amp; props['inEnrichmentDataLocation'] == 'message')</cc:expression>
                    <cc:expression error-number="10701" failure-message="Input parameter inPayloadDataLocation was not &quot;message&quot; and was not located as a variable.  The value must either be &quot;message&quot; or refer to a valid, bound variable.">props['inPayloadDataLocation'] == 'message' || context.variables.isVariable(props.inPayloadDataLocation);</cc:expression>
                    <cc:expression error-number="10702" failure-message="Input parameter inEnrichmentDataLocation was not &quot;message&quot; and was not located as a variable.  The value must either be &quot;message&quot; or refer to a valid, bound variable.">props['inEnrichmentDataLocation'] == 'message' || context.variables.isVariable(props.inEnrichmentDataLocation);</cc:expression>
                </cc:validate-exp>
            </cc:request-steps>
            <cc:response-steps>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_107" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_107"/>
        <cc:local-in id="StreamDataMerge" routes-to="Validation_107" access="public" icon="icons/StreamDataMerge.png">
            <cc:parameter default="'message'" documentation="Where the main data being enriched and transformed can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inPayloadDataLocation" required="true" type="string"/>
            <cc:parameter default="'globalRaaSResults'" documentation="Where the enrichment data (that would be used to build a map) can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found.  The default value assumes that sub-assembly 102 may have been used and the results are in &quot;globalRaaSResults&quot;, although this need not be the case." name="inEnrichmentDataLocation" required="true" type="string"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will transform the data from inPayloadDataLocation, enriching and decorating it with data from inEnrichmentDataLocation, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;.  Though this is intended to be a streaming implementation, the responsibility for streaming lies with the developer of the XSLT; this sub-assembly is not streaming unless the XSLT correctly implements it." name="inPathToXsltFile" required="true" type="string"/>
            <cc:parameter default="'globalData'" documentation="Where the results of the transformation are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the sub-assembly ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found.  " name="inReturnOutputLocation" required="true" type="string"/>
            <cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
        </cc:local-in>
        <cc:local-in id="Aggregate_107" routes-to="AggregateData_107"><cc:parameter default="true" name="inCollate" required="true" type="boolean"/><cc:parameter default="false" name="inBatch" required="true" type="boolean"/></cc:local-in>
        <cc:aggregator id="AggregateData_107" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-mimetype="text/xml" output-variable="localPreTransformData107">
        <cc:header-text>&lt;Results></cc:header-text>
        <cc:footer-text>&lt;/Results></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:async-mediation id="SavePayloadData_107" routes-to="PrepareEnrichmentData_107" execute-steps-when="props['inPayloadDataLocation'] == 'message'" handle-downstream-errors="true">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="localPayload107"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_SavePayloadData_Error_107"/>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareEnrichmentData_107" routes-to="Call_Aggregate_EnrichmentData_107" execute-steps-when="props['inEnrichmentDataLocation'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>parts[0] = vars.getVariable(props.inEnrichmentDataLocation);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_EnrichmentData_107" store-message="none" routes-response-to="RestorePayloadData_107" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Aggregate_107"><cc:set name="inCollate" value="true"/><cc:set name="inBatch" value="false"/></cc:local-out>
        <cc:async-mediation id="PreparePayloadData_107" routes-to="Call_Aggregate_PayloadData_107" execute-steps-when="props['inPayloadDataLocation'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>parts[0] = vars.getVariable(props.inPayloadDataLocation);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_PayloadData_107" store-message="none" routes-response-to="Transform_107" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Aggregate_107">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:async-mediation id="Transform_107" routes-to="FinalizeResults">
            <cc:steps>
                <cc:write id="WriteXSLT" output="variable" output-variable="localXslt107">
                    <cc:message>
                        <cc:static-file input-file="@{props['inPathToXsltFile']}"/>
                    </cc:message>
                </cc:write>
                <cc:xslt-plus id="ExecuteTranform" input="variable" input-variable="localPreTransformData107" url="mctx:vars/localXslt107"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Transform_Error_107"/>
        </cc:async-mediation>
        <cc:async-mediation id="FinalizeResults" execute-steps-when="props['inReturnOutputLocation'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars[props.inReturnOutputLocation] = parts[0];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_SavePayloadData_Error_107" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'XSLT Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred managing the payload and enrichment data between the message root and variables.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_107'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_Transform_Error_107" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred executing the payload transformation using enrichment data.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_107'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:sync-mediation id="MainFlowControl" routes-to="Call_Main" routes-response-to="Call_IEP_90">
            <cc:request-steps/>
            <cc:response-steps>
                <cc:eval id="ResetAbort">
                    <cc:expression>context.setAbort(false);</cc:expression>
                </cc:eval></cc:response-steps>
        </cc:sync-mediation>
        <cc:async-mediation id="Properties_PrepareValue_109" routes-to="Properties_Splitter_109">
            <cc:steps>
                <cc:write id="PropsToXML" output-mimetype="text/xml">
                    <cc:message>
                        <cc:text>&lt;root>&#xd;
@foreach{props[props.inTargetName] as propname}&#xd;
	&lt;p>&#xd;
		&lt;k>@{propname}&lt;/k>&#xd;
		&lt;v>@{props[propname]}&lt;/v>&#xd;
	&lt;/p>&#xd;
@end{}&#xd;
&lt;/root></cc:text>
                    </cc:message>
                </cc:write></cc:steps>
        </cc:async-mediation>
        <cc:sync-mediation id="Variable_InitializeAndFinalize_109" routes-to="Variable_PrepareValue_109" execute-steps-when="!message.isNullContentRootPart()">
            <cc:request-steps>
                <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage"/></cc:request-steps>
            <cc:response-steps>
            
                <cc:eval id="CleanUp">
                    <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                </cc:eval>
                <cc:copy id="RestoreMsg" output="message" input="variable" input-variable="debugTemporaryStorage"/>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:async-mediation id="Map_PrepareValue_109" routes-to="Map_Splitter_109">
            <cc:steps>
                <cc:write id="MapToXML" output-mimetype="text/xml">
                    <cc:message>
                        <cc:text>&lt;root>&#xd;
@foreach{props[props.inTargetName].keySet() as key}&#xd;
	&lt;p>&#xd;
		&lt;k>@{key}&lt;/k>&#xd;
		&lt;v>@{props[props.inTargetName].get(key)}&lt;/v>&#xd;
	&lt;/p>&#xd;
@end{}&#xd;
&lt;/root></cc:text>
                    </cc:message>
                </cc:write></cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="List_PrepareValue_109" routes-to="List_Splitter_109">
            <cc:steps>
                <cc:write id="ListToXML" output-mimetype="text/xml">
                    <cc:message>
                        <cc:text>&lt;root>&#xd;
@foreach{props[props.inTargetName] as e}&#xd;
	&lt;e>@{e}&lt;/e>&#xd;
@end{}&#xd;
&lt;/root></cc:text>
                    </cc:message>
                </cc:write></cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Set_PrepareValue_109" routes-to="Set_Splitter_109">
            <cc:steps>
                <cc:write id="SetToXML" output-mimetype="text/xml">
                    <cc:message>
                        <cc:text>&lt;root>&#xd;
@foreach{props[props.inTargetName] as e}&#xd;
	&lt;e>@{e}&lt;/e>&#xd;
@end{}&#xd;
&lt;/root></cc:text>
                    </cc:message>
                </cc:write></cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="RestorePayloadData_107" routes-to="PreparePayloadData_107" execute-steps-when="props['inPayloadDataLocation'] == 'message'">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output="message" output-mimetype="text/xml" input="variable" input-variable="localPayload107"/></cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_NormalizeResponse_Error_102" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'SOAP Unwrap Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while unwrapping the RaaS results from the SOAP envelope.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inReportServiceAlias']"/>
            
        </cc:local-out>
        <cc:async-mediation id="NormalizeResponse_102" execute-steps-when="props['inReturnResults'] == 'variable'">
            <cc:steps>
                <cc:xslt-plus id="UnwrapSoap" output-mimetype="text/xml" url="xslt/sa102/SA102_UnwrapSoapTransform.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_NormalizeResponse_Error_102"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_HttpOut_Error_102" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="HttpOut_Catch_102" routes-to="HttpOut_102" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_HttpOut_Error_102"/>
        </cc:async-mediation>
        <cc:http-out id="HttpOut_102" routes-response-to="NormalizeResponse_102" endpoint="@{intsys.reportService.getEndpoint(props.inReportServiceAlias)}" http-method="POST"/>
        <cc:local-out id="Call_Debug_SoapRequest_102" store-message="none" execute-when="props['inDebugMode']" routes-response-to="HttpOut_Catch_102" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Request__' # props['inReportServiceAlias']"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_ComposeRequest_Error_102" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:local-in id="ExecuteWithRest_102" routes-to="Call_Debug_RaaSRequest_102"><cc:parameter default="props['localRestUrl']" documentation="The full rest query including all querystring parameters" name="inRestUrl" required="true" type="string"/><cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/></cc:local-in>
        <cc:local-in id="ExecuteWithSoap_102" routes-to="Call_CreateLogEntry_ExecuteWithSoap_Info_102"><cc:parameter default="props['inReportServiceAlias']" documentation="The Report Service configuration from which to retrieve results." name="inReportServiceAlias" required="true" type="string"/><cc:parameter default="props['inPropertyNameReportPromptMap']" documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  If the report is not parameterized, then leave this input parameter empty.  If setting this input parameter though, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap." name="inPropertyNameReportPromptMap" required="true" type="string"/><cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/></cc:local-in>
        <cc:route id="ChooseProtocol_102">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['localIsValidUrlLength']" route="REST"/>
                <cc:choose-route expression="true" route="SOAP"/>
            </cc:mvel-strategy>
            <cc:sub-route name="REST" routes-to="Call_ExecuteWithRest_102"/>
            <cc:sub-route name="SOAP" routes-to="Call_ExecuteWithSoap_102"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntry_ExecuteWithSoap_Info_102" store-message="none" routes-response-to="ComposeRequest_102" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias using SOAP.'"/>
            <cc:set name="inLogMessageDetail" value="'The URL constructed including querystring parameters exceed the maximum URL length for RESTful RaaS calls of 16000 Bytes.  Switching to use SOAP as protocol.'"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
            
            
            
            
        </cc:local-out>
        <cc:local-out id="Call_ExecuteWithRest_102" store-message="none" routes-response-to="Results_102" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/ExecuteWithRest_102"><cc:set name="inRestUrl" value="props['localRestUrl']"/></cc:local-out>
        <cc:local-out id="Call_ExecuteWithSoap_102" store-message="none" routes-response-to="Results_102" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/ExecuteWithSoap_102"><cc:set name="inPropertyNameReportPromptMap" value="props['inPropertyNameReportPromptMap']"/><cc:set name="inReportServiceAlias" value="props['inReportServiceAlias']"/><cc:set name="inDebugMode" value="props['inDebugMode']"/></cc:local-out>
        <cc:async-mediation id="ComposeRequest_102" routes-to="Call_Debug_SoapRequest_102">
            <cc:steps>
                <cc:write id="WriteSoapRequest">
                    <cc:message>
                        <cc:text>&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:wd="urn:com.workday/bsvc" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
	&lt;soapenv:Header>
		&lt;wsse:Security soapenv:mustUnderstand="1">
			&lt;wsse:UsernameToken>
				&lt;wsse:Username>@{props['wss.usernametoken.username']}&lt;/wsse:Username>
				&lt;wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText">@{props['wss.usernametoken.password']}&lt;/wsse:Password>
			&lt;/wsse:UsernameToken>
		&lt;/wsse:Security>
	&lt;/soapenv:Header>
	&lt;soapenv:Body>
		&lt;wd:Execute_Report>
</cc:text>
                        <cc:text>			&lt;wd:Report_Parameters xmlns:wd="urn:com.workday/bsvc">&#xd;
			@{com.workday.custom.int200.postprocessor.sa102.ParameterMapHelper.getSoapRequestParameters(context, props.inPropertyNameReportPromptMap)}&#xd;
			&lt;/wd:Report_Parameters></cc:text>
                        <cc:text>		&lt;/wd:Execute_Report>&#xd;
	&lt;/soapenv:Body>&#xd;
&lt;/soapenv:Envelope></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ComposeRequest_Error_102"/>
        </cc:async-mediation>
        <cc:local-in id="AddReportPromptFromProperty" routes-to="InitializeAndFinalize_Property_101" access="public" icon="icons/AddReportPromptFromProperty.png">
			<cc:parameter documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  When setting this input parameter, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap.  This data structure can be easily created through the com.workday.custom.int200.postprocessor.sa102.ParameterMapHelper class and initializeParameterMap method and then subsequently managed with the SA101 sub-assemblies." name="inPropertyNameReportPromptMap" required="true" type="string"/>
        	<cc:parameter documentation="The XML name of the report prompt as specified on the Prompts tab of the Custom Report." name="inReportPromptName" required="true" type="string"/>
        	<cc:parameter documentation="The Id type of the value being provided on the prompt if the value is an instance reference.  For example, if the report prompt accepted workers and you were sending employees, this value might be 'Employee_ID'.  If the report prompt is a non-instance value, this parameter may be left empty / omitted." name="inReferenceIdType" required="false" type="string"/>
        	<cc:parameter documentation="The value to be assigned to the report prompt.  This may be a numeric value, string value or instance reference id." name="inValue" required="true"/>
        </cc:local-in>
        <cc:local-in id="AddReportPromptFromXml" routes-to="InitializeAndFinalize_Xml_101" icon="icons/AddReportPromptFromXml.png">
			<cc:parameter documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  When setting this input parameter, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap.  This data structure can be easily created through the com.workday.custom.int200.postprocessor.sa102.ParameterMapHelper class and initializeParameterMap method and then subsequently managed with the SA101 sub-assemblies." name="inPropertyNameReportPromptMap" required="true" type="string"/>
            <cc:parameter documentation="The XML name of the report prompt as specified on the Prompts tab of the Custom Report." name="inReportPromptName" required="true" type="string"/>
            <cc:parameter documentation="The Id type of the value being provided on the prompt if the value is an instance reference.  For example, if the report prompt accepted workers and you were sending employees, this value might be 'Employee_ID'.  If the report prompt is a non-instance value, this parameter may be left empty / omitted." name="inReferenceIdType" required="false" type="string"/>
            <cc:parameter documentation="The location where the XML data containing the parameter values can be found.  This may be either on the Message root or in a variable.  In the former case, specify the value of this parameter as the literal 'message'.  Otherwise, if the value is found in a variable, please set this parameter to the name of that variable." name="inParameterDataLocation" required="true" type="string" validation="props['inParameterDataLocation'] == 'message' || vars.isVariable(props.inParameterDataLocation)"/>
            <cc:parameter documentation="The XPath query that will select the values from the XML data to be used as report parameters." name="inQueryToValue" required="true" type="string"/>
            <cc:parameter documentation="XPath expression which can optionally be executed against the elements returned by QueryToEntry in order to determine if those entries should be stored in the map" name="inEntryFilter" required="false" type="string"/>
            <cc:parameter default="props['globalIsDebugMode']" documentation="Controls whether or not the dynamic XSLT is output on debug." name="inDebugMode" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Xml_Error_101" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Parameter Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_Xml_101" routes-to="NormalizeMapValues_Xml_101" continue-after-error="rewind" handle-downstream-errors="false" routes-response-to="Call_Finally_Multiple_101">
            <cc:request-steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsPromptsMap'] = context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map;</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10101" failure-message="The value contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap is not a map.">props['localIsPromptsMap']</cc:expression>
                </cc:validate-exp>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Xml_Error_101"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Property_Error_101" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Parameter Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_Property_101" routes-to="NormalizeMapValues_Property_101" continue-after-error="rewind" handle-downstream-errors="false" routes-response-to="Call_Finally_Single_101">
            <cc:request-steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsPromptsMap'] = context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map;</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10100" failure-message="The value contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap is not a map.">props['localIsPromptsMap']</cc:expression>
                </cc:validate-exp>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Property_Error_101"/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_101">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsPromptsMap','localKey','localValue']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localXslt101']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_101" routes-to="Teardown_101"/>
        <cc:local-out id="Call_Finally_Single_101" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_101"/>
        <cc:local-out id="Call_Finally_Multiple_101" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_101"/>
        <cc:async-mediation id="NormalizeMapValues_Property_101" routes-to="Validate_Property_101">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localKey'] = (props['inReferenceIdType'] == empty) ? props['inReportPromptName'] : props['inReportPromptName'] # '!' # props['inReferenceIdType'];</cc:expression>
                    <cc:expression>if (props['inValue'] instanceof java.lang.Object) {&#xd;
	props['localValue'] = props['inValue'];&#xd;
} else {&#xd;
	props['localValue'] = String.valueOf(props['inValue']);&#xd;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_NormalizeMapValues_Property_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_NormalizeMapValues_Property_Error_101" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Prompt Key/Value Pair Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while composing the key and value data for map storage on the ' # props['inReportPromptName'] # ' report prompt.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:local-out id="Call_HandleError_Validate_Property_Error_101" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Duplicate Map Key'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating a reports-as-a-service prompt key/value pair.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="Validate_Property_101" routes-to="UpdateMap_Property_101">
            <cc:steps>
                <cc:validate-exp id="ValidateKey">
                    <cc:expression error-number="10102" failure-message="The map already contains a key named @{props['localKey']}.">!(((java.util.Map)props[props.inPropertyNameReportPromptMap]).containsKey(props.localKey))</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Validate_Property_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_UpdateMap_Property_Error_101" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Map Update Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while writing the value data under the ' # props['localKey'] # ' report prompt in the ' # props['inPropertyNameReportPromptMap'] # ' map.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="UpdateMap_Property_101">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>((java.util.Map)props[props.inPropertyNameReportPromptMap]).put(props['localKey'], props['localValue']);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_UpdateMap_Property_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_UpdateMap_Xml_Error_101" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Map Update Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while writing the value data under the ' # props['localKey'] # ' report prompt in the ' # props['inPropertyNameReportPromptMap'] # ' map.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="UpdateMap_Xml_101">
            <cc:steps>
                <cc:xslt-plus id="BuildList" url="mctx:vars/localXslt101"/>
                <cc:eval id="UpdateValues">
                    <cc:expression>((java.util.Map)props[props.inPropertyNameReportPromptMap]).put(props['localKey'], props['localValue']);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_UpdateMap_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Validate_Xml_Error_101" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Duplicate Map Key'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating a reports-as-a-service prompt key/value pair.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="Validate_Xml_101" routes-to="UpdateMap_Xml_101">
            <cc:steps>
                <cc:validate-exp id="Validations">
                    <cc:expression error-number="10104" failure-message="The map already contains a key named @{props['localKey']}.">!(((java.util.Map)props[props.inPropertyNameReportPromptMap]).containsKey(props.localKey))</cc:expression>
                    <cc:expression error-number="10105" failure-message="The referenced data for transformation into Report Prompt data indicated at @{props['inParameterDataLocation']} is not in XML format.">parts[0].isXml()</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Validate_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_NormalizeMapValues_Xml_Error_101" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Prompt Key/Value Pair Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while composing the key and value data for map storage on the ' # props['inReportPromptName'] # ' report prompt.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="NormalizeMapValues_Xml_101" routes-to="Call_Debug_Xslt_101">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localKey'] = (props['inReferenceIdType'] == empty) ? props['inReportPromptName'] : props['inReportPromptName'] # '!' # props['inReferenceIdType'];</cc:expression>
                    <cc:expression>props['localValue'] = new java.util.ArrayList();</cc:expression>
                </cc:eval>
                <cc:write id="WriteXslt" output="variable" output-variable="localXslt101">
                    <cc:message>
                        <cc:text>&lt;?xml version="1.0" encoding="UTF-8"?>&#xd;
&lt;xsl:stylesheet version="3.0" &#xd;
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&#xd;
    xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"&#xd;
    xmlns:wd="urn:com.workday/bsvc"&#xd;
    xmlns:tube="java:com.capeclear.mediation.impl.cc.MediationTube"&#xd;
    xmlns:ctx="java:com.capeclear.mediation.MediationContext"&#xd;
    xmlns:xs="http://www.w3.org/2001/XMLSchema"&#xd;
    xmlns:jlist="java:java.util.List"&#xd;
    xmlns:jt="http://saxon.sf.net/java-type"&#xd;
    xmlns:this="urn:this">&#xd;
    &#xd;
    &lt;xsl:param name="inQueryToValue" as="xs:string"/>&#xd;
    &#xd;
    &lt;xsl:mode streamable="no" on-no-match="shallow-skip"/>&#xd;
    &#xd;
    &lt;!-- Obtain the current MediationContext in use in the assembly -->&#xd;
    &lt;xsl:variable name="ctx" select="tube:getCurrentMediationContext()"/>&#xd;
    &#xd;
    &lt;!-- Retrieve the Java List stored in the context property localValue -->&#xd;
    &lt;xsl:variable name="list" select="ctx:getProperty($ctx, 'localValue')" as="jt:java.util.List"/>&#xd;
    &#xd;
    &lt;xsl:template match="/">&#xd;
        &lt;ListHelper>&#xd;
            &lt;!-- Now process the input file.  The EntryFilter variable can then be optionally used to only select those entries matching that value.  The filter can only navigate the descendant axis since only the node and and descendants returned by the QueryToEntry expression are brought into memory -->&#xd;
            &lt;xsl:apply-templates select="@{props['inQueryToValue']}@if{props['inEntryFilter'] != empty}[@{props['inEntryFilter']}]@end{}"/>    		&#xd;
        &lt;/ListHelper>&#xd;
    &lt;/xsl:template>&#xd;
    &#xd;
    &lt;!-- Process each entry -->&#xd;
    &lt;xsl:template match="@{props['inQueryToValue']}">&#xd;
        &lt;xsl:variable name="value"	 select="./text()" as="xs:string"/>&#xd;
        &#xd;
		&lt;xsl:value-of select="jlist:add($list, $value)"/>&#xd;
    &lt;/xsl:template>&#xd;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_NormalizeMapValues_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_PrepareInputData_Xml_Error_101" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Map Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while moving the value data from the ' # props['inParameterDataLocation'] # ' variable to the message root for extraction.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="PrepareInputData_Xml_101" routes-to="Validate_Xml_101" execute-steps-when="props['inParameterDataLocation'] != 'message'">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>parts[0] = vars[props.inParameterDataLocation];</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_PrepareInputData_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Xslt_101" store-message="none" execute-when="props['inDebugMode']" routes-response-to="PrepareInputData_Xml_101" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localXslt101'"/>
            
        </cc:local-out>
        <cc:local-in id="HandleError" routes-to="Call_CreateLogEntry_109" access="public" icon="icons/HandleError.png">
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogMessage parameter." name="inLogMessage" required="true" type="string"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogMessageDetail parameter." name="inLogMessageDetail" required="false" type="string"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogReferenceId parameter." name="inLogReferenceId" required="false" type="string"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogLevel parameter.  Validation is performed by CreateLogEntry." name="inLogLevel" required="true" type="string"/>
            <cc:parameter default="context.errorComponentId" documentation="Value passed to CreateLogEntry's inExtraLocalIn parameter." name="inExtraLocalIn" required="false" type="string"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inExtraRecordNumber parameter." name="inExtraRecordNumber" required="false" type="string"/>
            <cc:parameter default="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message" documentation="Value passed to CreateLogEntry's inExtraSupportData parameter." name="inExtraSupportData" required="false" type="string"/><cc:parameter default="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''" documentation="Value passed to CreateLogEntry's inExtraErrorCode parameter." name="inExtraErrorCode" required="false" type="string"/><cc:parameter documentation="The sub-assembly endpoint to call for clean-up of properties and/or variables." name="inFinallyEndpoint" required="false" type="string"/>
            <cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler.  In order for this parameter to have an effect of aborting the sub-assembly from which it was called, the Propagate Abort setting on the Advanced tab of the calling Local-Out component must be set to true." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="When set to true, clears the residual error details by setting a null exception." name="inIsResetError" required="false" type="boolean"/><cc:parameter default="props['globalIsDebugMode']" documentation="Controls whether or not the dynamic XSLT is output on debug." name="inIncludeDebugOutput" required="true" type="boolean"/>
        	<cc:parameter default="'message'" documentation="The type of information to be output to the log." name="inTargetType" required="props['inIncludeDebugOutput']" type="string" validation="props['globalDebugTargetTypeParameterValidation'].contains(props['inTargetType'])"/>
        	<cc:parameter documentation="The reference name to use for single-named output types selected on inTargetType.  Required when inTargetType is one of: property, variable, list, map, or set." name="inTargetName" required="false" type="string" validation="props['globalDebugTargetNameParameterValidation'].contains(props['inTargetType']) &amp;&amp;&#xd;&#xa;(props['inTargetName'] != empty || props['inEntityName'] != empty)"/>
        	<cc:parameter documentation="A specific filename to use when exporting the message or variable content to a file zipped in a consolidated archive.  This is optional and only used when inTargetType is &quot;message&quot; or &quot;variable&quot;." name="inEntityName" required="false" type="string"/>
        	<cc:out-parameter name="outEntityName"/>
        </cc:local-in>
        <cc:local-out id="Call_Finally_109" store-message="none" execute-when="props['inFinallyEndpoint'] != empty" routes-response-to="Handler_109" endpoint="@{props['inFinallyEndpoint']}"/>
        <cc:async-mediation id="Handler_109" routes-to="AbortOnError_109">
            <cc:steps>
                <cc:eval id="HandleError">
                    <cc:expression>if (props.containsKey('inIsResetError') &amp;&amp; props.inIsResetError) { context.setException(null); }</cc:expression>
                    <cc:expression>context.setErrorHandled(true);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="AbortOnError_109" execute-steps-when="props['inIsAbortOnError']">
            <cc:steps>
                <cc:eval id="SetAbort">
                    <cc:expression>context.setAbort(true);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_109" store-message="none" routes-response-to="Call_Debug_109" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry">
            <cc:set name="inLogMessage" value="props.inLogMessage"/>
            <cc:set name="inLogMessageDetail" value="if (context.containsProperty('inLogMessageDetail')) {&#xd;&#xa;&#x9;(props['inLogMessageDetail'] != empty) ? props['inLogMessageDetail'] : ''&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
            <cc:set name="inLogReferenceId" value="if (context.containsProperty('inLogReferenceId')) {&#xd;&#xa;&#x9;(props['inLogReferenceId'] != empty) ? props['inLogReferenceId'] : ''&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
            <cc:set name="inLogLevel" value="props.inLogLevel"/>
            <cc:set name="inExtraLocalIn" value="if (context.containsProperty('inExtraLocalIn')) {&#xd;&#xa;&#x9;(props['inExtraLocalIn'] != empty) ? props['inExtraLocalIn'] : ''&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
            <cc:set name="inExtraRecordNumber" value="if (context.containsProperty('inExtraRecordNumber')) {&#xd;&#xa;&#x9;(props['inExtraRecordNumber'] != empty) ? props['inExtraRecordNumber'] : ''&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
            <cc:set name="inExtraSupportData" value="if (context.containsProperty('inExtraSupportData')) {&#xd;&#xa;&#x9;(props['inExtraSupportData'] != empty) ? props['inExtraSupportData'] : ''&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
            <cc:set name="inExtraErrorCode" value="if (context.containsProperty('inExtraErrorCode')) {&#xd;&#xa;&#x9;(props['inExtraErrorCode'] != empty) ? props['inExtraErrorCode'] : ''&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_109" store-message="none" execute-when="props['inIncludeDebugOutput'] &amp;&amp; props['inTargetType'] != empty" routes-response-to="Call_Finally_109" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="props['inTargetType']"/>
            <cc:set name="inTargetName" value="props['inTargetName']"/>
            <cc:set name="inEntityName" value="props['inEntityName']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Result_102" store-message="none" execute-when="props['inDebugMode'] || props['inSaveResultsToIntegrationEvent']" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/Debug">
            <cc:set name="inTargetType" value="props['inTargetType']"/>
            <cc:set name="inTargetName" value="props['inReturnResults'] == 'message' ? null : 'globalRaaSResults'"/><cc:set name="inEntityName" value="'RAAS-Results__' # props['inReportServiceAlias']"/>
            
        </cc:local-out>
        <cc:local-in id="SetupGlobal" routes-to="InitializeCoreStarterKit_109"/>
        <cc:local-in id="InitializeFrameworkThenRunMain" routes-to="Initialize" access="public" icon="icons/InitializeFrameworkThenRunMain.png"><cc:parameter default="'vm://INT200_Ceridian_Dayforce_PostProcessor/Main'" documentation="This parameter value will define the main flow and logic processing of the integration.  This is where all of the requirements-specific work will happen in between the StarterKit framework initialization and finalization." name="inMainEndpoint" required="true" type="string"/></cc:local-in>
        <cc:local-out id="Call_InitializeFrameworkThenRunMain" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/InitializeFrameworkThenRunMain" unset-properties="false"><cc:set name="inMainEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/Main'"/></cc:local-out>
        <cc:route id="RouteDestination_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inReturnResults'] == 'message'" route="AggregateToMessage"/>
                <cc:choose-route expression="true" route="AggregateToVariable"/>
            </cc:mvel-strategy>
            <cc:sub-route name="AggregateToMessage" routes-to="AggregateMessage_104"/>
            <cc:sub-route name="AggregateToVariable" routes-to="AggregateVariable_104"/>
        </cc:route>
        <cc:aggregator id="AggregateMessage_104" force-batch-on-last-message="false" force-batch-when="props['is.paged.get.last.page']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="message" output-mimetype="text/xml" xpath="@{props['inXpathToResultsToAggregate']}">
        <cc:header-text>@{props['inAggregatedResultsHeader']}</cc:header-text>
        <cc:footer-text>@{props['inAggregatedResultsFooter']}</cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:async-mediation id="RetrieveMessage_112" routes-to="Call_CreateLogEntry_Message_112">
            <cc:steps>
                <cc:eval id="UpdateValues"><cc:expression>props['localLogMessage'] = props['localLogIterator'].next()</cc:expression></cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="LoopOverMessages_112">
            <cc:loop-strategy condition="props['localLogIterator'].hasNext()"/>
            <cc:sub-route name="Loop" routes-to="RetrieveMessage_112"/>
        </cc:route>
        <cc:sync-mediation id="InitializeAndFinalize_112" routes-to="LoopOverMessages_112" handle-downstream-errors="true">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props.localLogIterator = new com.workday.custom.int200.postprocessor.sa112.ObjectIterator(props.inLogIterator)</cc:expression>
                    <cc:expression>props.localHasMessages = props.localLogIterator.hasNext()</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp"><cc:expression>foreach (name: {'localHasMessages', 'localLogMessage', 'localLogIterator'}) { context.removeProperty(name) } </cc:expression></cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-in id="CloudLogMessages_112" routes-to="InitializeAndFinalize_112" access="private">
            <cc:parameter documentation="An instance of Iterator&lt;CloudLogAdapter> which will be used to iterate over all the messages to be placed in the cloud-log" name="inLogIterator" required="true"/>
            
            
            
            
            
            
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntry_Message_112" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CreateLogEntry"><cc:set name="inLogMessage" value="props['localLogMessage'].message"/><cc:set name="inLogMessageDetail" value="props['localLogMessage'].details"/><cc:set name="inLogReferenceId" value="props['localLogMessage'].referenceId"/><cc:set name="inLogLevel" value="String.valueOf(props['localLogMessage'].level)"/></cc:local-out>
        <cc:local-in id="CloudLogETVXTTMessages" routes-to="InitializeAndFinalize_ETVXTT_112" access="public" icon="icons/CloudLogETVXTTMessages.png">
            <cc:parameter default="props['etv.messages']" documentation="An instance of ETVInfoCollection" name="inMessages" required="false" validation="props['inMessages'] instanceof com.workday.mediation.impl.mediators.etv.ETVInfoCollection"/>
            <cc:parameter default="false" documentation="Specifies whether the collection should be cleared after it is output to the log.  The default is to be cleared." name="inIsClearMessages" required="false" type="boolean"/>
            <cc:parameter default="'INFO'" documentation="Mininum severlty level to be reported.  Defaults to INFO" name="inMinLogLevel" required="false" validation="['INFO','WARNING','ERROR','CRITICAL'] contains props['inMinLogLevel']"/>
            
            
            
            
            
            
            
            <cc:out-parameter documentation="Boolean value that indicates whether an error or critical condition was detected" name="etv.has.error"/>
            <cc:out-parameter documentation="Number of messages reported on the current invocation" name="etv.reported.messages"/>
            <cc:out-parameter documentation="Total number of messages reported during the current launch" name="etv.total.reported.messages"/>
        </cc:local-in>
        <cc:local-in id="CloudLogXSLTMessages" routes-to="InitializeAndFinalize_XSLT_112" access="public" icon="icons/CloudLogXSLTMessages.png">
            <cc:parameter default="props['xsltstep.messages']" documentation="An instance of java.util.List which contains the messages" name="inMessages" required="true" validation="props['inMessages'] instanceof java.util.List"/>
            <cc:parameter default="true" documentation="Specifies whether the inXSLTMessages list should be cleared after it is output to the log.  The default is to be cleared." name="inIsClearMessages" required="false" type="boolean"/>
            
            
            
            
            
            
            
            <cc:parameter default="'debug'" documentation="The minimum level for which messages will be output.  If no value is given a default of debug will be used" name="inMinLogLevel" required="false" validation="['debug','info','warn','error','critical'] contains props['inMinLogLevel'].trim().toLowerCase()"/>
        </cc:local-in>
        <cc:local-out id="Call_CloudLogMessages_XSLT_112" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CloudLogMessages_112"><cc:set name="inLogIterator" value="com.workday.custom.int200.postprocessor.sa112.CloudLogXsltStepIterator.getIterator(props['inMessages'], props['inMinLogLevel'])"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_XSLT_112" routes-to="Call_CloudLogMessages_XSLT_112">
            <cc:request-steps/>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>if (props['inIsClearMessages']) { props['inMessages'].clear() }</cc:expression><cc:expression>foreach (name: {'inMessages', 'inIsClearMessages', 'inMinLogLevel'}) { context.removeProperty(name) } </cc:expression></cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-out id="Call_CloudLogMessages_ETVXTT_112" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CloudLogMessages_112">
            <cc:set name="inLogIterator" value="com.workday.custom.int200.postprocessor.sa112.CloudLogETVIterator.getIterator(props['inMessages'], props['inMinLogLevel'])"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_ETVXTT_112" routes-to="Call_CloudLogMessages_ETVXTT_112">
            <cc:request-steps/>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>if (props['inIsClearMessages']) { props['inMessages'].clear() }</cc:expression><cc:expression>foreach (name: {'inMessages', 'inIsClearMessages', 'inMinLogLevel'}) { context.removeProperty(name) } </cc:expression></cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:route id="RouteSource_106">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inDataSource'] == 'variable'" route="Variable"/>
                <cc:choose-route expression="true" route="Message"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Variable" routes-to="StoreVariable_106"/>
            <cc:sub-route name="Message" routes-to="StoreMessage_106"/>
        </cc:route>
        <cc:local-out id="Call_HandleError_StoreMessage_Error_106" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Storage Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while storing data to the Integration Event.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_106" routes-to="RouteSource_106">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localFilename'] = props['inOutputFilename'];</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localFilename']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localStoreResult']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                </cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:async-mediation id="StoreMessage_106" routes-to="PIM_Tag_106">
            <cc:steps>
                <cc:store id="StoreContent" output="variable" output-mimetype="text/xml" output-variable="localStoreResult" input="message" createDocumentReference="true" expiresIn="@{props['inDocumentRetentionPeriod']}" title="@{props['localFilename']}"/></cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_StoreMessage_Error_106"/>
        </cc:async-mediation>
        <cc:async-mediation id="StoreVariable_106" routes-to="PIM_Tag_106">
            <cc:steps>
                <cc:store id="StoreContent" output="variable" output-mimetype="text/xml" output-variable="localStoreResult" input="variable" input-variable="globalOutputData" createDocumentReference="true" expiresIn="@{props['inDocumentRetentionPeriod']}" title="@{props['localFilename']}"/></cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_StoreVariable_Error_106"/>
        </cc:async-mediation>
        <cc:local-in id="RetrievePECI" routes-to="Call_GetDocumentList"/>
        <cc:local-out id="Call_RetrievePECI" store-message="none" routes-response-to="Call_IEP_15" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/RetrievePECI"/>
        <cc:local-out id="Call_GetDocumentList" store-message="none" routes-response-to="ParseFileMetadata" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/GetDocumentList"><cc:set name="inEventWID" value="lp.isSet() ? lp.getIntegrationEventWID() : null"/><cc:set name="inNoFileThrowsException" value="true"/><cc:set name="inMultipleFilesThrowsException" value="false"/><cc:set name="inExactFileCountExpected" value="-1"/><cc:set name="inRetrievalDocTag" value="'Deliverable'"/><cc:set name="inIsAbortOnError" value="true"/></cc:local-out>
        <cc:local-out id="Call_LoadFile" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/LoadFile"><cc:set name="inFileCounter" value="(int)props['localFileIndex']"/><cc:set name="inFilename" value="props['globalRetrievalDocName']"/><cc:set name="inIsAbortOnError" value="false"/></cc:local-out>
        <cc:sync-mediation id="ParseFileMetadata" routes-to="Call_LoadFile">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localFileIndex'] = vars['globalDAMetadata'].xpath('/Metadata/File[Name = "' # props['globalRetrievalDocName'] # '"]/Counter');</cc:expression>
                </cc:eval>
                <cc:validate-exp id="Validations">
                    <cc:expression error-number="10000" failure-message="Unable to locate the aggregated PECI output file @{props['globalRetrievalDocName']}">props['localFileIndex'] != empty</cc:expression>
                </cc:validate-exp>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localFileIndex']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                </cc:eval>
            </cc:response-steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ParseFileMetadata"/>
        </cc:sync-mediation>
        <cc:local-in id="RetrievePeriodSchedules" routes-to="CalculatePromptsForPeriodSchedules"/>
        <cc:local-out id="Call_RetrievePeriodSchedules" store-message="none" routes-response-to="Call_IEP_30" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/RetrievePeriodSchedules" unset-properties="false"/>
        <cc:sync-mediation id="CalculatePromptsForPeriodSchedules" routes-to="Call_CallRaaS_PeriodSchedules">
            <cc:request-steps>
                <cc:xslt-plus id="ParsePeriodDates" output-mimetype="text/xml" input="variable" input-variable="globalInputData" url="xslt/ParsePeriodDates.xsl"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['localPeriodSchedulePromptMap'] = new java.util.HashMap();&#xd;
props['localPeriodSchedulePromptMap'].put(props['globalRaasPromptStart'], com.workday.custom.int200.postprocessor.DateUtils.calculatePeriodRangeStartFromXmlString(parts[0].xpath('/PeriodRange/Start')));&#xd;
props['localPeriodSchedulePromptMap'].put(props['globalRaasPromptEnd'], com.workday.custom.int200.postprocessor.DateUtils.calculatePeriodRangeEndFromXmlString(parts[0].xpath('/PeriodRange/End')));</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localPeriodSchedulePromptMap', 'outMap']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    <cc:expression>foreach (varname : ['globalRaaSResults']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                </cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-out id="Call_CallRaaS_PeriodSchedules" store-message="none" routes-response-to="CachePeriodSchedules" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CallRaaS"><cc:set name="inReportServiceAlias" value="'Period Data'"/><cc:set name="inPropertyNameReportPromptMap" value="'localPeriodSchedulePromptMap'"/><cc:set name="inIsUseJavaUrlEncoder" value="false"/><cc:set name="inReturnResults" value="'message'"/><cc:set name="inDebugMode" value="props['globalIsDebugMode']"/><cc:set name="inIsAbortOnError" value="true"/></cc:local-out>
        <cc:local-out id="Call_HandleError_ParseFileMetadata" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError"><cc:set name="inLogMessage" value="'File Input Error'"/><cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inIsAbortOnError" value="true"/><cc:set name="inIncludeDebugOutput" value="props['globalIsDebugMode']"/><cc:set name="inTargetType" value="'variable'"/><cc:set name="inTargetName" value="'globalDAMetadata'"/></cc:local-out>
        <cc:async-mediation id="CachePeriodSchedules">
            <cc:steps>
                <cc:validate-xpath id="Validations" namespaces="wd urn:com.workday.report/CR_INT200_Pay_Period_Details" xpath="/wd:Report_Data/wd:Report_Entry"/>
                <cc:copy id="CopyVarToVar" output="variable" output-mimetype="text/xml" output-variable="globalPeriodSchedules" input="message"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CachePeriodSchedules"/>
        </cc:async-mediation>
        <cc:local-in id="RetrieveWorkerData" routes-to="CalculatePromptsForWorkerData"/>
        <cc:local-out id="Call_RetrieveWorkerData" store-message="none" routes-response-to="Call_IEP_40" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/RetrieveWorkerData"><cc:set name="inAnchorPeriodStartDate" value="props['outAnchorPeriodStartDate']"/></cc:local-out>
        <cc:sync-mediation id="CalculatePromptsForWorkerData" routes-to="Call_CallRaaS_WorkerData">
            <cc:request-steps>
                <cc:xslt-plus id="ParsePayDates" output-mimetype="text/xml" input="variable" input-variable="globalPeriodSchedules" url="xslt/ParsePayDates.xsl"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['localHsaContributionYear'] = parts[0].xpath('/ContributionYear');</cc:expression>
                    <cc:expression>java.util.Date contributionYearStart = com.workday.custom.int200.postprocessor.DateUtils.getFirstDayOfYear(props['localHsaContributionYear']);&#xd;
java.util.Date contributionYearEnd = com.workday.custom.int200.postprocessor.DateUtils.getLastDayOfYear(props['localHsaContributionYear']);&#xd;
&#xd;
props['localWorkerDataPromptMap'] = new java.util.HashMap();</cc:expression>
                    <cc:expression>props['localWorkerDataPromptMap'].put(props['globalRaasPromptEarlyStart'], com.workday.custom.int200.postprocessor.DateUtils.convertDateToXmlString(contributionYearStart));&#xd;
props['localWorkerDataPromptMap'].put(props['globalRaasPromptEarlyEnd'], com.workday.custom.int200.postprocessor.DateUtils.convertDateToXmlString(contributionYearEnd));</cc:expression>
                    <cc:expression>java.util.Date nextYearStart = com.workday.custom.int200.postprocessor.DateUtils.addMonthsToDate(contributionYearStart, 12);&#xd;
java.util.Date nextYearEnd = com.workday.custom.int200.postprocessor.DateUtils.addMonthsToDate(contributionYearEnd, 12);&#xd;
&#xd;
props['localWorkerDataPromptMap'].put(props['globalRaasPromptLateStart'], com.workday.custom.int200.postprocessor.DateUtils.convertDateToXmlString(nextYearStart));&#xd;
props['localWorkerDataPromptMap'].put(props['globalRaasPromptLateEnd'], com.workday.custom.int200.postprocessor.DateUtils.convertDateToXmlString(nextYearEnd));</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localHsaContributionYear', 'localWorkerDataPromptMap']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                </cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-out id="Call_CallRaaS_WorkerData" store-message="none" routes-response-to="CacheWorkerData" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CallRaaS"><cc:set name="inReportServiceAlias" value="'Worker Data'"/><cc:set name="inSaveResultsToIntegrationEvent" value="false"/><cc:set name="inPropertyNameReportPromptMap" value="'localWorkerDataPromptMap'"/><cc:set name="inIsUseJavaUrlEncoder" value="false"/><cc:set name="inReturnResults" value="'message'"/><cc:set name="inDebugMode" value="props['globalIsDebugMode']"/><cc:set name="inIsAbortOnError" value="true"/></cc:local-out>
        <cc:async-mediation id="CacheWorkerData">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="globalWorkerData"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_CachePeriodSchedules" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'Pay Period Retrieval Error'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIncludeDebugOutput" value="props['globalIsDebugMode']"/>
            <cc:set name="inTargetType" value="'map'"/>
            <cc:set name="inTargetName" value="'localPeriodSchedulePromptMap'"/>
        </cc:local-out>
        <cc:local-out id="Call_TransformData" store-message="none" routes-response-to="Call_IEP_70" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/TransformData"/>
        <cc:local-in id="TransformData" routes-to="ConvertDataFromPeciToDayforce"/>
        <cc:async-mediation id="CollateDataToDayforceFiles">
            <cc:steps>
                <cc:xslt-plus id="CollateHrImport" output="variable" output-mimetype="text/xml" output-variable="localHrImportRecords" input="variable" input-variable="localCeridianRecords" url="xslt/CollateHrImport.xsl"/>
                <cc:xslt-plus id="CollateEmployeeElection" output="variable" output-mimetype="text/xml" output-variable="localEmployeeElectionRecords" input="variable" input-variable="localCeridianRecords" url="xslt/CollateEmployeeElection.xsl"/>
                <cc:xslt-plus id="CollatePayEntryImport" output="variable" output-mimetype="text/xml" output-variable="localPayEntryImportRecords" input="variable" input-variable="localCeridianRecords" url="xslt/CollatePayEntryImport.xsl"/>
                <cc:xslt-plus id="CollatePayEntryImportOffCycle" output="variable" output-mimetype="text/xml" output-variable="localPayEntryImportOffCycleRecords" input="variable" input-variable="localCeridianRecords" url="xslt/CollatePayEntryImportOffCycle.xsl"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CloudLogETVXTTMessages_ConvertData" store-message="none" routes-response-to="CollateDataToDayforceFiles" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CloudLogETVXTTMessages"><cc:set name="inMessages" value="props['etvMessages']"/><cc:set name="inIsClearMessages" value="true"/><cc:set name="inMinLogLevel" value="'INFO'"/></cc:local-out>
        <cc:local-in id="GenerateFiles" routes-to="Prepare_HRImport_Output"/>
        <cc:local-out id="Call_GenerateFiles" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/GenerateFiles"/>
        <cc:local-out id="Call_GenerateOutput_HRImport" store-message="none" execute-when="props['localIsOutputHRImport']" routes-response-to="Prepare_EmployeeElections_Output" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/GenerateOutput"><cc:set name="inTargetEventWID" value="lp.isSet() ? lp.getIntegrationEventWID() : null"/><cc:set name="inOutputFilename" value="props['globalFilenameHRImport']"/><cc:set name="inDocumentRetentionPeriod" value="props['globalDocumentRetentionPeriod']"/><cc:set name="inOutputDocumentTag" value="'INT200_HRImport'"/><cc:set name="inOutputIsDeliverable" value="true"/><cc:set name="inIsAbortOnError" value="false"/><cc:set name="inDataSource" value="'message'"/></cc:local-out>
        <cc:local-out id="Call_GenerateOutput_EmployeeElections" store-message="none" execute-when="props['localIsOutputEmployeeElections'] &amp;&amp; false" routes-response-to="Prepare_PayEntryImport_Output" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/GenerateOutput"><cc:set name="inTargetEventWID" value="lp.isSet() ? lp.getIntegrationEventWID() : null"/><cc:set name="inOutputFilename" value="props['globalFilenameEmployeeElection']"/><cc:set name="inDocumentRetentionPeriod" value="props['globalDocumentRetentionPeriod']"/><cc:set name="inOutputDocumentTag" value="'INT200_EmployeeElection'"/><cc:set name="inOutputIsDeliverable" value="true"/><cc:set name="inIsAbortOnError" value="false"/><cc:set name="inDataSource" value="'message'"/></cc:local-out>
        <cc:local-out id="Call_GenerateOutput_PayEntryImport" store-message="none" execute-when="props['localIsOutputPayEntryInput'] &amp;&amp; false" routes-response-to="Prepare_PayEntryImportOffCycle_Output" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/GenerateOutput"><cc:set name="inTargetEventWID" value="lp.isSet() ? lp.getIntegrationEventWID() : null"/><cc:set name="inOutputFilename" value="props['globalFilenamePayEntryImport']"/><cc:set name="inDocumentRetentionPeriod" value="props['globalDocumentRetentionPeriod']"/><cc:set name="inOutputDocumentTag" value="'INT200_PayEntryImport'"/><cc:set name="inOutputIsDeliverable" value="true"/><cc:set name="inIsAbortOnError" value="false"/><cc:set name="inDataSource" value="'message'"/></cc:local-out>
        <cc:local-out id="Call_GenerateOutput_PayEntryImporOffCycle" store-message="none" execute-when="props['localIsOutputPayEntryInputOffCycle'] &amp;&amp; false" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/GenerateOutput"><cc:set name="inTargetEventWID" value="lp.isSet() ? lp.getIntegrationEventWID() : null"/><cc:set name="inOutputFilename" value="props['globalFilenamePayEntryImportOffCycle']"/><cc:set name="inDocumentRetentionPeriod" value="props['globalDocumentRetentionPeriod']"/><cc:set name="inOutputDocumentTag" value="'INT200_PayEntryImport'"/><cc:set name="inOutputIsDeliverable" value="true"/><cc:set name="inIsAbortOnError" value="false"/><cc:set name="inDataSource" value="'message'"/></cc:local-out>
        <cc:async-mediation id="Prepare_HRImport_Output" routes-to="Call_GenerateOutput_HRImport">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localIsOutputHRImport'] = false;&#xd;
props['localIsOutputEmployeeElections'] = false;&#xd;
props['localIsOutputPayEntryInput'] = false;&#xd;
props['localIsOutputPayEntryInputOffCycle'] = false;</cc:expression>
                </cc:eval>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="localHrImportRecords"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['localIsOutputHRImport'] = parts[0].xstreamB('/EmployeeImport/Employee');</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Prepare_EmployeeElections_Output" routes-to="Call_GenerateOutput_EmployeeElections" execute-steps-when="false">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="localEmployeeElectionRecords"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['localIsOutputEmployeeElections'] = parts[0].xstreamB('/EmployeeElectionImport/ElectionImport/EmployeeElection/Employee');</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Prepare_PayEntryImportOffCycle_Output" routes-to="Call_GenerateOutput_PayEntryImporOffCycle" execute-steps-when="false">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="localPayEntryImportOffCycleRecords"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['localIsOutputPayEntryInputOffCycle'] = parts[0].xstreamB('/PayEntryImport/PayData');</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Prepare_PayEntryImport_Output" routes-to="Call_GenerateOutput_PayEntryImport" execute-steps-when="false">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="localPayEntryImportRecords"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['localIsOutputPayEntryInput'] = parts[0].xstreamB('/PayEntryImport/PayData');</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="AggregateResults" routes-to="AggregatePeriodData">
        	<cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
        	<cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
        </cc:local-in>
        <cc:aggregator id="AggregatePeriodData" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-variable="globalTransformData">
        <cc:header-text>&lt;Results></cc:header-text>
        <cc:footer-text>&lt;/Results></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-in id="AggregateAllData" routes-to="PrepareMapData_PayGroupSchedules">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="PreparePeriodData" routes-to="Call_AggregateResults_Period">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="globalPeriodSchedules"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareWorkerData" routes-to="Call_AggregateResults_Worker">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="globalWorkerData"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PreparePeciData" routes-to="Call_AggregateResults_Peci">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="globalInputData"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_AggregateResults_Period" store-message="none" routes-response-to="PrepareWorkerData" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/AggregateResults"><cc:set name="inCollate" value="true"/><cc:set name="inBatch" value="false"/></cc:local-out>
        <cc:local-out id="Call_AggregateResults_Worker" store-message="none" routes-response-to="PreparePeciData" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/AggregateResults"><cc:set name="inCollate" value="true"/><cc:set name="inBatch" value="false"/></cc:local-out>
        <cc:local-out id="Call_AggregateResults_Peci" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/AggregateResults"><cc:set name="inCollate" value="true"/><cc:set name="inBatch" value="true"/></cc:local-out>
        <cc:local-out id="Call_AggregateAllData" store-message="none" routes-response-to="Call_IEP_45" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/AggregateAllData"><cc:set name="inCollate" value="true"/><cc:set name="inBatch" value="false"/></cc:local-out>
        <cc:local-in id="GetIntegrationSystem" routes-to="PrepareSoap"/>
        <cc:local-out id="Call_GetIntegrationSystem" store-message="none" routes-response-to="Call_IEP_20" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/GetIntegrationSystem"/>
        <cc:async-mediation id="PrepareSoap" routes-to="CallSoap_GetIntegrationSystems">
            <cc:steps>
                <cc:write id="GetIntegrationSystemsRequest">
                    <cc:message>
                        <cc:text>&lt;soapenv:Envelope xmlns:bsvc="urn:com.workday/bsvc" xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">&#xd;
   &lt;soapenv:Header>&#xd;
      &lt;bsvc:Workday_Common_Header>&#xd;
         &lt;bsvc:Include_Reference_Descriptors_In_Response>1&lt;/bsvc:Include_Reference_Descriptors_In_Response>&#xd;
      &lt;/bsvc:Workday_Common_Header>&#xd;
   &lt;/soapenv:Header>&#xd;
   &lt;soapenv:Body>&#xd;
      &lt;bsvc:Get_Integration_Systems_Request bsvc:version="@{props['globalApiVersion']}">&#xd;
         &lt;bsvc:Request_References>&#xd;
            &lt;bsvc:Integration_System_Reference>&#xd;
               &lt;bsvc:ID bsvc:type="WID">@{lp.integrationSystemRefWID}&lt;/bsvc:ID>&#xd;
            &lt;/bsvc:Integration_System_Reference>&#xd;
         &lt;/bsvc:Request_References>&#xd;
         &lt;bsvc:Response_Group>&#xd;
            &lt;bsvc:Include_Reference>1&lt;/bsvc:Include_Reference>&#xd;
            &lt;bsvc:Show_Values_For_All_Environments>1&lt;/bsvc:Show_Values_For_All_Environments>&#xd;
         &lt;/bsvc:Response_Group>&#xd;
      &lt;/bsvc:Get_Integration_Systems_Request>&#xd;
   &lt;/soapenv:Body>&#xd;
&lt;/soapenv:Envelope></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="CallSoap_GetIntegrationSystems" store-message="none" routes-response-to="ExtractMapsForXslt" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/CallSoap"><cc:set name="inApiVersion" value="props['globalApiVersion']"/><cc:set name="inWebServiceApplication" value="'Integrations'"/><cc:set name="inUseMessageRootPartAsRequest" value="true"/><cc:set name="inReturnResults" value="'message'"/><cc:set name="inValidateOnly" value="props['globalIsValidationMode']"/><cc:set name="inDebugMode" value="props['globalIsDebugMode']"/><cc:set name="inIsAbortOnError" value="true"/></cc:local-out>
        <cc:async-mediation id="ExtractMapsForXslt">
            <cc:steps>
                <cc:copy id="GetPayGroupScheduleMap" output="variable" output-mimetype="text/xml" output-variable="globalPayGroupScheduleMap" input-xpath="/env:Envelope/env:Body/wd:Get_Integration_Systems_Response/wd:Response_Data/wd:Integration_System/wd:Integration_System_Data/wd:Integration_Maps_Data/wd:Integration_Map_Data[wd:Integration_Map_Name eq 'Pay Groups to Period Schedules']" namespaces=" wd urn:com.workday/bsvc"/>
                <cc:copy id="GetEarningsExpansionMap" output="variable" output-mimetype="text/xml" output-variable="globalEarningExpansionMap" input-xpath="/env:Envelope/env:Body/wd:Get_Integration_Systems_Response/wd:Response_Data/wd:Integration_System/wd:Integration_System_Data/wd:Integration_Maps_Data/wd:Integration_Map_Data[wd:Integration_Map_Name eq 'Earning Expansion Codes']" namespaces=" wd urn:com.workday/bsvc"/>
                <cc:copy id="GetExpressionCodeMap" output="variable" output-mimetype="text/xml" output-variable="globalExpressionCodeMap" input-xpath="/env:Envelope/env:Body/wd:Get_Integration_Systems_Response/wd:Response_Data/wd:Integration_System/wd:Integration_System_Data/wd:Integration_Maps_Data/wd:Integration_Map_Data[wd:Integration_Map_Name eq 'Expression Code Types']" namespaces=" wd urn:com.workday/bsvc"/>
                <cc:copy id="GetHsaCodeMap" output="variable" output-mimetype="text/xml" output-variable="globalHsaCodeMap" input-xpath="/env:Envelope/env:Body/wd:Get_Integration_Systems_Response/wd:Response_Data/wd:Integration_System/wd:Integration_System_Data/wd:Integration_Maps_Data/wd:Integration_Map_Data[wd:Integration_Map_Name eq 'HSA Codes']" namespaces=" wd urn:com.workday/bsvc"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareMapData_PayGroupSchedules" routes-to="Call_AggregateResults_ScheduleMap">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output="message" output-mimetype="text/xml" input="variable" input-variable="globalPayGroupScheduleMap"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareMapData_ExpansionCodes" routes-to="Call_AggregateResults_ExpansionMap">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output="message" output-mimetype="text/xml" input="variable" input-variable="globalEarningExpansionMap"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareMapData_ExpressionCodes" routes-to="Call_AggregateResults_ExpressionMap">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output="message" output-mimetype="text/xml" input="variable" input-variable="globalExpressionCodeMap"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareMapData_HsaCodes" routes-to="Call_AggregateResults_HsaCodeMap">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output="message" output-mimetype="text/xml" input="variable" input-variable="globalHsaCodeMap"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_AggregateResults_HsaCodeMap" store-message="none" routes-response-to="PreparePeriodData" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/AggregateResults">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_AggregateResults_ExpressionMap" store-message="none" routes-response-to="PrepareMapData_HsaCodes" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/AggregateResults">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_AggregateResults_ExpansionMap" store-message="none" routes-response-to="PrepareMapData_ExpressionCodes" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/AggregateResults">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_AggregateResults_ScheduleMap" store-message="none" routes-response-to="PrepareMapData_ExpansionCodes" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/AggregateResults">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_ConvertDataFromPeciToDayforce" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/HandleError">
            <cc:set name="inLogMessage" value="'PECI/Dayforce Transformation Error'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIncludeDebugOutput" value="props['globalIsDebugMode']"/>
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'globalTransformData'"/>
        <cc:set name="inFinallyEndpoint" value="'vm://INT200_Ceridian_Dayforce_PostProcessor/TransformData_Finally'"/></cc:local-out>
        <cc:sync-mediation id="ConvertDataFromPeciToDayforce" routes-to="Call_CloudLogETVXTTMessages_ConvertData" handle-downstream-errors="true" routes-response-to="Call_TransformData_Finally">
            <cc:request-steps>
                <cc:xslt-plus id="Transform" output="message" output-mimetype="text/xml" input="variable" input-variable="globalTransformData" url="xslt/TransformPeciToCeridian.xsl"/>
                <cc:etv id="ApplyReformatting" output="variable" output-mimetype="text/xml" output-variable="localCeridianRecords" input="message" append-messages="false" message-property="etvMessages"/></cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ConvertDataFromPeciToDayforce"/>
        </cc:sync-mediation>
        <cc:local-in id="TransformData_Finally" routes-to="PostTransformationCleanup"/>
        <cc:async-mediation id="PostTransformationCleanup">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (varname : ['globalTransformData','localCeridianRecords']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_TransformData_Finally" store-message="none" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/TransformData_Finally"/>
        <cc:local-out id="Call_IEP_70" store-message="none" routes-response-to="Call_GenerateFiles" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/IntegrationEventProgress"><cc:set name="inProgressPercentage" value="'70'"/><cc:set name="inProgressMessage" value="'Completed Data Transformation from PECI to Dayforce.  Beginning file generation...'"/></cc:local-out>
        <cc:local-out id="Call_IEP_45" store-message="none" routes-response-to="Call_TransformData" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/IntegrationEventProgress">
            <cc:set name="inProgressPercentage" value="'45'"/>
            <cc:set name="inProgressMessage" value="'Completed Data PECI and Workday Data Aggregation.  Beginning PECI to Dayforce Data Transformation...'"/>
        </cc:local-out>
        <cc:local-out id="Call_IEP_40" store-message="none" routes-response-to="Call_AggregateAllData" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/IntegrationEventProgress">
            <cc:set name="inProgressPercentage" value="'40'"/>
            <cc:set name="inProgressMessage" value="'Completed Worker Supplemental Data Retrieval.  Beginning PECI and Workday Data Aggregation...'"/>
        </cc:local-out>
        <cc:local-out id="Call_IEP_30" store-message="none" routes-response-to="Call_RetrieveWorkerData" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/IntegrationEventProgress">
            <cc:set name="inProgressPercentage" value="'30'"/>
            <cc:set name="inProgressMessage" value="'Completed Pay Period Schedule Retrieval.  Beginning Worker Supplemental Data Retrieval...'"/>
        </cc:local-out>
        <cc:local-out id="Call_IEP_20" store-message="none" routes-response-to="Call_RetrievePeriodSchedules" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/IntegrationEventProgress">
            <cc:set name="inProgressPercentage" value="'20'"/>
            <cc:set name="inProgressMessage" value="'Completed Integration System Map Retrieval.  Beginning Pay Period Schedule Retrieval...'"/>
        </cc:local-out>
        <cc:local-out id="Call_IEP_15" store-message="none" routes-response-to="Call_GetIntegrationSystem" endpoint="vm://INT200_Ceridian_Dayforce_PostProcessor/IntegrationEventProgress">
            <cc:set name="inProgressPercentage" value="'15'"/>
            <cc:set name="inProgressMessage" value="'Completed PECI Data Retrieval.  Beginning Integration System Map Retrieval...'"/>
        </cc:local-out>
	</cc:assembly>

</beans><SubAssemblies>
	
	<SubAssembly>SetupLog</SubAssembly>
	
	<SubAssembly>CreateLogEntry</SubAssembly>
	
	<SubAssembly>Debug</SubAssembly>
	
	<SubAssembly>HandleError</SubAssembly>
	
	<SubAssembly>LogStats</SubAssembly>
	
	<SubAssembly>StaticCodeAnalysis</SubAssembly>
	
	<SubAssembly>StoreLog</SubAssembly>
	
	<SubAssembly>IntegrationEventProgress</SubAssembly>
	
	<SubAssembly>InitializeFrameworkThenRunMain</SubAssembly>
	
	<SubAssembly>CloudLogXSLTMessages</SubAssembly>
	
	<SubAssembly>CloudLogETVXTTMessages</SubAssembly>
	
</SubAssemblies></Root>
