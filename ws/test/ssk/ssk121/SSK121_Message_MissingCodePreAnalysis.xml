<?xml version='1.0' encoding='utf-8'?>
<Root>
    <beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:cc="http://www.capeclear.com/assembly/10"
        xmlns:cloud="urn:com.workday/esb/cloud/10.0"
        xmlns:beans="http://www.springframework.org/schema/beans"
        xmlns:pi="urn:com.workday/picof"
        xmlns:atom="http://www.w3.org/2005/Atom"
        xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"
        xmlns:wd="urn:com.workday/bsvc"
        xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <cc:assembly id="WorkdayAssembly" version="2019.35">
            <cc:local-out
                endpoint="vm://wcc/PutIntegrationMessage"
                execute-when="props['globalLogCountDebug'] > 0"
                id="PIM_Debug_Stats_109"
                propagate-abort="false">
                <cc:set name="is.message.severity" value="'DEBUG'"/>
                <cc:set
                    name="is.message.summary"
                    value="props['globalLogCountDebug'] + ' debug message(s) added!  See attached file for details.'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://wcc/PutIntegrationMessage"
                execute-when="props['globalLogCountInfo'] > 0"
                id="PIM_Info_Stats_109"
                propagate-abort="false"
                routes-response-to="PIM_Debug_Stats_109">
                <cc:set name="is.message.severity" value="'INFO'"/>
                <cc:set
                    name="is.message.summary"
                    value="props['globalLogCountInfo'] + ' informational message(s) added!  See attached file for details.'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://wcc/PutIntegrationMessage"
                execute-when="props['globalLogCountWarn'] > 0"
                id="PIM_Warning_Stats_109"
                propagate-abort="false"
                routes-response-to="PIM_Info_Stats_109">
                <cc:set name="is.message.severity" value="'WARNING'"/>
                <cc:set
                    name="is.message.summary"
                    value="props['globalLogCountWarn'] + ' warning(s) encountered!  See attached file for details.'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://wcc/PutIntegrationMessage"
                execute-when="props['globalLogCountError'] > 0"
                id="PIM_Error_Stats_109"
                propagate-abort="false"
                routes-response-to="PIM_Warning_Stats_109">
                <cc:set name="is.message.severity" value="'ERROR'"/>
                <cc:set
                    name="is.message.summary"
                    value="props['globalLogCountError'] + ' error(s) encountered!  See attached file for details.'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://wcc/PutIntegrationMessage"
                execute-when="props['globalLogCountCritical'] > 0"
                id="PIM_Critical_Stats_109"
                propagate-abort="false"
                routes-response-to="PIM_Error_Stats_109">
                <cc:set name="is.message.severity" value="'CRITICAL'"/>
                <cc:set
                    name="is.message.summary"
                    value="props['globalLogCountCritical'] + ' critical error(s) encountered!  See attached file for details.'"/>
            </cc:local-out>
            <cc:local-in access="private" id="LogStats" routes-to="PIM_Critical_Stats_109"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/LogStats"
                execute-when="props['inLogFinalize']"
                id="Call_LogStats_109"/>
            <cc:async-mediation
                execute-steps-when="vars['cloud-log-content'] != null &amp;&amp; props['globalLogCountByLogFile'] > 0 &amp;&amp; props['globalLogCountTotal'] > 0 &amp;&amp;&#xd;&#xa;(&#xd;&#xa;&#x9;(props['inLogFinalize'] == true) ||&#xd;&#xa;&#x9;(props['globalLogMaxCountPerFile'] > 0 &amp;&amp; props['globalLogCountByLogFile'] == props['globalLogMaxCountPerFile'])&#xd;&#xa;)"
                id="OutputCloudLog_109"
                routes-to="Call_LogStats_109">
                <cc:steps>
                    <cc:eval id="Setup">
                        <cc:expression>props['globalLogFilesStored'] = props['globalLogFilesStored'] + 1</cc:expression>
                        <cc:expression>props['localLogFilenameForStorage'] = (props['globalLogMaxCountPerFile'] == 0) ? props['globalLogFilename'] # ".html" : props['globalLogFilename'] # "_" # props['globalLogFilesStored'] # ".html"</cc:expression>
                    </cc:eval>
                    <cc:store
                        createDocumentReference="true"
                        expiresIn="@{props['globalLogExpires']}"
                        id="StoreCloudLog"
                        input="variable"
                        input-variable="cloud-log-content"
                        title="@{props['localLogFilenameForStorage']}"/>
                    <cc:eval id="Reset">
                        <cc:expression>vars['cloud-log-content'] = null</cc:expression>
                        <cc:expression>props['globalLogCountByLogFile'] = 0</cc:expression>
                        <cc:expression>foreach (propname : ['localLogFilenameForStorage']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in access="public" id="StoreLog" routes-to="OutputCloudLog_109">
                <cc:parameter
                    default="false"
                    name="inLogFinalize"
                    required="true"
                    type="boolean"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLog"
                id="Call_StoreLog_109">
                <cc:set name="inLogFinalize" value="false"/>
            </cc:local-out>
            <cc:async-mediation id="WriteLog_109" routes-to="Call_StoreLog_109">
                <cc:steps>
                    <cc:eval id="UpdateLogCounts">
                        <cc:expression>(props['inLogLevel'] == 'debug') ? props['globalLogCountDebug'] = props['globalLogCountDebug'] + 1;</cc:expression>
                        <cc:expression>(props['inLogLevel'] == 'info') ? props['globalLogCountInfo'] = props['globalLogCountInfo'] + 1;</cc:expression>
                        <cc:expression>(props['inLogLevel'] == 'warn') ? props['globalLogCountWarn'] = props['globalLogCountWarn'] + 1;</cc:expression>
                        <cc:expression>(props['inLogLevel'] == 'error') ? props['globalLogCountError'] = props['globalLogCountError'] + 1;</cc:expression>
                        <cc:expression>(props['inLogLevel'] == 'critical') ? props['globalLogCountCritical'] = props['globalLogCountCritical'] + 1;</cc:expression>
                        <cc:expression>props['globalLogCountTotal'] = props['globalLogCountTotal'] + 1;</cc:expression>
                        <cc:expression>props['globalLogCountByLogFile'] = props['globalLogCountByLogFile'] + 1;</cc:expression>
                    </cc:eval>
                    <cc:cloud-log
                        id="LogMessage"
                        level="props['inLogLevel']"
                        message="@{props['inLogMessage']}"
                        message-details="@{props['inLogMessageDetail']}"
                        output-file-type="HTML"
                        reference-id="props['inLogReferenceId']">
                        <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                        <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                        <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                        <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                    </cc:cloud-log>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in
                access="public"
                icon="icons/CreateLogEntry.png"
                id="CreateLogEntry"
                routes-to="WriteLog_109">
                <cc:parameter
                    documentation="Value that will be written to the Message attribute of the Cloud Logger."
                    name="inLogMessage"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="Value that will be written to the Message Details attribute of the Cloud Logger."
                    name="inLogMessageDetail"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="Value that will be written to the Reference Id attribute of the Cloud Logger.  This is most commonly used to record the WID of the record to which this message pertains and can save the MVEL code of concatenating it into the Message Detail."
                    name="inLogReferenceId"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="Value that determines the Level attribute of the Cloud Logger.  Must be one of: debug, info, warn, error, critical."
                    name="inLogLevel"
                    required="true"
                    type="string"
                    validation="['debug','info','warn','error','critical'] contains props['inLogLevel'].trim().toLowerCase()"/>
                <cc:parameter
                    documentation="Value written to the LocalIn Extra Column on the log.  This field is a convention of SSK and used to record the name of a Mediation related to the message, e.g. the errorComponentId causing an error to be raised."
                    name="inExtraLocalIn"
                    required="false"/>
                <cc:parameter
                    documentation="Value written to the RecordNumber Extra Column on the log.  This field is a convention of SSK and used to record the position/count of a data record in a set to which this message pertains."
                    name="inExtraRecordNumber"
                    required="false"/>
                <cc:parameter
                    documentation="Value written to the SupportData Extra Column on the log.  This field is a convention of SSK and used to provide open-ended advice for support.  This may constitute additional data values, or it may mean remediation advice for a particular error."
                    name="inExtraSupportData"
                    required="false"/>
                <cc:parameter
                    documentation="Value written to the ErrorCode Extra Column on the log.  This field is a convention of SSK and used to provide the value of the error code when the message is logging error information.  This code may be given by the ESB, or it may be a custom code defined by the developer.  Note that this field is a String whereas Studio/ESB codes are integers, so type conversion is required."
                    name="inExtraErrorCode"
                    required="false"/>
            </cc:local-in>
            <cc:local-out
                clone-request="true"
                endpoint="vm://wcc/PutIntegrationMessage"
                id="PIM_Info_Finish_109">
                <cc:set name="is.message.severity" value="'INFO'"/>
                <cc:set
                    name="is.message.summary"
                    value="'Initialization of logging component finished.'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://wcc/PutIntegrationMessage"
                id="PIM_Critical_SetupFailure_109"
                propagate-abort="false"
                routes-response-to="InitializeLog_Handler_109">
                <cc:set name="is.message.severity" value="'CRITICAL'"/>
                <cc:set
                    name="is.message.summary"
                    value="'Initialization of logging component failed.  Immediate halt to integration processing.'"/>
                <cc:set name="is.message.storage.enabled" value="false"/>
            </cc:local-out>
            <cc:async-mediation id="InitializeLog_Handler_109">
                <cc:steps>
                    <cc:eval id="Abort">
                        <cc:expression>context.setAbort(true);</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation id="InitializeLog_109" routes-to="PIM_Info_Finish_109">
                <cc:steps>
                    <cc:eval id="SetupLog">
                        <cc:expression>props['globalLogFilename'] = intsys.getAttribute('Log File Name (Exclude File Extension)') == empty ? 'Log' : intsys.getAttribute('Log File Name (Exclude File Extension)')</cc:expression>
                        <cc:expression>props['globalLogExpires'] = intsys.getAttribute('Log Retention in Days') == empty ?  'P30D' : 'P' + intsys.getAttribute('Log Retention in Days') + 'D'</cc:expression>
                        <cc:expression>props['globalLogMaxCountPerFile'] = intsys.getAttribute('Max Entries per Log File') == empty ? 0 : intsys.getAttribute('Max Entries per Log File')</cc:expression>
                        <cc:expression>props['globalLogCountByLogFile'] = 0</cc:expression>
                        <cc:expression>props['globalLogCountDebug'] = 0</cc:expression>
                        <cc:expression>props['globalLogCountInfo'] = 0</cc:expression>
                        <cc:expression>props['globalLogCountWarn'] = 0</cc:expression>
                        <cc:expression>props['globalLogCountError'] = 0</cc:expression>
                        <cc:expression>props['globalLogCountCritical'] = 0</cc:expression>
                        <cc:expression>props['globalLogCountTotal'] = 0</cc:expression>
                        <cc:expression>props['globalLogFilesStored'] = 0</cc:expression>
                    </cc:eval>
                </cc:steps>
                <cc:send-error id="SendError" routes-to="PIM_Critical_SetupFailure_109"/>
            </cc:async-mediation>
            <cc:local-out
                clone-request="true"
                endpoint="vm://wcc/PutIntegrationMessage"
                id="PIM_Info_Start_109"
                propagate-abort="false"
                routes-response-to="InitializeLog_109">
                <cc:set name="is.message.severity" value="'INFO'"/>
                <cc:set
                    name="is.message.summary"
                    value="'Initialization of logging component started.'"/>
            </cc:local-out>
            <cc:local-in access="public" id="SetupLog" routes-to="PIM_Info_Start_109"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLog"
                id="Call_StoreLog_GEH"
                propagate-abort="false"
                routes-response-to="Call_Debug_Finalize_GEH">
                <cc:set name="inLogFinalize" value="true"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://wcc/PutIntegrationMessage"
                id="PIM_CriticalUnhandledException_GEH"
                propagate-abort="false"
                routes-response-to="Call_StoreLog_GEH">
                <cc:set name="is.message.severity" value="'CRITICAL'"/>
                <cc:set name="is.message.summary" value="'An unhandled error was encountered!'"/>
                <cc:set
                    name="is.message.detail"
                    value="'Error Message: ' + context.getErrorMessage()"/>
            </cc:local-out>
            <cc:send-error
                id="GlobalErrorHandler"
                routes-to="PIM_CriticalUnhandledException_GEH"/>
            <cc:async-mediation id="InitializeCoreStarterKit_109">
                <cc:steps>
                    <cc:eval id="IntSystem">
                        <cc:expression>props['globalDocumentRetentionPeriod'] = 'P' # ((intsys.getAttribute('Document Retention in Days') == null) ? '30' : intsys.getAttribute('Document Retention in Days')) # 'D';</cc:expression>
                    </cc:eval>
                    <cc:eval id="LaunchParameters">
                        <cc:expression>props['globalIsValidationMode'] = (lp.exists('Run in Validation Mode') ? (Boolean) lp.getSimpleData('Run in Validation Mode') : false);&#xd;
props['globalIsDebugMode'] = (lp.exists('Run with Debug Logging') ? (Boolean) lp.getSimpleData('Run with Debug Logging') : false);</cc:expression>
                    </cc:eval>
                    <cc:eval id="Debug">
                        <cc:expression>props['globalDebugPropertyList'] = new java.util.ArrayList();</cc:expression>
                        <cc:expression>props['globalDebugPropertyList'].add('globalDocumentRetentionPeriod');&#xd;
props['globalDebugPropertyList'].add('globalIsValidationMode');&#xd;
props['globalDebugPropertyList'].add('globalIsDebugMode');</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLog"
                id="Call_StoreLog"
                routes-response-to="Call_Debug_Finalize"
                store-message="none">
                <cc:set name="inLogFinalize" value="true"/>
            </cc:local-out>
            <cc:local-out
                endpoint="@{props['inMainEndpoint']}"
                id="Call_Main"
                propagate-abort="false"
                store-message="none"/>
            <cc:local-out
                endpoint="@{props['inInitializationEndpoint'] == empty ? 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/SetupGlobal' : props['inInitializationEndpoint']}"
                id="Call_SetupGlobal"
                routes-response-to="Call_IEP_10"
                store-message="none"
                unset-properties="false"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/SetupLog"
                id="Call_SetupLog"
                propagate-abort="true"
                routes-response-to="Call_SetupGlobal"
                store-message="none"/>
            <cc:async-mediation id="Initialize_Handler">
                <cc:steps>
                    <cc:eval id="Abort">
                        <cc:expression>context.setAbort(true);</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Initialize_Error"
                routes-response-to="Call_StoreLog_Initialize"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="'An error occurred within the integration flow and has been caught at the top-level just before the Global Error Handler.'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set name="inLogReferenceId"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="'InitializeCloudCollectionReference'"/>
                <cc:set name="inExtraSupportData"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            </cc:local-out>
            <cc:async-mediation
                continue-after-error="rewind"
                handle-downstream-errors="true"
                id="Initialize"
                routes-to="Call_SetupLog">
                <cc:steps>
                    <cc:eval id="SetConstantValues">
                        <cc:expression>props['globalStudioStarterKitVersion'] = 'v1.03'; //This property is set for reference purposes only.  </cc:expression>
                        <cc:expression>props['globalApiVersion'] = 'v35.0';&#xd;
props['globalDebugArchiveFilename'] = 'DebugFiles_INT.zip';</cc:expression>
                        <cc:expression>props['globalStringDeduplicator'] = new com.workday.custom.int0025.int0025109.StringDeduplicator();</cc:expression>
                        <cc:expression>props['globalDebugTargetTypeParameterValidation'] = new java.util.HashSet();&#xd;
props['globalDebugTargetTypeParameterValidation'].add('message');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('property');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('properties');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('variable');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('map');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('list');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('set');&#xd;
props['globalDebugTargetTypeParameterValidation'].add('finalize');</cc:expression>
                        <cc:expression>props['globalDebugTargetNameParameterValidation'] = new java.util.HashSet();&#xd;
props['globalDebugTargetNameParameterValidation'].add('message');&#xd;
props['globalDebugTargetNameParameterValidation'].add('property');&#xd;
props['globalDebugTargetNameParameterValidation'].add('properties');&#xd;
props['globalDebugTargetNameParameterValidation'].add('variable');&#xd;
props['globalDebugTargetNameParameterValidation'].add('map');&#xd;
props['globalDebugTargetNameParameterValidation'].add('list');&#xd;
props['globalDebugTargetNameParameterValidation'].add('set');</cc:expression>
                    </cc:eval>
                    <cc:eval id="StaticCodeAnalysis">
                        <cc:expression>props['globalStaticCodeAnalysisExemptionList'] = new java.util.ArrayList();</cc:expression>
                        <cc:expression>props['globalStaticCodeAnalysisExemptionList'].add('Main');</cc:expression>
                    </cc:eval>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Call_CreateLogEntry_Initialize_Error"/>
            </cc:async-mediation>
            <cc:workday-in id="StartHere" routes-to="Call_InitializeFrameworkThenRunMain">
                <cc:integration-system name="INT0025 CheckWorkRights VisaCheck Inbound">
                    <cloud:param name="Run in Validation Mode">
                        <cloud:type>
                            <cloud:simple-type>boolean</cloud:simple-type>
                        </cloud:type>
                        <cloud:default>
                            <cloud:boolean>false</cloud:boolean>
                        </cloud:default>
                    </cloud:param>
                    <cloud:param name="Run with Debug Logging">
                        <cloud:type>
                            <cloud:simple-type>boolean</cloud:simple-type>
                        </cloud:type>
                        <cloud:default>
                            <cloud:boolean>false</cloud:boolean>
                        </cloud:default>
                    </cloud:param>
                    <cloud:attribute-map-service
                        name="INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - General">
                        <cloud:attribute name="Document Retention in Days">
                            <cloud:type>
                                <cloud:simple-type>number</cloud:simple-type>
                            </cloud:type>
                        </cloud:attribute>
                    </cloud:attribute-map-service>
                    <cloud:attribute-map-service
                        name="INT0025 CheckWorkRights VisaCheck Inbound Attribute Map Service - Logging">
                        <cloud:attribute name="Log File Name (Exclude File Extension)">
                            <cloud:type>
                                <cloud:simple-type>text</cloud:simple-type>
                            </cloud:type>
                        </cloud:attribute>
                        <cloud:attribute name="Log Retention in Days">
                            <cloud:type>
                                <cloud:simple-type>number</cloud:simple-type>
                            </cloud:type>
                        </cloud:attribute>
                        <cloud:attribute name="Max Entries per Log File">
                            <cloud:type>
                                <cloud:simple-type>number</cloud:simple-type>
                            </cloud:type>
                        </cloud:attribute>
                    </cloud:attribute-map-service>
                    <cloud:attribute-map-service
                        name="INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - Functional">
                        <cloud:attribute name="Retrieval Document Tag">
                            <cloud:type>
                                <cloud:simple-type>text</cloud:simple-type>
                            </cloud:type>
                        </cloud:attribute>
                        <cloud:attribute name="Output File Name (Exclude File Extension)">
                            <cloud:type>
                                <cloud:simple-type>text</cloud:simple-type>
                            </cloud:type>
                        </cloud:attribute>
                        <cloud:attribute name="Delivery Document Tag">
                            <cloud:type>
                                <cloud:simple-type>text</cloud:simple-type>
                            </cloud:type>
                        </cloud:attribute>
                    </cloud:attribute-map-service>
                    <cloud:report-service name="INT0025 CheckWorkRights VisaCheck Inbound - Report Service">
                        <cloud:report-alias description="CR INT Worker Data" name="Worker Data"/>
                    </cloud:report-service>
                </cc:integration-system>
            </cc:workday-in>
            <cc:async-mediation id="InitializeAttributesAndLaunchParameters">
                <cc:steps>
                    <cc:eval id="Attributes">
                        <cc:expression>//For Inbound&#xd;
props['globalRetrievalDocTag'] = ((intsys.getAttribute('Retrieval Document Tag') == null) ? 'Retrieved' : intsys.getAttribute('Retrieval Document Tag'));</cc:expression>
                        <cc:expression>//For Outbound&#xd;
props['globalOutputFilename'] = ((intsys.getAttribute('Output File Name (Exclude File Extension)') == null) ? 'INT_Results' : intsys.getAttribute('Output File Name (Exclude File Extension)'));&#xd;
props['globalDeliveryDocTag'] = ((intsys.getAttribute('Delivery Document Tag') == null) ? null : intsys.getAttribute('Delivery Document Tag'));</cc:expression>
                    </cc:eval>
                    <cc:eval id="UpdateDebug">
                        <cc:expression>props['globalDebugPropertyList'].add('globalApiVersion');</cc:expression>
                        <cc:expression>props['globalDebugPropertyList'].add('globalRetrievalDocTag');</cc:expression>
                        <cc:expression>props['globalDebugPropertyList'].add('globalOutputFilename');&#xd;
props['globalDebugPropertyList'].add('globalDeliveryDocTag');</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation
                id="Results_Handler_103"
                routes-to="Call_HandleError_Results_Error_103">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Results_Error_103"
                store-message="none">
                <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while copying the SOAP results from the message rootpart to variable globalSoapResults.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'property'"/>
                <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
                <cc:set
                    name="inEntityName"
                    value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            </cc:local-out>
            <cc:async-mediation
                execute-steps-when="props['inReturnResults'] == 'variable'"
                id="Results_103">
                <cc:steps>
                    <cc:copy
                        id="CopyMsgToVar"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="globalSoapResults"/>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Results_Handler_103"/>
            </cc:async-mediation>
            <cc:async-mediation
                id="RouteError_Http_Handler_103"
                routes-to="Call_HandleError_HttpError_Error_103">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'http';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_HttpError_Error_103"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="props['inWebServiceApplication'] #' application HTTP request error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while executing a SOAP request for the '# props['inWebServiceApplication'] #' application.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? context.errorCode : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Request__' # props['inWebServiceApplication']"/>
            </cc:local-out>
            <cc:async-mediation
                continue-after-error="rewind"
                handle-downstream-errors="true"
                id="CallSoap_Catch_103"
                routes-to="CallSoap_103">
                <cc:steps/>
                <cc:send-error id="CatchError" routes-to="RouteError_103"/>
            </cc:async-mediation>
            <cc:workday-out-soap
                application="@{props['inWebServiceApplication']}"
                id="CallSoap_103"
                routes-response-to="Call_Debug_SoapResponse_103"
                version="@{props['inApiVersion']}"/>
            <cc:async-mediation
                id="Transform_Handler_103"
                routes-to="Call_HandleError_Transform_Error_103">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Transform_Error_103"
                store-message="none">
                <cc:set name="inLogMessage" value="'SOAP Preparation Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while preparing a SOAP service call.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'property'"/>
                <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
                <cc:set
                    name="inEntityName"
                    value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            </cc:local-out>
            <cc:async-mediation id="Transform_103" routes-to="Call_Debug_SoapXslt_103">
                <cc:steps>
                    <cc:xslt-plus id="WriteSoap" url="@{props['inPathToXsltFile']}"/>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Transform_Handler_103"/>
            </cc:async-mediation>
            <cc:async-mediation
                execute-steps-when="props['localIsNonEmptyMapVariable']"
                id="PrepareVariableInput_103"
                routes-to="Transform_103">
                <cc:steps>
                    <cc:eval id="PrimeMessage">
                        <cc:expression>varname = props['inMapVariableName'];&#xd;
parts[0] = vars[varname];</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation
                execute-steps-when="(!props['localIsValuedProperty'] &amp;&amp; !props['localIsValuedVariable']) || props['localIsNonEmptyMapProperty']"
                id="PrepareMapInput_103"
                routes-to="PrepareVariableInput_103">
                <cc:steps>
                    <cc:write id="PrimeMessage">
                        <cc:message>
                            <cc:text>&lt;?xml version="1.0" encoding="UTF-8"?>&#xd;
&lt;Root/></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation
                id="Validation_Handler_103"
                routes-to="Call_HandleError_Validation_Error_103">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Validation_Error_103"
                store-message="none">
                <cc:set name="inLogMessage" value="'SOAP Preparation Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while validating the parameters for a SOAP service call.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:sync-mediation
                id="InitializeAndFinalize_103"
                routes-response-to="Call_Finally_103"
                routes-to="Call_BuildRequest_103">
                <cc:request-steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['outIsSoapError'] = '';</cc:expression>
                    </cc:eval>
                </cc:request-steps>
                <cc:response-steps/>
            </cc:sync-mediation>
            <cc:async-mediation id="Teardown_103">
                <cc:steps>
                    <cc:set-headers id="ClearHeaders">
                        <cc:remove-headers>
                            <cc:remove-header name="x-validate-only"/>
                        </cc:remove-headers>
                        <cc:add-headers/>
                    </cc:set-headers>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localIsValuedProperty','localIsDefinedProperty','localIsCorrectTypeProperty','localIsNonEmptyMapProperty','localIsValuedVariable','localIsDefinedVariable','localIsCorrectTypeVariable','localIsNonEmptyMapVariable']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_103" routes-to="Teardown_103"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103"
                id="Call_Finally_103"
                store-message="none"/>
            <cc:local-in
                access="public"
                icon="icons/CallSoap.png"
                id="CallSoap"
                routes-to="InitializeAndFinalize_103">
                <cc:parameter
                    default="props['globalApiVersion']"
                    documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;"
                    name="inApiVersion"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;."
                    name="inWebServiceApplication"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="true"
                    documentation="Sub-assembly supports pre-built, on-message requests as well as facilities to construct the request dynamically.  Set this parameter to true to bypass the dynamic request construction and use the message root part as the request.  If set to false, then the inPathToXsltFile and the inMapPropertyName or inMapVariableName parameters should be set."
                    name="inUseMessageRootPartAsRequest"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;."
                    name="inPathToXsltFile"
                    required="!props['inUseMessageRootPartAsRequest']"
                    type="string"/>
                <cc:parameter
                    documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request."
                    name="inMapPropertyName"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example."
                    name="inMapVariableName"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="'variable'"
                    documentation="How the SOAP results are returned to the caller, either on the message if the value is 'message', or in the 'globalSoapResults' variable if the value is 'variable', which is the default."
                    name="inReturnResults"
                    required="true"
                    type="string"
                    validation="props['inReturnResults'] == 'variable' || props['inReturnResults'] == 'message'"/>
                <cc:parameter
                    default="props['globalIsValidationMode']"
                    documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors."
                    name="inValidateOnly"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="props['globalIsDebugMode']"
                    documentation="Controls whether or not the SOAP request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
                <cc:out-parameter
                    documentation="A string to indicate that the request resulted in an error and identify the type.  If the error was at the API level, then outIsSoapError == 'http'.  If the error was at the tenant/application level, then outIsSoapError == 'soap'.  If there was an error unrelated to the API call, then outIsSoapError == 'logic'.  If there is no error, , then outIsSoapError == empty.  Further individual errors determined by Get_Event_Details or Get_Import_Processes are not handled here."
                    name="outIsSoapError"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Error_105"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="'Error generated during loading of Java Map'"/>
                <cc:set name="inLogMessageDetail" value="parts[0].xpath('/Error')"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_Error_105'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Warn_105"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="'Warning generated during loading of Java Map'"/>
                <cc:set name="inLogMessageDetail" value="parts[0].xpath('/Warning')"/>
                <cc:set name="inLogLevel" value="'warn'"/>
                <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_Warn_105'"/>
            </cc:local-out>
            <cc:route id="RouteMessages_105">
                <cc:xpath-strategy>
                    <cc:choose-route expression="exists( /Warning )" route="Warning"/>
                    <cc:choose-route expression="exists( /Error )" route="Error"/>
                </cc:xpath-strategy>
                <cc:sub-route name="Warning" routes-to="Call_CreateLogEntry_Warn_105"/>
                <cc:sub-route name="Error" routes-to="Call_CreateLogEntry_Error_105"/>
            </cc:route>
            <cc:splitter id="Splitter_105" no-split-message-error="false">
                <cc:sub-route name="RouteResult" routes-to="RouteMessages_105"/>
                <cc:xml-stream-splitter xpath="/*/*"/>
            </cc:splitter>
            <cc:sync-mediation id="LoadMap_105" routes-to="Splitter_105">
                <cc:request-steps>
                    <cc:xslt-plus id="LoadMap" url="mctx:vars/localPjmXslt"/>
                </cc:request-steps>
                <cc:response-steps/>
                <cc:send-error id="CatchError" routes-to="Call_HandleError_LoadMap_Error_105"/>
            </cc:sync-mediation>
            <cc:sync-mediation
                id="PrepareForLoadMap_105"
                routes-response-to="Call_Finally_105"
                routes-to="LoadMap_105">
                <cc:request-steps>
                    <cc:validate-exp id="ValidateParameters">
                        <cc:expression
                            error-number="10500"
                            failure-message="Property 'inMap' does not contain a Java Map">map = props['inMap'];
return (map == null ) ||
	(( map != null) &amp;&amp; (map instanceof java.util.Map));</cc:expression>
                    </cc:validate-exp>
                    <cc:eval id="SetValues">
                        <cc:expression>props['outMap'] = props['inMap'];</cc:expression>
                        <cc:expression>// If the map property is not current assigned then create a new HashMap in it
if (props['outMap'] == empty) {&#xd;
	props['outMap'] = new java.util.HashMap();&#xd;
}</cc:expression>
                        <cc:expression>props['localMapPropertyName'] = 'outMap'</cc:expression>
                    </cc:eval>
                    <cc:write id="LoadXslt" output="variable" output-variable="localPjmXslt">
                        <cc:message>
                            <cc:text>&lt;?xml version="1.0" encoding="UTF-8"?>&#xd;
&lt;xsl:stylesheet version="3.0" &#xd;
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&#xd;
    xmlns:tube="java:com.capeclear.mediation.impl.cc.MediationTube"&#xd;
    xmlns:ctx="java:com.capeclear.mediation.MediationContext"&#xd;
    xmlns:xs="http://www.w3.org/2001/XMLSchema"&#xd;
    xmlns:jmap="java:java.util.Map"&#xd;
    xmlns:jt="http://saxon.sf.net/java-type"&#xd;
    xmlns:this="urn:this">&#xd;
    &#xd;
    &lt;xsl:param name="inStoreDataAs" as="xs:string"/>&#xd;
    &lt;xsl:param name="inQueryToEntry" as="xs:string"/>&#xd;
    &lt;xsl:param name="inQueryToKey" as="xs:string"/>&#xd;
    &lt;xsl:param name="inQueryToValue" as="xs:string"/>&#xd;
    &lt;xsl:param name="localMapPropertyName" as="xs:string"/>&#xd;
    &lt;xsl:param name="inEmptyValueIsError" as="xs:boolean" select="true()"/>&#xd;
    &#xd;
    &lt;!-- This stylesheet is designed to be streamable so that only one record is held in memory at any one time -->&#xd;
    &lt;xsl:mode streamable="yes" on-no-match="shallow-skip"/>&#xd;
    &lt;xsl:mode streamable="no" name="in-memory"/>&#xd;
    &#xd;
    &lt;!-- Obtain the current MediationContext in use in the assembly -->&#xd;
    &lt;xsl:variable name="ctx" select="tube:getCurrentMediationContext()"/>&#xd;
    &#xd;
    &lt;!-- Retrieve the Java Map stored in the context property named HashMap -->&#xd;
    &lt;xsl:variable name="Map" select="ctx:getProperty($ctx, $localMapPropertyName)" as="jt:java.util.Map"/>&#xd;
    &#xd;
    &lt;!-- Based on the configuration of the StoreDataAs property determine the function which will be used to store the values in the map.  Using the function reference allows us to avoid the inefficiency of comparing the value of StoreDataAs for each entry -->&#xd;
    &lt;xsl:variable name="StoreDataInMap" select="if ( $inStoreDataAs = 'SimpleString') then this:StoreDataAsSimpleString#2 else if ($inStoreDataAs = 'DOM') then this:StoreDataAsDOM#2 else this:StoreDataAsXMLString#2" />&#xd;
    &#xd;
    &lt;xsl:template match="/">&#xd;
        &lt;MapHelper>&#xd;
            &lt;xsl:if test="$inStoreDataAs = 'XMLString'">&#xd;
                &lt;Warning>Map entries are configured to be stored as XMLStrings.  Using this will require that data is re-parsed every time the data is used.  This could impose a significant runtime performance overhead if each entry is, on average, accessed more than once&lt;/Warning>&#xd;
            &lt;/xsl:if>&#xd;
            &lt;xsl:if test="$inStoreDataAs = 'DOM'">&#xd;
                &lt;Warning>Map entries are configured to be stored as an XML DOM.  Using this option may require large amounts of memory.  Consider transforming the data before storage so as to only store the minimum required.  For very large documents consider moving to a custom Java solution with optimized data storage&lt;/Warning>&#xd;
            &lt;/xsl:if>&#xd;
            &#xd;
            &lt;!-- Now process the input file.  The EntryFilter variable can then be optionally used to only select those entries matching that value.  The filter can only navigate the descendant axis since only the node and and descendants returned by the QueryToEntry expression are brought into memory -->&#xd;
            &lt;xsl:apply-templates select="copy-of(@{props['inQueryToEntry']}@if{props['inEntryFilter'] != empty}[@{props['inEntryFilter']}]@end{})" mode="in-memory"/>    		&#xd;
        &lt;/MapHelper>&#xd;
    &lt;/xsl:template>&#xd;
    &#xd;
    &lt;!-- Process each entry -->&#xd;
    &lt;xsl:template match="*" mode="in-memory">&#xd;
        &lt;xsl:variable name="key"	select="@{props['inQueryToKey']}"/>&#xd;
        &lt;xsl:variable name="value"	select="@{props['inQueryToValue']}"/>&#xd;
        &#xd;
        &lt;xsl:choose>&#xd;
            &lt;!-- If we've no key then we have no option but to generate an error -->&#xd;
            &lt;xsl:when test="not(exists($key))">&#xd;
                &lt;Error>&#xd;
                    &lt;Message>&lt;xsl:text expand-text="yes">No key matching {$inQueryToKey} found in record&lt;/xsl:text>&lt;/Message>&#xd;
                    &lt;Record>&lt;xsl:copy-of select="."/>&lt;/Record>&#xd;
                &lt;/Error>&#xd;
            &lt;/xsl:when>&#xd;
            &#xd;
            &lt;!-- If we've no value and we're configured to treat no value as an error then output that error, otherwise we'll put the empty value into the map -->&#xd;
            &lt;xsl:when test="not(exists($value)) and $inEmptyValueIsError">&#xd;
                &lt;Error>&#xd;
                    &lt;Message>&lt;xsl:text expand-text="yes">No value matching {$inQueryToValue} found in record&lt;/xsl:text>&lt;/Message>&#xd;
                    &lt;Record>&lt;xsl:copy-of select="."/>&lt;/Record>&#xd;
                &lt;/Error>				&#xd;
            &lt;/xsl:when>&#xd;
            &#xd;
            &lt;!-- Store the value in the map -->&#xd;
            &lt;xsl:otherwise>&#xd;
                &lt;xsl:value-of select="$StoreDataInMap($key,$value)"/>&#xd;
            &lt;/xsl:otherwise>&#xd;
        &lt;/xsl:choose>&#xd;
    &lt;/xsl:template>&#xd;
    &#xd;
    &lt;xsl:function name="this:StoreDataAsSimpleString">&#xd;
        &lt;xsl:param name="key" as="xs:string"/>&#xd;
        &lt;xsl:param name="value" as="item()"/>&#xd;
        &lt;xsl:value-of select="jmap:put($Map, string($key), string($value))"/>&#xd;
    &lt;/xsl:function>&#xd;
    &#xd;
    &lt;xsl:function name="this:StoreDataAsXMLString">&#xd;
        &lt;xsl:param name="key" as="xs:string"/>&#xd;
        &lt;xsl:param name="value" as="item()"/>&#xd;
        &lt;xsl:value-of select="jmap:put($Map, string($key), serialize($value))"/>&#xd;
    &lt;/xsl:function>&#xd;
    &#xd;
    &lt;!-- &#xd;
    	This function is provided for future expansion.  There is no native way to export DOM information through Saxon Java extension functions such that the DOM (or NodeInfo) information can be processed&#xd;
    	elsewhere in the assembly since the Saxon Processor which was used to produce this information is not available to us outside of the XsltPlus step.&#xd;
    	&#xd;
    	In future, access to parsed DOM of the data will be provided through a Java extension function and a DOM implementation optimized for Workday-like data and map configurations.&#xd;
     -->&#xd;
    &lt;xsl:function name="this:StoreDataAsDOM" >&#xd;
        &lt;xsl:param name="key" as="xs:string"/>&#xd;
        &lt;xsl:param name="value" as="item()"/>&#xd;
		&lt;xsl:value-of select="jmap:put($Map, string($key), $value)"/>&#xd;
		&lt;xsl:message terminate="yes" select="'Storage of DOM values in the map are not yet implemented'"/>&#xd;
	&lt;/xsl:function>&#xd;
&lt;/xsl:stylesheet></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:request-steps>
                <cc:response-steps>
            </cc:response-steps>
            </cc:sync-mediation>
            <cc:local-in
                access="public"
                icon="icons/PopulateJavaMap.png"
                id="PopulateJavaMap"
                routes-to="PrepareForLoadMap_105">
                <cc:parameter
                    documentation="The Java Map which is to be populated with the current message"
                    name="inMap"
                    required="false"/>
                <cc:parameter
                    default="'SimpleString'"
                    documentation="Determines whether the map will be populated with simple string values, an in-memory DOM or an XML String"
                    name="inStoreDataAs"
                    required="false"
                    validation="['SimpleString','XMLString'].contains(props['inStoreDataAs'])"/>
                <cc:parameter
                    documentation="The XPath expression selecting the records which contain the information to be put into the Map"
                    name="inQueryToEntry"
                    required="true"
                    type="string"
                    validation="props['inQueryToEntry'].trim().length() > 0"/>
                <cc:parameter
                    documentation="XPath expression which can optionally be executed against the elements returned by QueryToEntry in order to determine if those entries should be stored in the map"
                    name="inEntryFilter"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="The XPath expression to select the Map key from each record.  This expression is executed against the element returned by the QueryToEntry expression"
                    name="inQueryToKey"
                    required="true"
                    type="string"
                    validation="props['inQueryToKey'].trim().length() > 0"/>
                <cc:parameter
                    documentation="The XPath expression which returns the value to be stored in the map when executed against the element returned by the QueryToEntry expression"
                    name="inQueryToValue"
                    required="true"
                    type="string"
                    validation="props['inQueryToValue'].trim().length() > 0"/>
                <cc:parameter
                    default="true"
                    documentation="Controls whether empty map values are to be treated as errors"
                    name="inEmptyValueIsError"
                    required="false"
                    type="boolean"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
                <cc:out-parameter
                    documentation="The Java Map which will have been populated with the data in the current message"
                    name="outMap"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Results_Error_102"
                store-message="none">
                <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while copying the RaaS results from the message rootpart to variable globalRaaSResults.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                execute-steps-when="props['inReturnResults'] == 'variable'"
                id="Results_102"
                routes-to="Call_Debug_Result_102">
                <cc:steps>
                    <cc:copy
                        id="CopyMsgToVar"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="globalRaaSResults"/>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_102"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_CallRaaS_Error_102"
                store-message="none">
                <cc:set name="inLogMessage" value="'RaaS Execution Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                continue-after-error="rewind"
                handle-downstream-errors="true"
                id="CallRaaS_Catch_102"
                routes-to="CallRaaS_102">
                <cc:steps/>
                <cc:send-error id="CatchError" routes-to="Call_HandleError_CallRaaS_Error_102"/>
            </cc:async-mediation>
            <cc:workday-out-rest
                extra-path="@{props['localRestUrl']}"
                id="CallRaaS_102"
                method="GET"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_InitializeAndFinalize_Error_102"
                store-message="none">
                <cc:set name="inLogMessage" value="'RaaS Preparation Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while preparing a reports-as-a-service call.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:sync-mediation
                continue-after-error="rewind"
                handle-downstream-errors="true"
                id="InitializeAndFinalize_102"
                routes-response-to="Call_Finally_102"
                routes-to="ChooseProtocol_102">
                <cc:request-steps>
                    <cc:eval id="EvaluateParameters">
                        <cc:expression>props['localIsPromptsProvided'] = props['inPropertyNameReportPromptMap'] != empty;</cc:expression>
                        <cc:expression>props['localIsPromptsMap'] = (props['localIsPromptsProvided']) ? (context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map) : false;&#xd;
props['localIsPromptsEmpty'] = (props['localIsPromptsProvided']) ? (context.getProperty(props['inPropertyNameReportPromptMap']).isEmpty()) : false;</cc:expression>
                        <cc:expression>props['localIsPromptsValid'] = (!props['localIsPromptsProvided']) || (props['localIsPromptsMap'] &amp;&amp; !props['localIsPromptsEmpty']);</cc:expression>
                    </cc:eval>
                    <cc:validate-exp id="ValidateParameters">
                        <cc:expression
                            error-number="10200"
                            failure-message="The map contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap was either empty, or it was not a map.">props['localIsPromptsValid']</cc:expression>
                    </cc:validate-exp>
                    <cc:eval id="BuildURL">
                        <cc:expression>props['localRestUrl'] = intsys.reportService.getExtrapath(props['inReportServiceAlias']);</cc:expression>
                        <cc:expression>props['localQuerystring'] = '';</cc:expression>
                        <cc:expression>if (props['localIsPromptsProvided']) {&#xd;
	props['localKeyValueMap'] = context.getProperty(props['inPropertyNameReportPromptMap']);&#xd;
&#xd;
	foreach (mapKey : props['localKeyValueMap'].keySet()) {&#xd;
		if (props['localQuerystring'] != empty) {props['localQuerystring'] = props['localQuerystring'] # '&amp;';}&#xd;
&#xd;
		mapValue = props['localKeyValueMap'].get(String.valueOf(mapKey));&#xd;
		if (mapValue instanceof java.util.AbstractCollection) {&#xd;
			props['localQuerystring'] = props['localQuerystring'] # String.valueOf(mapKey) # '=' # com.workday.custom.int0025.int0025102.ParameterMapHelper.transformCollectionParameterToQueryString(mapValue, props.inIsUseJavaUrlEncoder);&#xd;
		} else {&#xd;
			props['localQuerystring'] = props['localQuerystring'] # String.valueOf(mapKey) # '=' # com.workday.custom.int0025.int0025102.ParameterMapHelper.urlEscapeValue(String.valueOf(mapValue), props.inIsUseJavaUrlEncoder);&#xd;
		}&#xd;
	}&#xd;
	props['localRestUrl'] = props['localRestUrl'] # '?' # props['localQuerystring'];&#xd;
}</cc:expression>
                        <cc:expression>props['localIsValidUrlLength'] = props['localRestUrl'].getBytes().length &lt;= 16000;</cc:expression>
                    </cc:eval>
                </cc:request-steps>
                <cc:response-steps/>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_InitializeAndFinalize_Error_102"/>
            </cc:sync-mediation>
            <cc:async-mediation id="Teardown_102">
                <cc:steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localIsPromptsProvided','localIsPromptsValid','localRestUrl','localQuerystring','localKeyValueMap','localIsPromptsMap','localIsPromptsEmpty','localFilename','localProgressedToAPI','localIsValidUrlLength']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_102" routes-to="Teardown_102"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102"
                id="Call_Finally_102"
                store-message="none"/>
            <cc:local-in
                access="public"
                icon="icons/CallRaaS.png"
                id="CallRaaS"
                routes-to="InitializeAndFinalize_102">
                <cc:parameter
                    documentation="The Report Service configuration from which to retrieve results."
                    name="inReportServiceAlias"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the RaaS results are saved to a file that is then attached to the Integration Event for support purposes."
                    name="inSaveResultsToIntegrationEvent"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  If the report is not parameterized, then leave this input parameter empty.  If setting this input parameter though, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap."
                    name="inPropertyNameReportPromptMap"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="false"
                    documentation="Parameter decides how the prompt values are URLEncoded.  True = use java.net.URLEncoder, which encodes the most characters possible.  False = use implementation in ParameterMapHelper that encodes the minimum characters necessary."
                    name="inIsUseJavaUrlEncoder"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="'variable'"
                    documentation="How the RaaS results are returned to the caller, either on the message if the value is 'message', or in the 'globalRaaSResults' variable if the value is 'variable', which is the default."
                    name="inReturnResults"
                    required="true"
                    type="string"
                    validation="props['inReturnResults'] == 'variable' || props['inReturnResults'] == 'message'"/>
                <cc:parameter
                    default="props['globalIsDebugMode']"
                    documentation="Controls whether or not the REST request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_LoadFile_Error_111"
                store-message="none">
                <cc:set name="inLogMessage" value="'File Read Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while reading file ' # props['inFilename'] # ' into the globalInputData variable.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set name="inExtraRecordNumber" value="props['inFileCounter']"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation id="LoadFile_111">
                <cc:steps>
                    <cc:eval id="ReadFileIntoVar">
                        <cc:expression>da.toVar(props['inFilename'], 'globalInputData');</cc:expression>
                    </cc:eval>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Call_HandleError_LoadFile_Error_111"/>
            </cc:async-mediation>
            <cc:local-in
                access="public"
                icon="icons/LoadFile.png"
                id="LoadFile"
                routes-to="LoadFile_111">
                <cc:parameter
                    documentation="The numeric position of the file in the set of input files to be loaded.  This will match to the /Metadata/File/Counter value in vars[globalDAMetadata] as constructed by GetDocumentList.  If there is only one file, then this should be passed as a 1."
                    name="inFileCounter"
                    required="true"/>
                <cc:parameter
                    documentation="The name of the file as known in the results of GetEventDocuments and written into globalDAMetadata in the /Metadata/File/Name element."
                    name="inFilename"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://wcc/PutIntegrationMessage"
                execute-when="props['inOutputIsDeliverable'] == true || props['inOutputDocumentTag'] != empty"
                id="PIM_Tag_106">
                <cc:set name="is.message.severity" value="'INFO'"/>
                <cc:set
                    name="is.message.summary"
                    value="'Saved file '# props['localFilename'] #' to the Integration Event.'"/>
                <cc:set name="is.document.file.name" value="props['localFilename']"/>
                <cc:set
                    name="is.document.deliverable"
                    value="props['inOutputIsDeliverable'] ? 'true' : 'false'"/>
                <cc:set name="is.message.storage.enabled" value="false"/>
                <cc:set name="is.document.labels" value="props['inOutputDocumentTag']"/>
                <cc:set name="is.document.variable.name" value="'localStoreResult'"/>
                <cc:set name="is.event.wid" value="props['inTargetEventWID']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_StoreVariable_Error_106"
                store-message="none">
                <cc:set name="inLogMessage" value="'Storage Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while storing data to the Integration Event.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:local-in
                access="public"
                icon="icons/GenerateOutput.png"
                id="GenerateOutput"
                routes-to="InitializeAndFinalize_106">
                <cc:parameter
                    default="lp.isSet() ? lp.getIntegrationEventWID() : null"
                    documentation="The WID of the Integration Event to which the document should be attached.  This need not be the current event, although it will default as such."
                    name="inTargetEventWID"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['globalOutputFilename']"
                    documentation="The filename of the file to be produced.  This may be provided as an Integration Attribute, and is defaulted as such.  This may also be produced by a Sequence Generator and provided here.  The name should not include an extension.  The extension is provided on the inOutputFileExtension parameter."
                    name="inOutputFilename"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="'xml'"
                    documentation="The file extension to be added to the filename provided on the inOutputFilename parameter."
                    name="inOutputFileExtension"
                    required="true"
                    type="string"
                    validation="props['inOutputFileExtension'] == 'xml' || props['inOutputFileExtension'] == 'xml.pgp' ||&#xd;&#xa;props['inOutputFileExtension'] == 'csv' || props['inOutputFileExtension'] == 'csv.pgp' ||&#xd;&#xa;props['inOutputFileExtension'] == 'txt' || props['inOutputFileExtension'] == 'txt.pgp'"/>
                <cc:parameter
                    default="props['globalDocumentRetentionPeriod']"
                    documentation="The duration to keep the output file.  Value is of the format &quot;P&quot; followed by a number followed by &quot;D&quot;.  This evaluates to a number of days."
                    name="inDocumentRetentionPeriod"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="An optional Document Tag to be placed on the file to facilitate ease of identification on the Integration Event."
                    name="inOutputDocumentTag"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="A boolean flag to specify if the file being produced should be considered deliverable.  This facilitates identification by a Document Delivery service."
                    name="inOutputIsDeliverable"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
                <cc:parameter
                    default="'message'"
                    documentation="Where to find the data to be output.  If the value is 'variable', then the contents of globalOutputData will be written.  Otherwise, the contents of the message root part will be output."
                    name="inDataSource"
                    required="true"
                    type="string"
                    validation="['variable', 'message'] contains props['inDataSource'].trim().toLowerCase()"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_SingleFileProceed_InitializeAndFinalize_Error_110"
                store-message="none">
                <cc:set name="inLogMessage" value="'File Metadata Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while reading the input file and generating the metadata.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:sync-mediation id="SingleFileProceed_InitializeAndFinalize_110">
                <cc:request-steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['localRetrievedFilename'] = (props['inRetrievalDocTag'] == empty) ? da.allFileNames.get(0) : da.getFileNames(props['inRetrievalDocTag']).get(0);</cc:expression>
                    </cc:eval>
                    <cc:eval id="UpdateDebug">
                        <cc:expression>props['globalDebugPropertyList'].add('localRetrievedFilename');</cc:expression>
                    </cc:eval>
                    <cc:write
                        id="WriteDocumentAccessorMetadata"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="globalDAMetadata">
                        <cc:message>
                            <cc:text>&lt;Metadata>&#xd;
	&lt;File>&#xd;
		&lt;Counter>0&lt;/Counter>&#xd;
		&lt;Name>@{props['localRetrievedFilename']}&lt;/Name>&#xd;
	&lt;/File>&#xd;
&lt;/Metadata>	</cc:text>
                        </cc:message>
                    </cc:write>
                </cc:request-steps>
                <cc:response-steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localRetrievedFilename']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    </cc:eval>
                    <cc:eval id="ReduceDebug">
                        <cc:expression>props['globalDebugPropertyList'].remove('localRetrievedFilename');</cc:expression>
                    </cc:eval>
                </cc:response-steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_SingleFileProceed_InitializeAndFinalize_Error_110"/>
            </cc:sync-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_SingleFileProceed_Info_110"
                routes-response-to="SingleFileProceed_InitializeAndFinalize_110"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="'A Document Retrieval Service file was found and loaded.'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
                <cc:set name="inLogLevel" value="'info'"/>
                <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(SingleFileProceed)'"/>
                <cc:set
                    name="inExtraRecordNumber"
                    value="String.valueOf(props['localDACount'])"/>
                <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/AggregateMetadata_110"
                id="Call_AggregateMetadata_Append_110"
                store-message="none">
                <cc:set name="inCollate" value="true"/>
                <cc:set name="inBatch" value="false"/>
            </cc:local-out>
            <cc:async-mediation id="MultipleFilesProceed_Iterate_Handler_110">
                <cc:steps>
                    <cc:eval id="ClearError">
                        <cc:expression>context.setException(null);</cc:expression>
                        <cc:expression>context.setErrorComponentId(null);</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_MultipleFilesProceed_Iterate_Error_110"
                routes-response-to="MultipleFilesProceed_Iterate_Handler_110"
                store-message="none">
                <cc:set name="inLogMessage" value="'File Metadata Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred on iteration loop '# String.valueOf(props['localFileCounter']) #'.  This file will be skipped and processing will attempt to resume with the next file.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set name="inIsAbortOnError" value="false"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                continue-after-error="rewind"
                handle-downstream-errors="true"
                id="MultipleFilesProceed_Iterate_110"
                routes-to="Call_AggregateMetadata_Append_110">
                <cc:steps>
                    <cc:eval id="SetValues">
                        <cc:expression>props['localRetrievedFilename'] = props['localRetrievedFilenames'].get(props['localFileCounter']);</cc:expression>
                    </cc:eval>
                    <cc:write id="WriteDocumentAccessorMetadata">
                        <cc:message>
                            <cc:text>&lt;File>&#xd;
	&lt;Counter>@{props['localFileCounter']}&lt;/Counter>&#xd;
	&lt;Name>@{props['localRetrievedFilename']}&lt;/Name>&#xd;
&lt;/File></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_MultipleFilesProceed_Iterate_Error_110"/>
            </cc:async-mediation>
            <cc:route id="MultipleFilesProceed_ForLoop_110">
                <cc:loop-strategy
                    condition="props['localFileCounter'] &lt; props['localDACount']"
                    increment="props['localFileCounter'] = props['localFileCounter'] + 1"
                    init="props['localFileCounter'] = 0"/>
                <cc:sub-route name="Iterate" routes-to="MultipleFilesProceed_Iterate_110"/>
            </cc:route>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/AggregateMetadata_110"
                id="Call_AggregateMetadata_Finalize_110"
                store-message="none">
                <cc:set name="inCollate" value="false"/>
                <cc:set name="inBatch" value="true"/>
            </cc:local-out>
            <cc:sync-mediation
                id="MultipleFilesProceed_InitializeAndFinalize_110"
                routes-response-to="Call_AggregateMetadata_Finalize_110"
                routes-to="MultipleFilesProceed_ForLoop_110">
                <cc:request-steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['localRetrievedFilenames'] = (props['inRetrievalDocTag'] == empty) ? da.allFileNames : da.getFileNames(props['inRetrievalDocTag']);</cc:expression>
                    </cc:eval>
                    <cc:eval id="UpdateDebug">
                        <cc:expression>props['globalDebugPropertyList'].add('localRetrievedFilenames');</cc:expression>
                    </cc:eval>
                </cc:request-steps>
                <cc:response-steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localRetrievedFilenames','localRetrievedFilename','localFileCounter']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    </cc:eval>
                    <cc:eval id="ReduceDebug">
                        <cc:expression>props['globalDebugPropertyList'].remove('localRetrievedFilenames');</cc:expression>
                    </cc:eval>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_MultipleFilesProceed_Info_110"
                routes-response-to="MultipleFilesProceed_InitializeAndFinalize_110"
                store-message="none">
                <cc:set name="inLogMessage" value="'Multiple retrieved files were found.'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
                <cc:set name="inLogReferenceId" value="String.valueOf(props['localDACount'])"/>
                <cc:set name="inLogLevel" value="'info'"/>
                <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(MultipleFilesProceed)'"/>
                <cc:set
                    name="inExtraRecordNumber"
                    value="String.valueOf(props['localDACount'])"/>
                <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_MultipleFilesCountError_Error_110"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="'The expected number of files was not found!'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  However, '# props['inExactFileCountExpected'] #' files(s) were expected.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set
                    name="inExtraLocalIn"
                    value="'RouteOnCount_110(MultipleFilesCountError)'"/>
                <cc:set
                    name="inExtraRecordNumber"
                    value="String.valueOf(props['localDACount'])"/>
                <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
                <cc:set name="inExtraErrorCode" value="'11002'"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_MultipleFilesError_Error_110"
                store-message="none">
                <cc:set name="inLogMessage" value="'Too many retrieved files were found!'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  Only a single file is expected.  A multiple-data condition is an error and the output of the Document Retrieval Service should be investigated.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(MultipleFilesError)'"/>
                <cc:set
                    name="inExtraRecordNumber"
                    value="String.valueOf(props['localDACount'])"/>
                <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
                <cc:set name="inExtraErrorCode" value="'11001'"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation id="NoFileProceed_EmptyMetadata_110">
                <cc:steps>
                    <cc:write
                        id="WriteDocumentAccessorMetadata"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="globalDAMetadata">
                        <cc:message>
                            <cc:text>&lt;Metadata/>&#xd;
</cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_NoFileProceed_Info_110"
                routes-response-to="NoFileProceed_EmptyMetadata_110"
                store-message="none">
                <cc:set name="inLogMessage" value="'No retrieved file was found.'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
                <cc:set name="inLogLevel" value="'info'"/>
                <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(NoFileProceed)'"/>
                <cc:set name="inExtraRecordNumber" value="'0'"/>
                <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_NoFileError_Error_110"
                store-message="none">
                <cc:set name="inLogMessage" value="'No retrieved file was found!'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="props['localDACount'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  Data is expected.  A no-data condition is an error and the output of the Document Retrieval Service should be investigated.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(NoFileError)'"/>
                <cc:set name="inExtraRecordNumber" value="'0'"/>
                <cc:set name="inExtraSupportData" value="props['localExtraSupportData']"/>
                <cc:set name="inExtraErrorCode" value="'11000'"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:route id="RouteOnCount_110">
                <cc:mvel-strategy>
                    <cc:choose-route
                        expression="props['inNoFileThrowsException'] == true &amp;&amp; props['localDACount'] == 0"
                        route="NoFileError"/>
                    <cc:choose-route
                        expression="props['inNoFileThrowsException'] == false &amp;&amp; props['localDACount'] == 0"
                        route="NoFileProceed"/>
                    <cc:choose-route
                        expression="props['inMultipleFilesThrowsException'] == true &amp;&amp; props['localDACount'] > 1"
                        route="MultipleFilesError"/>
                    <cc:choose-route
                        expression="props['inMultipleFilesThrowsException'] == false &amp;&amp; props['inExactFileCountExpected'] > 0 &amp;&amp; (props['localDACount'] != props['inExactFileCountExpected'])"
                        route="MultipleFilesCountError"/>
                    <cc:choose-route
                        expression="props['inMultipleFilesThrowsException'] == false &amp;&amp; (props['inExactFileCountExpected'] == -1 || props['localDACount'] == props['inExactFileCountExpected']) &amp;&amp; props['localDACount'] > 1"
                        route="MultipleFilesProceed"/>
                    <cc:choose-route expression="true" route="SingleFileProceed"/>
                </cc:mvel-strategy>
                <cc:sub-route
                    name="NoFileError"
                    routes-to="Call_HandleError_NoFileError_Error_110"/>
                <cc:sub-route
                    name="NoFileProceed"
                    routes-to="Call_CreateLogEntry_NoFileProceed_Info_110"/>
                <cc:sub-route
                    name="MultipleFilesError"
                    routes-to="Call_HandleError_MultipleFilesError_Error_110"/>
                <cc:sub-route
                    name="MultipleFilesCountError"
                    routes-to="Call_HandleError_MultipleFilesCountError_Error_110"/>
                <cc:sub-route
                    name="MultipleFilesProceed"
                    routes-to="Call_CreateLogEntry_MultipleFilesProceed_Info_110"/>
                <cc:sub-route
                    name="SingleFileProceed"
                    routes-to="Call_CreateLogEntry_SingleFileProceed_Info_110"/>
            </cc:route>
            <cc:async-mediation
                handle-downstream-errors="true"
                id="DocumentAccessor_110"
                routes-to="RouteOnCount_110">
                <cc:steps>
                    <cc:eval id="SetValues">
                        <cc:expression>props['localDACount'] = (props['inRetrievalDocTag'] == empty) ? da.size() : da.size(props['inRetrievalDocTag']);</cc:expression>
                        <cc:expression>props['localExtraSupportData'] = (props['inRetrievalDocTag'] != empty) ? 'Document Tag filter = ['# props['inRetrievalDocTag'] #']' : '';</cc:expression>
                    </cc:eval>
                    <cc:eval id="UpdateDebug">
                        <cc:expression>props['globalDebugPropertyList'].add('localDACount');&#xd;
props['globalDebugPropertyList'].add('localExtraSupportData');</cc:expression>
                    </cc:eval>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_DocumentAccessor_Error_110"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://wcc/GetEventDocuments"
                id="GetEventDocuments_110"
                routes-response-to="DocumentAccessor_110">
                <cc:set name="ie.event.wid" value="props['inEventWID']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_InitializeAndFinalize_Error_110"
                store-message="none">
                <cc:set name="inLogMessage" value="'GetEventDocuments Execution Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while calling Get_Event_Documents.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:sync-mediation
                handle-downstream-errors="true"
                id="InitializeAndFinalize_110"
                routes-response-to="Call_Finally_110"
                routes-to="GetEventDocuments_110">
                <cc:request-steps/>
                <cc:response-steps>
                    <cc:eval id="ReduceDebug">
                        <cc:expression>props['globalDebugPropertyList'].remove('localDACount');&#xd;
props['globalDebugPropertyList'].remove('localExtraSupportData');</cc:expression>
                    </cc:eval>
                </cc:response-steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_InitializeAndFinalize_Error_110"/>
            </cc:sync-mediation>
            <cc:aggregator
                collate-when="props['inCollate']"
                force-batch-on-last-message="false"
                force-batch-when="props['inBatch']"
                id="AggregateRows_110">
                <cc:size-batch-strategy batch-size="-1"/>
                <cc:xml-message-content-collater
                    output="variable"
                    output-mimetype="text/xml"
                    output-variable="globalDAMetadata">
                    <cc:header-text>&lt;Metadata></cc:header-text>
                    <cc:footer-text>&lt;/Metadata></cc:footer-text>
                </cc:xml-message-content-collater>
            </cc:aggregator>
            <cc:local-in id="AggregateMetadata_110" routes-to="AggregateRows_110">
                <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
                <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
            </cc:local-in>
            <cc:async-mediation id="Teardown_110">
                <cc:steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localDACount','localExtraSupportData']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_110" routes-to="Teardown_110"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110"
                id="Call_Finally_110"
                store-message="none">
            
            
            
            
            
            
            
        </cc:local-out>
            <cc:local-in
                access="public"
                icon="icons/GetDocumentList.png"
                id="GetDocumentList"
                routes-to="InitializeAndFinalize_110">
                <cc:parameter
                    default="lp.isSet() ? lp.getIntegrationEventWID() : null"
                    documentation="WID of the Integration Event from which the documents will be queried.  This is typically the current event, and as such, is defaulted to the current event WID.  However, changing this WID enables retrieving documents from another related event for processing."
                    name="inEventWID"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="true"
                    documentation="Controls whether or not an exception is thrown when there are no input files to the Integration Event.  TRUE means an exception will be thrown.  FALSE means no exception will be thrown."
                    name="inNoFileThrowsException"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="true"
                    documentation="Controls whether or not an exception is thrown when there are multiple input files to the Integration Event.  TRUE means an exception will be thrown.  FALSE means no exception will be thrown."
                    name="inMultipleFilesThrowsException"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="-1"
                    documentation="Specifies an exact number of files to be expected on the Integration Event.  If a variable number of input files is supported, then this should be passed as -1."
                    name="inExactFileCountExpected"
                    required="false"
                    type="integer"
                    validation="props['inExactFileCountExpected'] == -1 || props['inExactFileCountExpected'] > 0"/>
                <cc:parameter
                    default="props['globalRetrievalDocTag']"
                    documentation="Specifies a Document Tag for filtering the input files on the Integration Event.  If not specified, parameter will try to use the value of the Retrieval Document Tag Integration Attribute."
                    name="inRetrievalDocTag"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
            </cc:local-in>
            <cc:local-in id="Main" routes-to="InitializeAttributesAndLaunchParameters"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_SoapError_Error_103"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="props['inWebServiceApplication'] #' application SOAP request error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while executing a soap request for the '# props['inWebServiceApplication'] #' application.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set name="inExtraErrorCode" value="'10307'"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Request__' # props['inWebServiceApplication']"/>
            </cc:local-out>
            <cc:async-mediation
                id="RouteError_Soap_Handler_103"
                routes-to="Call_HandleError_SoapError_Error_103">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'soap';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLog"
                id="Call_StoreLog_Initialize"
                routes-response-to="Call_Debug_Initialize_Finalize"
                store-message="none">
                <cc:set name="inLogFinalize" value="true"/>
            </cc:local-out>
            <cc:local-in
                access="public"
                icon="icons/Debug.png"
                id="Debug"
                routes-to="Initialize_109">
                <cc:parameter
                    default="'message'"
                    documentation="The type of information to be output to the log."
                    name="inTargetType"
                    required="true"
                    type="string"
                    validation="props['globalDebugTargetTypeParameterValidation'].contains(props['inTargetType'])"/>
                <cc:parameter
                    documentation="The reference name to use for single-named output types selected on inTargetType.  Required when inTargetType is one of: property, variable, list, map, or set."
                    name="inTargetName"
                    required="false"
                    type="string"
                    validation="props['globalDebugTargetNameParameterValidation'].contains(props['inTargetType']) &amp;&amp;&#xd;&#xa;(props['inTargetName'] != empty || props['inEntityName'] != empty)"/>
                <cc:parameter
                    documentation="A specific filename to use when exporting the message or variable content to a file zipped in a consolidated archive.  This is optional and only used when inTargetType is &quot;message&quot; or &quot;variable&quot;."
                    name="inEntityName"
                    required="false"
                    type="string"/>
                <cc:out-parameter
                    documentation="If a file has been written to the debug archive, the name of that file will be returned for further reference in logging messages."
                    name="outEntityName"/>
            </cc:local-in>
            <cc:route id="RouteType_109">
                <cc:mvel-strategy>
                    <cc:choose-route
                        expression="props['inTargetType'] == 'message'"
                        route="Message"/>
                    <cc:choose-route
                        expression="props['inTargetType'] == 'property'"
                        route="Property"/>
                    <cc:choose-route
                        expression="props['inTargetType'] == 'properties'"
                        route="Properties"/>
                    <cc:choose-route
                        expression="props['inTargetType'] == 'variable'"
                        route="Variable"/>
                    <cc:choose-route expression="props['inTargetType'] == 'map'" route="Map"/>
                    <cc:choose-route expression="props['inTargetType'] == 'list'" route="List"/>
                    <cc:choose-route expression="props['inTargetType'] == 'set'" route="Set"/>
                    <cc:choose-route
                        expression="props['inTargetType'] == 'finalize'"
                        route="Finalize"/>
                    <cc:choose-route expression="true" route="Undefined"/>
                </cc:mvel-strategy>
                <cc:sub-route name="Message" routes-to="Call_Aggregate_Message_109"/>
                <cc:sub-route
                    name="Property"
                    routes-to="Call_CreateLogEntry_Debug_Property_109"/>
                <cc:sub-route
                    name="Properties"
                    routes-to="Properties_InitializeAndFinalize_109"/>
                <cc:sub-route name="Variable" routes-to="Variable_InitializeAndFinalize_109"/>
                <cc:sub-route name="Map" routes-to="Map_InitializeAndFinalize_109"/>
                <cc:sub-route name="List" routes-to="List_InitializeAndFinalize_109"/>
                <cc:sub-route name="Set" routes-to="Set_InitializeAndFinalize_109"/>
                <cc:sub-route name="Finalize" routes-to="Call_Aggregate_Finalize_109"/>
                <cc:sub-route
                    name="Undefined"
                    routes-to="Call_CreateLogEntry_Warn_Undefined_109"/>
            </cc:route>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Warn_Undefined_109"
                store-message="none">
                <cc:set name="inLogMessage" value="'Undefined Debug Log'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'RouteType_109 was not able to correctly process the inTargetType input parameter.'"/>
                <cc:set name="inLogLevel" value="'warn'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Debug_Variable_109"
                routes-response-to="Variable_Name_109"
                store-message="none">
                <cc:set name="inLogMessage" value="'Variable ' # props['inTargetName']"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'Variable '# props['inTargetName'] #' saved to debug file with name of ' # props['outEntityName']"/>
                <cc:set name="inLogLevel" value="'debug'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Debug_Property_109"
                store-message="none">
                <cc:set name="inLogMessage" value="'Property ' # props['inTargetName']"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="propname = props['inTargetName'];&#xd;&#xa;String.valueOf(props[propname]);"/>
                <cc:set name="inLogLevel" value="'debug'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Debug_Message_109"
                routes-response-to="Message_Name_109"
                store-message="none">
                <cc:set name="inLogMessage" value="'Message RootPart'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'Message root part saved to debug file with name of ' # props['outEntityName']"/>
                <cc:set name="inLogLevel" value="'debug'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Debug_Properties_109"
                store-message="none">
                <cc:set name="inLogMessage" value="parts[0].xpath('/p/k')"/>
                <cc:set name="inLogMessageDetail" value="parts[0].xpath('/p/v')"/>
                <cc:set name="inLogLevel" value="'debug'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
            </cc:local-out>
            <cc:splitter id="Properties_Splitter_109" no-split-message-error="false">
                <cc:sub-route
                    name="Iterate"
                    routes-to="Call_CreateLogEntry_Debug_Properties_109"/>
                <cc:xml-stream-splitter xpath="/root/p"/>
            </cc:splitter>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Debug_Map_109"
                store-message="none">
                <cc:set name="inLogMessage" value="parts[0].xpath('/p/k')"/>
                <cc:set name="inLogMessageDetail" value="parts[0].xpath('/p/v')"/>
                <cc:set name="inLogLevel" value="'debug'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
            </cc:local-out>
            <cc:splitter id="Map_Splitter_109" no-split-message-error="false">
                <cc:sub-route name="Iterate" routes-to="Call_CreateLogEntry_Debug_Map_109"/>
                <cc:xml-stream-splitter xpath="/root/p"/>
            </cc:splitter>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Debug_List_109"
                store-message="none">
                <cc:set name="inLogMessage" value="props.inTargetName # ' Element'"/>
                <cc:set name="inLogMessageDetail" value="parts[0].xpath('/root/e')"/>
                <cc:set name="inLogLevel" value="'debug'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
            </cc:local-out>
            <cc:splitter id="List_Splitter_109" no-split-message-error="false">
                <cc:sub-route name="Iterate" routes-to="Call_CreateLogEntry_Debug_List_109"/>
                <cc:xml-stream-splitter xpath="/root"/>
            </cc:splitter>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Debug_Set_109"
                store-message="none">
                <cc:set name="inLogMessage" value="props.inTargetName # ' Element'"/>
                <cc:set name="inLogMessageDetail" value="parts[0].xpath('/root/e')"/>
                <cc:set name="inLogLevel" value="'debug'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
            </cc:local-out>
            <cc:splitter id="Set_Splitter_109" no-split-message-error="false">
                <cc:sub-route name="Iterate" routes-to="Call_CreateLogEntry_Debug_Set_109"/>
                <cc:xml-stream-splitter xpath="/root"/>
            </cc:splitter>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_SoapRequest_103"
                routes-response-to="CallSoap_Catch_103"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Request__' # props['inWebServiceApplication']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_RaaSRequest_102"
                routes-response-to="CallRaaS_Catch_102"
                store-message="none">
                <cc:set name="inTargetType" value="'property'"/>
                <cc:set name="inTargetName" value="'localRestUrl'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_SoapXslt_103"
                store-message="none">
                <cc:set name="inTargetType" value="'variable'"/>
                <cc:set name="inTargetName" value="'localXsltSoapGenerator'"/>
                <cc:set
                    name="inEntityName"
                    value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            </cc:local-out>
            <cc:route id="RouteError_103">
                <cc:mvel-strategy>
                    <cc:choose-route
                        expression="parts[0].isXml() &amp;&amp; (Integer.valueOf(parts[0].xpath('count(/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault)')) > 0)"
                        route="SoapError"/>
                    <cc:choose-route expression="true" route="HttpError"/>
                </cc:mvel-strategy>
                <cc:sub-route name="SoapError" routes-to="RouteError_Soap_Handler_103"/>
                <cc:sub-route name="HttpError" routes-to="RouteError_Http_Handler_103"/>
            </cc:route>
            <cc:async-mediation
                id="HttpError_Handler_104"
                routes-to="Call_HandleError_HttpError_Error_104">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'http';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_HttpError_Error_104"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="props['inWebServiceApplication'] #' application HTTP request error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'A transport protocol error occurred and the request was not evaluated or processed by the tenant.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'property'"/>
                <cc:set name="inTargetName" value="'message'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Request__' # props['inWebServiceApplication']"/>
            </cc:local-out>
            <cc:async-mediation
                id="SoapError_Handler_104"
                routes-to="Call_HandleError_SoapError_Error_104">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'soap';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_SoapError_Error_104"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="props['inWebServiceApplication'] #' application SOAP request error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'The API call resulted in the following SOAP fault: '# String.valueOf(parts[0].xpath('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault/faultstring'))"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set name="inExtraErrorCode" value="'10407'"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'property'"/>
                <cc:set name="inTargetName" value="'message'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Request__' # props['inWebServiceApplication']"/>
            </cc:local-out>
            <cc:route id="RouteError_104">
                <cc:mvel-strategy>
                    <cc:choose-route
                        expression="parts[0].isXml() &amp;&amp; (parts[0].xpath('count(/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault)') > 0)"
                        route="SoapError"/>
                    <cc:choose-route expression="true" route="HttpError"/>
                </cc:mvel-strategy>
                <cc:sub-route name="SoapError" routes-to="SoapError_Handler_104"/>
                <cc:sub-route name="HttpError" routes-to="HttpError_Handler_104"/>
            </cc:route>
            <cc:async-mediation
                continue-after-error="rewind"
                handle-downstream-errors="true"
                id="CallSoap_Catch_104"
                routes-to="CallSoap_104">
                <cc:steps/>
                <cc:send-error id="CatchError" routes-to="RouteError_104"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_SoapRequest_104"
                routes-response-to="CallSoap_Catch_104"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set name="inEntityName" value="'SOAP-Request'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_SoapXslt_104"
                store-message="none">
                <cc:set name="inTargetType" value="'variable'"/>
                <cc:set name="inTargetName" value="'localXsltSoapGenerator'"/>
                <cc:set
                    name="inEntityName"
                    value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            </cc:local-out>
            <cc:async-mediation
                id="Transform_Handler_104"
                routes-to="Call_HandleError_Transform_Error_104">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Transform_Error_104"
                store-message="none">
                <cc:set name="inLogMessage" value="'Transformation Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while preparing a SOAP service call.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'property'"/>
                <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
                <cc:set
                    name="inEntityName"
                    value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            </cc:local-out>
            <cc:async-mediation id="Transform_104" routes-to="Call_Debug_SoapXslt_104">
                <cc:steps>
                    <cc:xslt-plus id="WriteSoap" url="@{props['inPathToXsltFile']}"/>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Transform_Handler_104"/>
            </cc:async-mediation>
            <cc:async-mediation
                execute-steps-when="props['localIsNonEmptyMapVariable']"
                id="PrepareVariableInput_104"
                routes-to="Transform_104">
                <cc:steps>
                    <cc:eval id="PrimeMessage">
                        <cc:expression>varname = props['inMapVariableName'];&#xd;
parts[0] = vars[varname];</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation
                execute-steps-when="(!props['localIsValuedProperty'] &amp;&amp; !props['localIsValuedVariable']) || props['localIsNonEmptyMapProperty']"
                id="PrepareMapInput_104"
                routes-to="PrepareVariableInput_104">
                <cc:steps>
                    <cc:write id="PrimeMessage">
                        <cc:message>
                            <cc:text>&lt;?xml version="1.0" encoding="UTF-8"?>&#xd;
&lt;Root/></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation
                id="Validation_Handler_104"
                routes-to="Call_HandleError_Validation_Error_104">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Validation_Error_104"
                store-message="none">
                <cc:set name="inLogMessage" value="'Validation Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while validating parameters for a SOAP service call.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:sync-mediation
                id="InitializeAndFinalize_104"
                routes-response-to="Call_Finally_104"
                routes-to="Call_BuildRequest_104">
                <cc:request-steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['outIsSoapError'] = '';</cc:expression>
                    </cc:eval>
                </cc:request-steps>
                <cc:response-steps/>
            </cc:sync-mediation>
            <cc:async-mediation id="Teardown_104">
                <cc:steps>
                    <cc:set-headers id="ClearHeaders">
                        <cc:remove-headers>
                            <cc:remove-header name="x-validate-only"/>
                        </cc:remove-headers>
                        <cc:add-headers/>
                    </cc:set-headers>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localIsValuedProperty','localIsDefinedProperty','localIsCorrectTypeProperty','localIsNonEmptyMapProperty','localIsValuedVariable','localIsDefinedVariable','localIsCorrectTypeVariable','localIsNonEmptyMapVariable']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_104" routes-to="Teardown_104"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104"
                id="Call_Finally_104"
                store-message="none"/>
            <cc:local-in
                access="public"
                icon="icons/CallSoapPaged.png"
                id="CallSoapPaged"
                routes-to="InitializeAndFinalize_104">
                <cc:parameter
                    default="props['globalApiVersion']"
                    documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;"
                    name="inApiVersion"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;."
                    name="inWebServiceApplication"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="true"
                    documentation="Sub-assembly supports pre-built, on-message requests as well as facilities to construct the request dynamically.  Set this parameter to true to bypass the dynamic request construction and use the message root part as the request.  If set to false, then the inPathToXsltFile and the inMapPropertyName or inMapVariableName parameters should be set."
                    name="inUseMessageRootPartAsRequest"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;."
                    name="inPathToXsltFile"
                    required="!props['inUseMessageRootPartAsRequest']"
                    type="string"/>
                <cc:parameter
                    documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request."
                    name="inMapPropertyName"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example."
                    name="inMapVariableName"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="Xpath to the elements in the response that are to be aggregated into the globalSoapResults variable."
                    name="inXpathToResultsToAggregate"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="'&lt;SoapResults xmlns:wd=&quot;urn:com.workday/bsvc&quot;>'"
                    documentation="In order to aggregate multiple XML elements at the same level into a final, returned document, a new root node is required.  This parameter defines that node including the namespaces required in the results, e.g. &lt;SoapResults xmlns:wd=&quot;urn:com.workday/bsvc&quot;>"
                    name="inAggregatedResultsHeader"
                    required="true"
                    type="string"
                    validation="props['inAggregatedResultsHeader'] != empty"/>
                <cc:parameter
                    default="'&lt;/SoapResults>'"
                    documentation="In order to aggregate multiple XML elements at the same level into a final, returned document, a new root node is required.  This parameter defines the matching, terminating element as was defined on the inAggregatedResults parameter."
                    name="inAggregatedResultsFooter"
                    required="true"
                    type="string"
                    validation="props['inAggregatedResultsFooter'] != empty"/>
                <cc:parameter
                    default="'variable'"
                    documentation="How the SOAP results are returned to the caller, either on the message if the value is 'message', or in the 'globalSoapResults' variable if the value is 'variable', which is the default."
                    name="inReturnResults"
                    required="true"
                    type="string"
                    validation="props['inReturnResults'] == 'variable' || props['inReturnResults'] == 'message'"/>
                <cc:parameter
                    default="props['globalIsValidationMode']"
                    documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors."
                    name="inValidateOnly"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="props['globalIsDebugMode']"
                    documentation="Controls whether or not the SOAP request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
                <cc:out-parameter
                    documentation="A string to indicate that the request resulted in an error and identify the type.  If the error was at the API level, then outIsSoapError == 'http'.  If the error was at the tenant/application level, then outIsSoapError == 'soap'.  If there was an error unrelated to the API call, then outIsSoapError == 'logic'.  If there is no error, , then outIsSoapError == empty.  Further individual errors determined by Get_Event_Details or Get_Import_Processes are not handled here."
                    name="outIsSoapError"/>
            </cc:local-in>
            <cc:local-out endpoint="vm://wcc/PagedGet" id="CallSoap_104">
                <cc:set
                    name="is.paged.get.request.current.page.xpath"
                    value="'/env:Envelope/env:Body/*/wd:Response_Filter/wd:Page'"/>
                <cc:set
                    name="is.paged.get.response.current.page.xpath"
                    value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Page'"/>
                <cc:set
                    name="is.paged.get.response.total.pages.xpath"
                    value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Pages'"/>
                <cc:set
                    name="is.paged.get.response.total.results.xpath"
                    value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Results'"/>
                <cc:set
                    name="is.paged.get.process.endpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessPage_104'"/>
                <cc:set
                    name="is.paged.get.application"
                    value="props['inWebServiceApplication']"/>
                <cc:set name="is.paged.get.version" value="props['inApiVersion']"/>
                <cc:set name="is.paged.get.page.zero" value="false"/>
                <cc:set name="is.paged.get.store.requests" value="true"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_LoadMap_Error_105"
                store-message="none">
                <cc:set name="inLogMessage" value="'XSLT3 Map Load Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'The XML data failed to be converted into a Java Map'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_105'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'variable'"/>
                <cc:set name="inTargetName" value="'localPjmXslt'"/>
                <cc:set name="inEntityName" value="'PopulateJavaMap-Transform'"/>
            </cc:local-out>
            <cc:async-mediation id="Teardown_105">
                <cc:steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>// Remove properties that are purely internal to the subassembly
foreach (propname : ['localMapPropertyName']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                        <cc:expression>// And remove local variables that are no longer required&#xd;
foreach (varname : ['localPjmXslt', 'localPjmXsltBlob']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_105" routes-to="Teardown_105"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_105"
                id="Call_Finally_105"
                store-message="none"/>
            <cc:local-in
                access="public"
                icon="icons/IntegrationEventProgress0.png"
                id="IntegrationEventProgress"
                routes-to="PIM_108">
                <cc:parameter
                    documentation="The overall completion percentage of the studio execution."
                    name="inProgressPercentage"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The optional message to output on the Integration Event to indicate at what stage of the processing the Studio is."
                    name="inProgressMessage"
                    required="false"
                    type="string"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://wcc/PutIntegrationMessage"
                execute-when="props['inProgressMessage'] != empty"
                id="PIM_108"
                routes-response-to="PIE_108">
                <cc:set name="is.message.severity" value="'INFO'"/>
                <cc:set name="is.message.summary" value="props['inProgressMessage']"/>
                <cc:set name="is.message.storage.enabled" value="false"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://wcc/PutIntegrationEvent"
                id="PIE_108"
                routes-response-to="Call_CreateLogEntry_Info_108">
                <cc:set name="is.percent.complete" value="props['inProgressPercentage']"/>
            </cc:local-out>
            <cc:local-out
                clone-request="true"
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/IntegrationEventProgress"
                id="Call_IEP_10"
                propagate-abort="false"
                routes-response-to="MainFlowControl"
                store-message="none">
                <cc:set name="inProgressPercentage" value="'10'"/>
                <cc:set
                    name="inProgressMessage"
                    value="'Initialization Complete.  Cloud Log, integration attributes, and launch parameters have been loaded.'"/>
            </cc:local-out>
            <cc:local-out
                clone-request="true"
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/IntegrationEventProgress"
                id="Call_IEP_90"
                propagate-abort="false"
                routes-response-to="Call_StaticCodeAnalysis"
                store-message="none">
                <cc:set name="inProgressPercentage" value="'90'"/>
                <cc:set
                    name="inProgressMessage"
                    value="'Integration functional behavior complete.  Finalizing logs...'"/>
            </cc:local-out>
            <cc:local-out
                clone-request="true"
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/IntegrationEventProgress"
                id="Call_IEP_99"
                propagate-abort="false"
                store-message="none">
                <cc:set name="inProgressPercentage" value="'99'"/>
                <cc:set
                    name="inProgressMessage"
                    value="'Logs Finalized.  Awaiting any background process to complete Integration Event...'"/>
            </cc:local-out>
            <cc:aggregator
                collate-when="props['inCollate']"
                force-batch-on-last-message="false"
                force-batch-when="props['inBatch']"
                id="AggregateToArchive_109"
                routes-to="StoreArchive_109">
                <cc:size-batch-strategy batch-size="-1"/>
                <cc:zip-file-collater
                    message-entity-name="@{props['outEntityName']}"
                    output-mimetype="application/zip"/>
            </cc:aggregator>
            <cc:local-in id="Aggregate_109" routes-to="DedupeName_109">
                <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
                <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
                <cc:parameter
                    default="(props['inEntityName'] != empty) ? props['inEntityName'] : props['inTargetName']"
                    name="inEntityName"
                    required="props['inCollate']"
                    type="string"/>
                <cc:out-parameter name="outEntityName"/>
            </cc:local-in>
            <cc:async-mediation id="DedupeName_109" routes-to="AggregateToArchive_109">
                <cc:steps>
                    <cc:validate-exp id="ValidateParameters">
                        <cc:expression
                            error-number="10900"
                            failure-message="DebugFile Aggregator (Aggregator_109) parameter failure.  The inCollate and inBatch arguments cannot both be false.">(!props['inCollate'] &amp;&amp; props['inBatch']) ||&#xd;
	(props['inCollate'] &amp;&amp; !props['inBatch']) ||&#xd;
	(props['inCollate'] &amp;&amp; props['inBatch'])</cc:expression>
                    </cc:validate-exp>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outEntityName'] = (props['inEntityName'] != empty) ? props['globalStringDeduplicator'].dedupeString(props['inEntityName']) : '';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_109"
                id="Call_Aggregate_Finalize_109"
                store-message="none">
                <cc:set name="inCollate" value="false"/>
                <cc:set name="inBatch" value="true"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_109"
                id="Call_Aggregate_Message_109"
                routes-response-to="Call_CreateLogEntry_Debug_Message_109"
                store-message="none">
                <cc:set name="inCollate" value="true"/>
                <cc:set name="inBatch" value="false"/>
                <cc:set
                    name="inEntityName"
                    value="(props['inEntityName'] != empty) ? props['inEntityName'] : props['inTargetName']"/>
            </cc:local-out>
            <cc:async-mediation id="Message_Name_109">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outEntityName'] = props['outEntityName'];</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation
                id="Variable_PrepareValue_109"
                routes-to="Call_Aggregate_Variable_109">
                <cc:steps>
                    <cc:eval id="CopyVarToMsg">
                        <cc:expression>parts[0] = vars[props.inTargetName];</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_109"
                id="Call_Aggregate_Variable_109"
                routes-response-to="Call_CreateLogEntry_Debug_Variable_109"
                store-message="none">
                <cc:set name="inCollate" value="true"/>
                <cc:set name="inBatch" value="false"/>
                <cc:set
                    name="inEntityName"
                    value="(props['inEntityName'] != empty) ? props['inEntityName'] : props['inTargetName']"/>
            </cc:local-out>
            <cc:async-mediation id="Variable_Name_109">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outEntityName'] = props['outEntityName'];</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation id="Validation_103" routes-to="PrepareMapInput_103">
                <cc:steps>
                    <cc:eval id="EvaluateParameters">
                        <cc:expression>props['localIsValuedProperty'] = props['inMapPropertyName'] != empty;&#xd;
propname = props['inMapPropertyName'];&#xd;
props['localIsDefinedProperty'] = props['localIsValuedProperty'] &amp;&amp; context.containsProperty(propname);&#xd;
props['localIsCorrectTypeProperty'] = props['localIsDefinedProperty'] &amp;&amp; (context.getProperty(propname) instanceof java.util.Map);&#xd;
props['localIsNonEmptyMapProperty'] = props['localIsCorrectTypeProperty'] &amp;&amp; !(((java.util.Map)(context.getProperty(propname))).isEmpty());</cc:expression>
                        <cc:expression>props['localIsValuedVariable'] = props['inMapVariableName'] != empty;&#xd;
varname = props['inMapVariableName'];&#xd;
props['localIsDefinedVariable'] = props['localIsValuedVariable'] &amp;&amp; vars.isVariable(varname);&#xd;
props['localIsCorrectTypeVariable'] = props['localIsDefinedVariable'] &amp;&amp; (vars[varname].isXml());&#xd;
props['localIsNonEmptyMapVariable'] = props['localIsCorrectTypeVariable'] &amp;&amp; (vars[varname] != null);</cc:expression>
                    </cc:eval>
                    <cc:validate-exp id="ValidateParameters">
                        <cc:expression
                            error-number="10300"
                            failure-message="Only one (or neither) of the inMapPropertyName and inMapVariableName input parameters should be set.  However, both were provided.">!(props['localIsValuedProperty'] &amp;&amp; props['localIsValuedVariable'])</cc:expression>
                        <cc:expression
                            error-number="10301"
                            failure-message="The inMapPropertyName input parameter was set.  However, a context property with the referenced name [@{props['inMapPropertyName']}] could not be found.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsDefinedProperty'])</cc:expression>
                        <cc:expression
                            error-number="10302"
                            failure-message="The inMapPropertyName input parameter was set.  However, the referenced context property [@{props['inMapPropertyName']}] was not an instance of java.util.Map.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsCorrectTypeProperty'])</cc:expression>
                        <cc:expression
                            error-number="10303"
                            failure-message="The inMapPropertyName input parameter was set.  However, the referenced context property [@{props['inMapPropertyName']}] contained no data.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsNonEmptyMapProperty'])</cc:expression>
                        <cc:expression
                            error-number="10304"
                            failure-message="The inMapVariableName input parameter was set.  However, a context variable with the referenced name [@{props['inMapVariableName']}] could not be found.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsDefinedVariable'])</cc:expression>
                        <cc:expression
                            error-number="10305"
                            failure-message="The inMapVariableName input parameter was set.  However, the referenced context variable [@{props['inMapVariableName']}] was not XML.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsCorrectTypeVariable'])</cc:expression>
                        <cc:expression
                            error-number="10306"
                            failure-message="The inMapVariableName input parameter was set.  However, the referenced context variable [@{props['inMapVariableName']}] was null.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsNonEmptyMapVariable'])</cc:expression>
                    </cc:validate-exp>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Validation_Handler_103"/>
            </cc:async-mediation>
            <cc:async-mediation id="SetHeaders_103" routes-to="Call_Debug_SoapRequest_103">
                <cc:steps>
                    <cc:set-headers id="SetHeaders">
                        <cc:remove-headers/>
                        <cc:add-headers>
                            <cc:add-header
                                name="x-validate-only"
                                value="@{props['inValidateOnly'] == true ? 1 : 0}"/>
                        </cc:add-headers>
                    </cc:set-headers>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="BuildRequest_103" routes-to="Validation_103">
                <cc:parameter
                    default="props['inApiVersion']"
                    documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;"
                    name="inApiVersion"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['inPathToXsltFile']"
                    documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;."
                    name="inPathToXsltFile"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request."
                    name="inMapPropertyName"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example."
                    name="inMapVariableName"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="props['inDebugMode']"
                    documentation="Controls whether or not the SOAP request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="props['inIsAbortOnError']"
                    name="inIsAbortOnError"
                    required="true"
                    type="boolean"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/BuildRequest_103"
                execute-when="!props['inUseMessageRootPartAsRequest']"
                id="Call_BuildRequest_103"
                propagate-abort="true"
                routes-response-to="SetHeaders_103"
                store-message="none">
                <cc:set name="inApiVersion" value="props['inApiVersion']"/>
                <cc:set name="inPathToXsltFile" value="props['inPathToXsltFile']"/>
                <cc:set name="inMapPropertyName" value="props['inMapPropertyName']"/>
                <cc:set name="inMapVariableName" value="props['inMapVariableName']"/>
                <cc:set name="inDebugMode" value="props['inDebugMode']"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            </cc:local-out>
            <cc:async-mediation execute-steps-when="props['inBatch']" id="StoreArchive_109">
                <cc:steps>
                    <cc:store
                        createDocumentReference="true"
                        expiresIn="@{props['globalDocumentRetentionPeriod']}"
                        id="StoreArchive"
                        output="variable"
                        output-variable="localDebugArchive"
                        title="@{props['globalDebugArchiveFilename']}"/>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="BuildRequest_104" routes-to="Validation_104">
                <cc:parameter
                    default="props['inApiVersion']"
                    documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;"
                    name="inApiVersion"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['inPathToXsltFile']"
                    documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;."
                    name="inPathToXsltFile"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request."
                    name="inMapPropertyName"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example."
                    name="inMapVariableName"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="props['inDebugMode']"
                    documentation="Controls whether or not the SOAP request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="props['inIsAbortOnError']"
                    name="inIsAbortOnError"
                    required="true"
                    type="boolean"/>
            </cc:local-in>
            <cc:async-mediation id="Validation_104" routes-to="PrepareMapInput_104">
                <cc:steps>
                    <cc:eval id="EvaluateParameters">
                        <cc:expression>props['localIsValuedProperty'] = props['inMapPropertyName'] != empty;&#xd;
propname = props['inMapPropertyName'];&#xd;
props['localIsDefinedProperty'] = props['localIsValuedProperty'] &amp;&amp; context.containsProperty(propname);&#xd;
props['localIsCorrectTypeProperty'] = props['localIsDefinedProperty'] &amp;&amp; (context.getProperty(propname) instanceof java.util.Map);&#xd;
props['localIsNonEmptyMapProperty'] = props['localIsCorrectTypeProperty'] &amp;&amp; !(((java.util.Map)(context.getProperty(propname))).isEmpty());</cc:expression>
                        <cc:expression>props['localIsValuedVariable'] = props['inMapVariableName'] != empty;&#xd;
varname = props['inMapVariableName'];&#xd;
props['localIsDefinedVariable'] = props['localIsValuedVariable'] &amp;&amp; vars.isVariable(varname);&#xd;
props['localIsCorrectTypeVariable'] = props['localIsDefinedVariable'] &amp;&amp; (vars[varname].isXml());&#xd;
props['localIsNonEmptyMapVariable'] = props['localIsCorrectTypeVariable'] &amp;&amp; (vars[varname] != null);</cc:expression>
                    </cc:eval>
                    <cc:validate-exp id="ValidateParameters">
                        <cc:expression
                            error-number="10400"
                            failure-message="Only one (or neither) of the inMapPropertyName and inMapVariableName input parameters should be set.  However, both were provided.">!(props['localIsValuedProperty'] &amp;&amp; props['localIsValuedVariable'])</cc:expression>
                        <cc:expression
                            error-number="10401"
                            failure-message="The inMapPropertyName input parameter was set.  However, a context property with the referenced name [@{props['inMapPropertyName']}] could not be found.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsDefinedProperty'])</cc:expression>
                        <cc:expression
                            error-number="10402"
                            failure-message="The inMapPropertyName input parameter was set.  However, the referenced context property [@{props['inMapPropertyName']}] was not an instance of java.util.Map.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsCorrectTypeProperty'])</cc:expression>
                        <cc:expression
                            error-number="10403"
                            failure-message="The inMapPropertyName input parameter was set.  However, the referenced context property [@{props['inMapPropertyName']}] contained no data.">!props['localIsValuedProperty'] || (props['localIsValuedProperty'] &amp;&amp; props['localIsNonEmptyMapProperty'])</cc:expression>
                        <cc:expression
                            error-number="10404"
                            failure-message="The inMapVariableName input parameter was set.  However, a context variable with the referenced name [@{props['inMapVariableName']}] could not be found.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsDefinedVariable'])</cc:expression>
                        <cc:expression
                            error-number="10405"
                            failure-message="The inMapVariableName input parameter was set.  However, the referenced context variable [@{props['inMapVariableName']}] was not XML.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsCorrectTypeVariable'])</cc:expression>
                        <cc:expression
                            error-number="10406"
                            failure-message="The inMapVariableName input parameter was set.  However, the referenced context variable [@{props['inMapVariableName']}] was null.">!props['localIsValuedVariable'] || (props['localIsValuedVariable'] &amp;&amp; props['localIsNonEmptyMapVariable'])</cc:expression>
                    </cc:validate-exp>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Validation_Handler_104"/>
            </cc:async-mediation>
            <cc:async-mediation id="SetHeaders_104" routes-to="Call_Debug_SoapRequest_104">
                <cc:steps>
                    <cc:set-headers id="SetHeaders">
                        <cc:remove-headers/>
                        <cc:add-headers>
                            <cc:add-header
                                name="x-validate-only"
                                value="@{props['inValidateOnly'] == true ? 1 : 0}"/>
                        </cc:add-headers>
                    </cc:set-headers>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/BuildRequest_104"
                execute-when="!props['inUseMessageRootPartAsRequest']"
                id="Call_BuildRequest_104"
                propagate-abort="true"
                routes-response-to="SetHeaders_104"
                store-message="none">
                <cc:set name="inApiVersion" value="props['inApiVersion']"/>
                <cc:set name="inPathToXsltFile" value="props['inPathToXsltFile']"/>
                <cc:set name="inMapPropertyName" value="props['inMapPropertyName']"/>
                <cc:set name="inMapVariableName" value="props['inMapVariableName']"/>
                <cc:set name="inDebugMode" value="props['inDebugMode']"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                id="Call_Debug_Finalize"
                routes-response-to="Call_IEP_99"
                store-message="none">
                <cc:set name="inTargetType" value="'finalize'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_DocumentAccessor_Error_110"
                store-message="none">
                <cc:set name="inLogMessage" value="'GetEventDocuments Processing Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while parsing the Get_Event_Documents response.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Info_108"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="'Integration '# String.valueOf(props['inProgressPercentage']) #'% Complete'"/>
                <cc:set name="inLogMessageDetail" value="props['inProgressMessage']"/>
                <cc:set name="inLogLevel" value="'info'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                id="Call_Debug_Finalize_GEH"
                store-message="none">
                <cc:set name="inTargetType" value="'finalize'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_SoapResponse_103"
                routes-response-to="Results_103"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Response__' # props['inWebServiceApplication']"/>
            </cc:local-out>
            <cc:sync-mediation
                execute-steps-when="!message.isNullContentRootPart()"
                id="Properties_InitializeAndFinalize_109"
                routes-to="Properties_PrepareValue_109">
                <cc:request-steps>
                    <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage"/>
                </cc:request-steps>
                <cc:response-steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                    </cc:eval>
                    <cc:copy
                        id="RestoreMsg"
                        input="variable"
                        input-variable="debugTemporaryStorage"
                        output="message"/>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:sync-mediation
                execute-steps-when="!message.isNullContentRootPart()"
                id="Map_InitializeAndFinalize_109"
                routes-to="Map_PrepareValue_109">
                <cc:request-steps>
                    <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage"/>
                </cc:request-steps>
                <cc:response-steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                    </cc:eval>
                    <cc:copy
                        id="RestoreMsg"
                        input="variable"
                        input-variable="debugTemporaryStorage"
                        output="message"/>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:sync-mediation
                execute-steps-when="!message.isNullContentRootPart()"
                id="List_InitializeAndFinalize_109"
                routes-to="List_PrepareValue_109">
                <cc:request-steps>
                    <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage"/>
                </cc:request-steps>
                <cc:response-steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                    </cc:eval>
                    <cc:copy
                        id="RestoreMsg"
                        input="variable"
                        input-variable="debugTemporaryStorage"
                        output="message"/>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:sync-mediation
                execute-steps-when="!message.isNullContentRootPart()"
                id="Set_InitializeAndFinalize_109"
                routes-to="Set_PrepareValue_109">
                <cc:request-steps>
                    <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage"/>
                </cc:request-steps>
                <cc:response-steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                    </cc:eval>
                    <cc:copy
                        id="RestoreMsg"
                        input="variable"
                        input-variable="debugTemporaryStorage"
                        output="message"/>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:async-mediation id="Initialize_109" routes-to="RouteType_109">
                <cc:steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['outEntityName'] = '';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                id="Call_Debug_Initialize_Finalize"
                routes-response-to="Initialize_Handler"
                store-message="none">
                <cc:set name="inTargetType" value="'finalize'"/>
            </cc:local-out>
            <cc:async-mediation id="Teardown_107">
                <cc:steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>// And remove local variables that are no longer required&#xd;
foreach (varname : ['localPreTransformData107', 'localPayload107', 'localXslt107']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_107" routes-to="Teardown_107"/>
            <cc:sync-mediation
                id="Validation_107"
                routes-response-to="Call_Finally_107"
                routes-to="SavePayloadData_107">
                <cc:request-steps>
                    <cc:validate-exp id="ValidateParameters">
                        <cc:expression
                            error-number="10700"
                            failure-message="Input parameters inPayloadDataLocation and inEnrichmentDataLocation were both set to message.  This implies that the message contains both the data payload as well as the mapping data.  Only one can be on the message.">!(props['inPayloadDataLocation'] == 'message' &amp;&amp; props['inEnrichmentDataLocation'] == 'message')</cc:expression>
                        <cc:expression
                            error-number="10701"
                            failure-message="Input parameter inPayloadDataLocation was not &quot;message&quot; and was not located as a variable.  The value must either be &quot;message&quot; or refer to a valid, bound variable.">props['inPayloadDataLocation'] == 'message' || context.variables.isVariable(props.inPayloadDataLocation);</cc:expression>
                        <cc:expression
                            error-number="10702"
                            failure-message="Input parameter inEnrichmentDataLocation was not &quot;message&quot; and was not located as a variable.  The value must either be &quot;message&quot; or refer to a valid, bound variable.">props['inEnrichmentDataLocation'] == 'message' || context.variables.isVariable(props.inEnrichmentDataLocation);</cc:expression>
                    </cc:validate-exp>
                </cc:request-steps>
                <cc:response-steps>
            </cc:response-steps>
            </cc:sync-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_107"
                id="Call_Finally_107"
                store-message="none"/>
            <cc:local-in
                access="public"
                icon="icons/StreamDataMerge.png"
                id="StreamDataMerge"
                routes-to="Validation_107">
                <cc:parameter
                    default="'message'"
                    documentation="Where the main data being enriched and transformed can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found."
                    name="inPayloadDataLocation"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="'globalRaaSResults'"
                    documentation="Where the enrichment data (that would be used to build a map) can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found.  The default value assumes that sub-assembly 102 may have been used and the results are in &quot;globalRaaSResults&quot;, although this need not be the case."
                    name="inEnrichmentDataLocation"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will transform the data from inPayloadDataLocation, enriching and decorating it with data from inEnrichmentDataLocation, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;.  Though this is intended to be a streaming implementation, the responsibility for streaming lies with the developer of the XSLT; this sub-assembly is not streaming unless the XSLT correctly implements it."
                    name="inPathToXsltFile"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="'globalData'"
                    documentation="Where the results of the transformation are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the sub-assembly ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found.  "
                    name="inReturnOutputLocation"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
            </cc:local-in>
            <cc:local-in id="Aggregate_107" routes-to="AggregateData_107">
                <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
                <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
            </cc:local-in>
            <cc:aggregator
                collate-when="props['inCollate']"
                force-batch-on-last-message="false"
                force-batch-when="props['inBatch']"
                id="AggregateData_107">
                <cc:size-batch-strategy batch-size="-1"/>
                <cc:xml-message-content-collater
                    output="variable"
                    output-mimetype="text/xml"
                    output-variable="localPreTransformData107">
                    <cc:header-text>&lt;Results></cc:header-text>
                    <cc:footer-text>&lt;/Results></cc:footer-text>
                </cc:xml-message-content-collater>
            </cc:aggregator>
            <cc:async-mediation
                execute-steps-when="props['inPayloadDataLocation'] == 'message'"
                handle-downstream-errors="true"
                id="SavePayloadData_107"
                routes-to="PrepareEnrichmentData_107">
                <cc:steps>
                    <cc:copy
                        id="CopyMsgToVar"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="localPayload107"/>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_SavePayloadData_Error_107"/>
            </cc:async-mediation>
            <cc:async-mediation
                execute-steps-when="props['inEnrichmentDataLocation'] != 'message'"
                id="PrepareEnrichmentData_107"
                routes-to="Call_Aggregate_EnrichmentData_107">
                <cc:steps>
                    <cc:eval id="MoveVarToMsg">
                        <cc:expression>parts[0] = vars.getVariable(props.inEnrichmentDataLocation);</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_107"
                id="Call_Aggregate_EnrichmentData_107"
                routes-response-to="RestorePayloadData_107"
                store-message="none">
                <cc:set name="inCollate" value="true"/>
                <cc:set name="inBatch" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                execute-steps-when="props['inPayloadDataLocation'] != 'message'"
                id="PreparePayloadData_107"
                routes-to="Call_Aggregate_PayloadData_107">
                <cc:steps>
                    <cc:eval id="MoveVarToMsg">
                        <cc:expression>parts[0] = vars.getVariable(props.inPayloadDataLocation);</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_107"
                id="Call_Aggregate_PayloadData_107"
                routes-response-to="Transform_107"
                store-message="none">
                <cc:set name="inCollate" value="true"/>
                <cc:set name="inBatch" value="true"/>
            </cc:local-out>
            <cc:async-mediation id="Transform_107" routes-to="FinalizeResults">
                <cc:steps>
                    <cc:write id="WriteXSLT" output="variable" output-variable="localXslt107">
                        <cc:message>
                            <cc:static-file input-file="@{props['inPathToXsltFile']}"/>
                        </cc:message>
                    </cc:write>
                    <cc:xslt-plus
                        id="ExecuteTranform"
                        input="variable"
                        input-variable="localPreTransformData107"
                        url="mctx:vars/localXslt107"/>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Call_HandleError_Transform_Error_107"/>
            </cc:async-mediation>
            <cc:async-mediation
                execute-steps-when="props['inReturnOutputLocation'] != 'message'"
                id="FinalizeResults">
                <cc:steps>
                    <cc:eval id="MoveMsgToVar">
                        <cc:expression>vars[props.inReturnOutputLocation] = parts[0];</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_SavePayloadData_Error_107"
                store-message="none">
                <cc:set name="inLogMessage" value="'XSLT Preparation Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred managing the payload and enrichment data between the message root and variables.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_107'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Transform_Error_107"
                store-message="none">
                <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred executing the payload transformation using enrichment data.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_107'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:sync-mediation
                id="MainFlowControl"
                routes-response-to="Call_IEP_90"
                routes-to="Call_Main">
                <cc:request-steps/>
                <cc:response-steps>
                    <cc:eval id="ResetAbort">
                        <cc:expression>context.setAbort(false);</cc:expression>
                    </cc:eval>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:async-mediation
                id="Properties_PrepareValue_109"
                routes-to="Properties_Splitter_109">
                <cc:steps>
                    <cc:write id="PropsToXML" output-mimetype="text/xml">
                        <cc:message>
                            <cc:text>&lt;root>&#xd;
@foreach{props[props.inTargetName] as propname}&#xd;
	&lt;p>&#xd;
		&lt;k>@{propname}&lt;/k>&#xd;
		&lt;v>@{props[propname]}&lt;/v>&#xd;
	&lt;/p>&#xd;
@end{}&#xd;
&lt;/root></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
            </cc:async-mediation>
            <cc:sync-mediation
                execute-steps-when="!message.isNullContentRootPart()"
                id="Variable_InitializeAndFinalize_109"
                routes-to="Variable_PrepareValue_109">
                <cc:request-steps>
                    <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage"/>
                </cc:request-steps>
                <cc:response-steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                    </cc:eval>
                    <cc:copy
                        id="RestoreMsg"
                        input="variable"
                        input-variable="debugTemporaryStorage"
                        output="message"/>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:async-mediation id="Map_PrepareValue_109" routes-to="Map_Splitter_109">
                <cc:steps>
                    <cc:write id="MapToXML" output-mimetype="text/xml">
                        <cc:message>
                            <cc:text>&lt;root>&#xd;
@foreach{props[props.inTargetName].keySet() as key}&#xd;
	&lt;p>&#xd;
		&lt;k>@{key}&lt;/k>&#xd;
		&lt;v>@{props[props.inTargetName].get(key)}&lt;/v>&#xd;
	&lt;/p>&#xd;
@end{}&#xd;
&lt;/root></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation id="List_PrepareValue_109" routes-to="List_Splitter_109">
                <cc:steps>
                    <cc:write id="ListToXML" output-mimetype="text/xml">
                        <cc:message>
                            <cc:text>&lt;root>&#xd;
@foreach{props[props.inTargetName] as e}&#xd;
	&lt;e>@{e}&lt;/e>&#xd;
@end{}&#xd;
&lt;/root></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation id="Set_PrepareValue_109" routes-to="Set_Splitter_109">
                <cc:steps>
                    <cc:write id="SetToXML" output-mimetype="text/xml">
                        <cc:message>
                            <cc:text>&lt;root>&#xd;
@foreach{props[props.inTargetName] as e}&#xd;
	&lt;e>@{e}&lt;/e>&#xd;
@end{}&#xd;
&lt;/root></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation
                execute-steps-when="props['inPayloadDataLocation'] == 'message'"
                id="RestorePayloadData_107"
                routes-to="PreparePayloadData_107">
                <cc:steps>
                    <cc:copy
                        id="CopyVarToMsg"
                        input="variable"
                        input-variable="localPayload107"
                        output="message"
                        output-mimetype="text/xml"/>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_NormalizeResponse_Error_102"
                store-message="none">
                <cc:set name="inLogMessage" value="'SOAP Unwrap Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while unwrapping the RaaS results from the SOAP envelope.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Response__' # props['inReportServiceAlias']"/>
            </cc:local-out>
            <cc:async-mediation
                execute-steps-when="props['inReturnResults'] == 'variable'"
                id="NormalizeResponse_102">
                <cc:steps>
                    <cc:xslt-plus
                        id="UnwrapSoap"
                        output-mimetype="text/xml"
                        url="xslt/sa102/SA102_UnwrapSoapTransform.xsl"/>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_NormalizeResponse_Error_102"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_HttpOut_Error_102"
                store-message="none">
                <cc:set name="inLogMessage" value="'RaaS Execution Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                continue-after-error="rewind"
                handle-downstream-errors="true"
                id="HttpOut_Catch_102"
                routes-to="HttpOut_102">
                <cc:steps/>
                <cc:send-error id="CatchError" routes-to="Call_HandleError_HttpOut_Error_102"/>
            </cc:async-mediation>
            <cc:http-out
                endpoint="@{intsys.reportService.getEndpoint(props.inReportServiceAlias)}"
                http-method="POST"
                id="HttpOut_102"
                routes-response-to="NormalizeResponse_102"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_SoapRequest_102"
                routes-response-to="HttpOut_Catch_102"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Request__' # props['inReportServiceAlias']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_ComposeRequest_Error_102"
                store-message="none">
                <cc:set name="inLogMessage" value="'RaaS Preparation Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while preparing a reports-as-a-service call.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:local-in id="ExecuteWithRest_102" routes-to="Call_Debug_RaaSRequest_102">
                <cc:parameter
                    default="props['localRestUrl']"
                    documentation="The full rest query including all querystring parameters"
                    name="inRestUrl"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['inDebugMode']"
                    documentation="Controls whether or not the REST request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
            </cc:local-in>
            <cc:local-in
                id="ExecuteWithSoap_102"
                routes-to="Call_CreateLogEntry_ExecuteWithSoap_Info_102">
                <cc:parameter
                    default="props['inReportServiceAlias']"
                    documentation="The Report Service configuration from which to retrieve results."
                    name="inReportServiceAlias"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['inPropertyNameReportPromptMap']"
                    documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  If the report is not parameterized, then leave this input parameter empty.  If setting this input parameter though, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap."
                    name="inPropertyNameReportPromptMap"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['inDebugMode']"
                    documentation="Controls whether or not the REST request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
            </cc:local-in>
            <cc:route id="ChooseProtocol_102">
                <cc:mvel-strategy>
                    <cc:choose-route expression="props['localIsValidUrlLength']" route="REST"/>
                    <cc:choose-route expression="true" route="SOAP"/>
                </cc:mvel-strategy>
                <cc:sub-route name="REST" routes-to="Call_ExecuteWithRest_102"/>
                <cc:sub-route name="SOAP" routes-to="Call_ExecuteWithSoap_102"/>
            </cc:route>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_ExecuteWithSoap_Info_102"
                routes-response-to="ComposeRequest_102"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="'Executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias using SOAP.'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'The URL constructed including querystring parameters exceed the maximum URL length for RESTful RaaS calls of 16000 Bytes.  Switching to use SOAP as protocol.'"/>
                <cc:set name="inLogLevel" value="'info'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ExecuteWithRest_102"
                id="Call_ExecuteWithRest_102"
                routes-response-to="Results_102"
                store-message="none">
                <cc:set name="inRestUrl" value="props['localRestUrl']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ExecuteWithSoap_102"
                id="Call_ExecuteWithSoap_102"
                routes-response-to="Results_102"
                store-message="none">
                <cc:set
                    name="inPropertyNameReportPromptMap"
                    value="props['inPropertyNameReportPromptMap']"/>
                <cc:set name="inReportServiceAlias" value="props['inReportServiceAlias']"/>
                <cc:set name="inDebugMode" value="props['inDebugMode']"/>
            </cc:local-out>
            <cc:async-mediation
                id="ComposeRequest_102"
                routes-to="Call_Debug_SoapRequest_102">
                <cc:steps>
                    <cc:write id="WriteSoapRequest">
                        <cc:message>
                            <cc:text>&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:wd="urn:com.workday/bsvc" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
            &lt;soapenv:Header>
                &lt;wsse:Security soapenv:mustUnderstand="1">
                    &lt;wsse:UsernameToken>
                        &lt;wsse:Username>@{props['wss.usernametoken.username']}&lt;/wsse:Username>
                        &lt;wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText">@{props['wss.usernametoken.password']}&lt;/wsse:Password>
                    &lt;/wsse:UsernameToken>
                &lt;/wsse:Security>
            &lt;/soapenv:Header>
            &lt;soapenv:Body>
                &lt;wd:Execute_Report>
</cc:text>
                            <cc:text>			&lt;wd:Report_Parameters xmlns:wd="urn:com.workday/bsvc">&#xd;
			@{com.workday.custom.int0025.int0025102.ParameterMapHelper.getSoapRequestParameters(context, props.inPropertyNameReportPromptMap)}&#xd;
			&lt;/wd:Report_Parameters></cc:text>
                            <cc:text>		&lt;/wd:Execute_Report>&#xd;
	&lt;/soapenv:Body>&#xd;
&lt;/soapenv:Envelope></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_ComposeRequest_Error_102"/>
            </cc:async-mediation>
            <cc:local-in
                access="public"
                icon="icons/AddReportPromptFromProperty.png"
                id="AddReportPromptFromProperty"
                routes-to="InitializeAndFinalize_Property_101">
                <cc:parameter
                    documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  When setting this input parameter, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap.  This data structure can be easily created through the com.workday.custom.int0025.int0025102.ParameterMapHelper class and initializeParameterMap method and then subsequently managed with the SA101 sub-assemblies."
                    name="inPropertyNameReportPromptMap"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The XML name of the report prompt as specified on the Prompts tab of the Custom Report."
                    name="inReportPromptName"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The Id type of the value being provided on the prompt if the value is an instance reference.  For example, if the report prompt accepted workers and you were sending employees, this value might be 'Employee_ID'.  If the report prompt is a non-instance value, this parameter may be left empty / omitted."
                    name="inReferenceIdType"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="The value to be assigned to the report prompt.  This may be a numeric value, string value or instance reference id."
                    name="inValue"
                    required="true"/>
            </cc:local-in>
            <cc:local-in
                icon="icons/AddReportPromptFromXml.png"
                id="AddReportPromptFromXml"
                routes-to="InitializeAndFinalize_Xml_101">
                <cc:parameter
                    documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  When setting this input parameter, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap.  This data structure can be easily created through the com.workday.custom.int0025.int0025102.ParameterMapHelper class and initializeParameterMap method and then subsequently managed with the SA101 sub-assemblies."
                    name="inPropertyNameReportPromptMap"
                    required="true"/>
                <cc:parameter
                    documentation="The XML name of the report prompt as specified on the Prompts tab of the Custom Report."
                    name="inReportPromptName"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The Id type of the value being provided on the prompt if the value is an instance reference.  For example, if the report prompt accepted workers and you were sending employees, this value might be 'Employee_ID'.  If the report prompt is a non-instance value, this parameter may be left empty / omitted."
                    name="inReferenceIdType"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="The location where the XML data containing the parameter values can be found.  This may be either on the Message root or in a variable.  In the former case, specify the value of this parameter as the literal 'message'.  Otherwise, if the value is found in a variable, please set this parameter to the name of that variable."
                    name="inParameterDataLocation"
                    required="true"
                    type="string"
                    validation="props['inParameterDataLocation'] == 'message' || vars.isVariable(props.inParameterDataLocation)"/>
                <cc:parameter
                    documentation="The XPath query that will select the values from the XML data to be used as report parameters."
                    name="inQueryToValue"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="XPath expression which can optionally be executed against the elements returned by QueryToEntry in order to determine if those entries should be stored in the map"
                    name="inEntryFilter"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="props['globalIsDebugMode']"
                    documentation="Controls whether or not the dynamic XSLT is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_InitializeAndFinalize_Xml_Error_101"
                store-message="none">
                <cc:set name="inLogMessage" value="'RaaS Parameter Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while preparing a reports-as-a-service call.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:sync-mediation
                continue-after-error="rewind"
                handle-downstream-errors="false"
                id="InitializeAndFinalize_Xml_101"
                routes-response-to="Call_Finally_Multiple_101"
                routes-to="NormalizeMapValues_Xml_101">
                <cc:request-steps>
                    <cc:eval id="EvaluateParameters">
                        <cc:expression>props['localIsPromptsMap'] = context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map;</cc:expression>
                    </cc:eval>
                    <cc:validate-exp id="ValidateParameters">
                        <cc:expression
                            error-number="10101"
                            failure-message="The value contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap is not a map.">props['localIsPromptsMap']</cc:expression>
                    </cc:validate-exp>
                </cc:request-steps>
                <cc:response-steps/>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_InitializeAndFinalize_Xml_Error_101"/>
            </cc:sync-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_InitializeAndFinalize_Property_Error_101"
                store-message="none">
                <cc:set name="inLogMessage" value="'RaaS Parameter Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while preparing a reports-as-a-service call.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:sync-mediation
                continue-after-error="rewind"
                handle-downstream-errors="false"
                id="InitializeAndFinalize_Property_101"
                routes-response-to="Call_Finally_Single_101"
                routes-to="NormalizeMapValues_Property_101">
                <cc:request-steps>
                    <cc:eval id="EvaluateParameters">
                        <cc:expression>props['localIsPromptsMap'] = context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map;</cc:expression>
                    </cc:eval>
                    <cc:validate-exp id="ValidateParameters">
                        <cc:expression
                            error-number="10100"
                            failure-message="The value contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap is not a map.">props['localIsPromptsMap']</cc:expression>
                    </cc:validate-exp>
                </cc:request-steps>
                <cc:response-steps/>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_InitializeAndFinalize_Property_Error_101"/>
            </cc:sync-mediation>
            <cc:async-mediation id="Teardown_101">
                <cc:steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localIsPromptsMap','localKey','localValue']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                        <cc:expression>foreach (varname : ['localXslt101']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_101" routes-to="Teardown_101"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101"
                id="Call_Finally_Single_101"
                store-message="none"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101"
                id="Call_Finally_Multiple_101"
                store-message="none"/>
            <cc:async-mediation
                id="NormalizeMapValues_Property_101"
                routes-to="Validate_Property_101">
                <cc:steps>
                    <cc:eval id="SetValues">
                        <cc:expression>props['localKey'] = (props['inReferenceIdType'] == empty) ? props['inReportPromptName'] : props['inReportPromptName'] # '!' # props['inReferenceIdType'];</cc:expression>
                        <cc:expression>if (props['inValue'] instanceof java.lang.Object) {&#xd;
	props['localValue'] = props['inValue'];&#xd;
} else {&#xd;
	props['localValue'] = String.valueOf(props['inValue']);&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_NormalizeMapValues_Property_Error_101"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_NormalizeMapValues_Property_Error_101"
                store-message="none">
                <cc:set name="inLogMessage" value="'RaaS Prompt Key/Value Pair Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'A problem was encountered while composing the key and value data for map storage on the ' # props['inReportPromptName'] # ' report prompt.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Validate_Property_Error_101"
                store-message="none">
                <cc:set name="inLogMessage" value="'Duplicate Map Key'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while validating a reports-as-a-service prompt key/value pair.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                id="Validate_Property_101"
                routes-to="UpdateMap_Property_101">
                <cc:steps>
                    <cc:validate-exp id="ValidateKey">
                        <cc:expression
                            error-number="10102"
                            failure-message="The map already contains a key named @{props['localKey']}.">!(((java.util.Map)props[props.inPropertyNameReportPromptMap]).containsKey(props.localKey))</cc:expression>
                    </cc:validate-exp>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_Validate_Property_Error_101"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_UpdateMap_Property_Error_101"
                store-message="none">
                <cc:set name="inLogMessage" value="'Map Update Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'A problem was encountered while writing the value data under the ' # props['localKey'] # ' report prompt in the ' # props['inPropertyNameReportPromptMap'] # ' map.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation id="UpdateMap_Property_101">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>((java.util.Map)props[props.inPropertyNameReportPromptMap]).put(props['localKey'], props['localValue']);</cc:expression>
                    </cc:eval>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_UpdateMap_Property_Error_101"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_UpdateMap_Xml_Error_101"
                store-message="none">
                <cc:set name="inLogMessage" value="'Map Update Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'A problem was encountered while writing the value data under the ' # props['localKey'] # ' report prompt in the ' # props['inPropertyNameReportPromptMap'] # ' map.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation id="UpdateMap_Xml_101">
                <cc:steps>
                    <cc:xslt-plus id="BuildList" url="mctx:vars/localXslt101"/>
                    <cc:eval id="UpdateValues">
                        <cc:expression>((java.util.Map)props[props.inPropertyNameReportPromptMap]).put(props['localKey'], props['localValue']);</cc:expression>
                    </cc:eval>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_UpdateMap_Xml_Error_101"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Validate_Xml_Error_101"
                store-message="none">
                <cc:set name="inLogMessage" value="'Duplicate Map Key'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while validating a reports-as-a-service prompt key/value pair.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation id="Validate_Xml_101" routes-to="UpdateMap_Xml_101">
                <cc:steps>
                    <cc:validate-exp id="Validations">
                        <cc:expression
                            error-number="10104"
                            failure-message="The map already contains a key named @{props['localKey']}.">!(((java.util.Map)props[props.inPropertyNameReportPromptMap]).containsKey(props.localKey))</cc:expression>
                        <cc:expression
                            error-number="10105"
                            failure-message="The referenced data for transformation into Report Prompt data indicated at @{props['inParameterDataLocation']} is not in XML format.">parts[0].isXml()</cc:expression>
                    </cc:validate-exp>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_Validate_Xml_Error_101"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_NormalizeMapValues_Xml_Error_101"
                store-message="none">
                <cc:set name="inLogMessage" value="'RaaS Prompt Key/Value Pair Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'A problem was encountered while composing the key and value data for map storage on the ' # props['inReportPromptName'] # ' report prompt.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                id="NormalizeMapValues_Xml_101"
                routes-to="Call_Debug_Xslt_101">
                <cc:steps>
                    <cc:eval id="SetValues">
                        <cc:expression>props['localKey'] = (props['inReferenceIdType'] == empty) ? props['inReportPromptName'] : props['inReportPromptName'] # '!' # props['inReferenceIdType'];</cc:expression>
                        <cc:expression>props['localValue'] = new java.util.ArrayList();</cc:expression>
                    </cc:eval>
                    <cc:write id="WriteXslt" output="variable" output-variable="localXslt101">
                        <cc:message>
                            <cc:text>&lt;?xml version="1.0" encoding="UTF-8"?>&#xd;
&lt;xsl:stylesheet version="3.0" &#xd;
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&#xd;
    xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"&#xd;
    xmlns:wd="urn:com.workday/bsvc"&#xd;
    xmlns:tube="java:com.capeclear.mediation.impl.cc.MediationTube"&#xd;
    xmlns:ctx="java:com.capeclear.mediation.MediationContext"&#xd;
    xmlns:xs="http://www.w3.org/2001/XMLSchema"&#xd;
    xmlns:jlist="java:java.util.List"&#xd;
    xmlns:jt="http://saxon.sf.net/java-type"&#xd;
    xmlns:this="urn:this">&#xd;
    &#xd;
    &lt;xsl:param name="inQueryToValue" as="xs:string"/>&#xd;
    &#xd;
    &lt;xsl:mode streamable="no" on-no-match="shallow-skip"/>&#xd;
    &#xd;
    &lt;!-- Obtain the current MediationContext in use in the assembly -->&#xd;
    &lt;xsl:variable name="ctx" select="tube:getCurrentMediationContext()"/>&#xd;
    &#xd;
    &lt;!-- Retrieve the Java List stored in the context property localValue -->&#xd;
    &lt;xsl:variable name="list" select="ctx:getProperty($ctx, 'localValue')" as="jt:java.util.List"/>&#xd;
    &#xd;
    &lt;xsl:template match="/">&#xd;
        &lt;ListHelper>&#xd;
            &lt;!-- Now process the input file.  The EntryFilter variable can then be optionally used to only select those entries matching that value.  The filter can only navigate the descendant axis since only the node and and descendants returned by the QueryToEntry expression are brought into memory -->&#xd;
            &lt;xsl:apply-templates select="@{props['inQueryToValue']}@if{props['inEntryFilter'] != empty}[@{props['inEntryFilter']}]@end{}"/>    		&#xd;
        &lt;/ListHelper>&#xd;
    &lt;/xsl:template>&#xd;
    &#xd;
    &lt;!-- Process each entry -->&#xd;
    &lt;xsl:template match="@{props['inQueryToValue']}">&#xd;
        &lt;xsl:variable name="value"	 select="./text()" as="xs:string"/>&#xd;
        &#xd;
		&lt;xsl:value-of select="jlist:add($list, $value)"/>&#xd;
    &lt;/xsl:template>&#xd;
&lt;/xsl:stylesheet></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_NormalizeMapValues_Xml_Error_101"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_PrepareInputData_Xml_Error_101"
                store-message="none">
                <cc:set name="inLogMessage" value="'Map Preparation Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'A problem was encountered while moving the value data from the ' # props['inParameterDataLocation'] # ' variable to the message root for extraction.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
                <cc:set name="inIsAbortOnError" value="true"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                execute-steps-when="props['inParameterDataLocation'] != 'message'"
                id="PrepareInputData_Xml_101"
                routes-to="Validate_Xml_101">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>parts[0] = vars[props.inParameterDataLocation];</cc:expression>
                    </cc:eval>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_PrepareInputData_Xml_Error_101"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_Xslt_101"
                routes-response-to="PrepareInputData_Xml_101"
                store-message="none">
                <cc:set name="inTargetType" value="'variable'"/>
                <cc:set name="inTargetName" value="'localXslt101'"/>
            </cc:local-out>
            <cc:local-in
                access="public"
                icon="icons/HandleError.png"
                id="HandleError"
                routes-to="Call_CreateLogEntry_109">
                <cc:parameter
                    documentation="Value passed to CreateLogEntry's inLogMessage parameter."
                    name="inLogMessage"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="Value passed to CreateLogEntry's inLogMessageDetail parameter."
                    name="inLogMessageDetail"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="Value passed to CreateLogEntry's inLogReferenceId parameter."
                    name="inLogReferenceId"
                    required="false"
                    type="string"/>
                <cc:parameter
                    documentation="Value passed to CreateLogEntry's inLogLevel parameter.  Validation is performed by CreateLogEntry."
                    name="inLogLevel"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="context.errorComponentId"
                    documentation="Value passed to CreateLogEntry's inExtraLocalIn parameter."
                    name="inExtraLocalIn"
                    required="false"/>
                <cc:parameter
                    documentation="Value passed to CreateLogEntry's inExtraRecordNumber parameter."
                    name="inExtraRecordNumber"
                    required="false"/>
                <cc:parameter
                    default="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"
                    documentation="Value passed to CreateLogEntry's inExtraSupportData parameter."
                    name="inExtraSupportData"
                    required="false"/>
                <cc:parameter
                    default="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"
                    documentation="Value passed to CreateLogEntry's inExtraErrorCode parameter."
                    name="inExtraErrorCode"
                    required="false"/>
                <cc:parameter
                    documentation="The sub-assembly endpoint to call for clean-up of properties and/or variables."
                    name="inFinallyEndpoint"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler.  In order for this parameter to have an effect of aborting the sub-assembly from which it was called, the Propagate Abort setting on the Advanced tab of the calling Local-Out component must be set to true."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
                <cc:parameter
                    default="false"
                    documentation="When set to true, clears the residual error details by setting a null exception."
                    name="inIsResetError"
                    required="false"
                    type="boolean"/>
                <cc:parameter
                    default="props['globalIsDebugMode']"
                    documentation="Controls whether or not the dynamic XSLT is output on debug."
                    name="inIncludeDebugOutput"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="'message'"
                    documentation="The type of information to be output to the log."
                    name="inTargetType"
                    required="props['inIncludeDebugOutput']"
                    type="string"
                    validation="props['globalDebugTargetTypeParameterValidation'].contains(props['inTargetType'])"/>
                <cc:parameter
                    documentation="The reference name to use for single-named output types selected on inTargetType.  Required when inTargetType is one of: property, variable, list, map, or set."
                    name="inTargetName"
                    required="false"
                    type="string"
                    validation="props['globalDebugTargetNameParameterValidation'].contains(props['inTargetType']) &amp;&amp;&#xd;&#xa;(props['inTargetName'] != empty || props['inEntityName'] != empty)"/>
                <cc:parameter
                    documentation="A specific filename to use when exporting the message or variable content to a file zipped in a consolidated archive.  This is optional and only used when inTargetType is &quot;message&quot; or &quot;variable&quot;."
                    name="inEntityName"
                    required="false"
                    type="string"/>
                <cc:out-parameter
                    documentation="If a file has been written to the debug archive, the name of that file will be returned for further reference in logging messages."
                    name="outEntityName"/>
            </cc:local-in>
            <cc:local-out
                endpoint="@{props['inFinallyEndpoint']}"
                execute-when="props['inFinallyEndpoint'] != empty"
                id="Call_Finally_109"
                routes-response-to="Handler_109"
                store-message="none"/>
            <cc:async-mediation id="Handler_109" routes-to="AbortOnError_109">
                <cc:steps>
                    <cc:eval id="HandleError">
                        <cc:expression>if (props.containsKey('inIsResetError') &amp;&amp; props.inIsResetError) { context.setException(null); }</cc:expression>
                        <cc:expression>context.setErrorHandled(true);</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation
                execute-steps-when="props['inIsAbortOnError']"
                id="AbortOnError_109">
                <cc:steps>
                    <cc:eval id="SetAbort">
                        <cc:expression>context.setAbort(true);</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_109"
                routes-response-to="Call_Debug_109"
                store-message="none">
                <cc:set name="inLogMessage" value="props.inLogMessage"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="if (context.containsProperty('inLogMessageDetail')) {&#xd;&#xa;&#x9;(props['inLogMessageDetail'] != empty) ? props['inLogMessageDetail'] : ''&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
                <cc:set
                    name="inLogReferenceId"
                    value="if (context.containsProperty('inLogReferenceId')) {&#xd;&#xa;&#x9;(props['inLogReferenceId'] != empty) ? props['inLogReferenceId'] : ''&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
                <cc:set name="inLogLevel" value="props.inLogLevel"/>
                <cc:set
                    name="inExtraLocalIn"
                    value="if (context.containsProperty('inExtraLocalIn')) {&#xd;&#xa;&#x9;props['inExtraLocalIn']&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
                <cc:set
                    name="inExtraRecordNumber"
                    value="if (context.containsProperty('inExtraRecordNumber')) {&#xd;&#xa;&#x9;props['inExtraRecordNumber']&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
                <cc:set
                    name="inExtraSupportData"
                    value="if (context.containsProperty('inExtraSupportData')) {&#xd;&#xa;&#x9;props['inExtraSupportData']&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="if (context.containsProperty('inExtraErrorCode')) {&#xd;&#xa;&#x9;props['inExtraErrorCode']&#xd;&#xa;} else {&#xd;&#xa;&#x9;''&#xd;&#xa;}"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inIncludeDebugOutput'] &amp;&amp; props['inTargetType'] != empty"
                id="Call_Debug_109"
                routes-response-to="Call_Finally_109"
                store-message="none">
                <cc:set name="inTargetType" value="props['inTargetType']"/>
                <cc:set name="inTargetName" value="props['inTargetName']"/>
                <cc:set name="inEntityName" value="props['inEntityName']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode'] || props['inSaveResultsToIntegrationEvent']"
                id="Call_Debug_Result_102"
                store-message="none">
                <cc:set name="inTargetType" value="props['inTargetType']"/>
                <cc:set
                    name="inTargetName"
                    value="props['inReturnResults'] == 'message' ? null : 'globalRaaSResults'"/>
                <cc:set
                    name="inEntityName"
                    value="'RAAS-Results__' # props['inReportServiceAlias']"/>
            </cc:local-out>
            <cc:local-in id="SetupGlobal" routes-to="InitializeCoreStarterKit_109"/>
            <cc:local-in
                access="public"
                icon="icons/InitializeFrameworkThenRunMain.png"
                id="InitializeFrameworkThenRunMain"
                routes-to="Initialize">
                <cc:parameter
                    default="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Main'"
                    documentation="This parameter value will define the main flow and logic processing of the integration.  This is where all of the requirements-specific work will happen in between the StarterKit framework initialization and finalization."
                    name="inMainEndpoint"
                    required="true"
                    type="string"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/InitializeFrameworkThenRunMain"
                id="Call_InitializeFrameworkThenRunMain"
                store-message="none"
                unset-properties="false">
                <cc:set name="inMainEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Main'"/>
            </cc:local-out>
            <cc:local-in
                access="public"
                icon="icons/GetDISResults.png"
                id="GetDISResults"
                routes-to="GetEventDocuments_114">
                <cc:parameter
                    default="lp.isSet() ? lp.getIntegrationEventWID() : null"
                    documentation="WID of the Integration Event from which the documents will be queried.  This is typically the current event, and as such, is defaulted to the current event WID.  However, changing this WID enables retrieving documents from another related event for processing."
                    name="inEventWID"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="Specifies a Document Tag for filtering the input files on the Integration Event in addition to the default &quot;Data - Partial&quot; used by DIS.  &quot;Data - Partial&quot; is assumed and should not be provided.  If no additional tag is specified, then only the &quot;Data - Partial&quot; tag will be used."
                    name="inRetrievalDocTag"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="'variable'"
                    documentation="How the DIS results are returned to the caller, either on the message if the value is 'message', or in the 'globalDISResults' variable if the value is 'variable', which is the default."
                    name="inReturnResults"
                    required="true"
                    type="string"
                    validation="props['inReturnResults'] == 'variable' || props['inReturnResults'] == 'message'"/>
                <cc:parameter
                    default="props['globalIsDebugMode']"
                    documentation="Controls whether or not the DIS results are output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://wcc/GetEventDocuments"
                id="GetEventDocuments_114"
                routes-response-to="PrepareFileResults_114">
                <cc:set name="ie.event.wid" value="props['inEventWID']"/>
            </cc:local-out>
            <cc:sync-mediation
                id="InitializeAndFinalize_114"
                routes-response-to="Call_Aggregate_Finalize_114"
                routes-to="Call_Debug_Property_114">
                <cc:request-steps>
            </cc:request-steps>
                <cc:response-steps>
            </cc:response-steps>
            </cc:sync-mediation>
            <cc:async-mediation id="LoadFile_114" routes-to="Call_Aggregate_Append_114">
                <cc:steps>
                    <cc:copy
                        id="CopyVarToMsg"
                        input="variable"
                        input-variable="wd.retrieve.variable"/>
                </cc:steps>
            </cc:async-mediation>
            <cc:route id="RetrieveFiles_114">
                <cc:doc-iterator labels="@{props['localLabels']}" sort-by="FILENAME_ASCENDING"/>
                <cc:sub-route name="Route" routes-to="Call_Debug_Variable_114"/>
            </cc:route>
            <cc:async-mediation id="Teardown_114">
                <cc:steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localLabels','localFileCount']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_114" routes-to="Teardown_114"/>
            <cc:aggregator
                collate-when="props['inCollate']"
                force-batch-on-last-message="false"
                force-batch-when="props['inBatch']"
                id="AggregateFile_114">
                <cc:size-batch-strategy batch-size="-1"/>
                <cc:xml-message-content-collater
                    output="message"
                    output-mimetype="text/xml"
                    xpath="*/*">
                    <cc:header-text>&lt;DISRoot xmlns:tdf="urn:com.workday/tdf"></cc:header-text>
                    <cc:footer-text>&lt;/DISRoot></cc:footer-text>
                </cc:xml-message-content-collater>
            </cc:aggregator>
            <cc:local-in id="Aggregate_114" routes-to="AggregateFile_114">
                <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
                <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_114"
                id="Call_Aggregate_Append_114"
                store-message="none">
                <cc:set name="inCollate" value="true"/>
                <cc:set name="inBatch" value="false"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_114"
                id="Call_Aggregate_Finalize_114"
                routes-response-to="Call_Debug_Message_114"
                store-message="none">
                <cc:set name="inCollate" value="false"/>
                <cc:set name="inBatch" value="true"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_114"
                id="Call_Finally_114"
                store-message="none">
            
            
            
            
            
            
            
        </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Results_Error_114"
                store-message="none">
                <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while copying the DIS results from the message rootpart to variable globalDISResults.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_114'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set name="inEntityName" value="'DISResults.xml'"/>
            </cc:local-out>
            <cc:async-mediation
                execute-steps-when="props['inReturnResults'] == 'variable'"
                id="Results_114"
                routes-to="Call_Finally_114">
                <cc:steps>
                    <cc:copy
                        id="CopyMsgToVar"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="globalDISResults"/>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_114"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_Property_114"
                routes-response-to="RetrieveFiles_114"
                store-message="none">
                <cc:set name="inTargetType" value="'property'"/>
                <cc:set name="inTargetName" value="'localLabels'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_Variable_114"
                routes-response-to="LoadFile_114"
                store-message="none">
                <cc:set name="inTargetType" value="'variable'"/>
                <cc:set name="inTargetName" value="'wd.retrieve.variable'"/>
                <cc:set name="inEntityName" value="'DIS_Partial_File'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_Message_114"
                routes-response-to="Results_114"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set name="inEntityName" value="'DIS_Aggregated_File'"/>
            </cc:local-out>
            <cc:async-mediation
                id="RetrieveMessage_112"
                routes-to="Call_CreateLogEntry_Message_112">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['localLogMessage'] = props['localLogIterator'].next()</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:route id="LoopOverMessages_112">
                <cc:loop-strategy condition="props['localLogIterator'].hasNext()"/>
                <cc:sub-route name="Loop" routes-to="RetrieveMessage_112"/>
            </cc:route>
            <cc:sync-mediation
                handle-downstream-errors="true"
                id="InitializeAndFinalize_112"
                routes-to="LoopOverMessages_112">
                <cc:request-steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props.localLogIterator = new com.workday.custom.int0025.int0025112.ObjectIterator(props.inLogIterator)</cc:expression>
                        <cc:expression>props.localHasMessages = props.localLogIterator.hasNext()</cc:expression>
                    </cc:eval>
                </cc:request-steps>
                <cc:response-steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (name: {'localHasMessages', 'localLogMessage', 'localLogIterator'}) { context.removeProperty(name) } </cc:expression>
                    </cc:eval>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:local-in
                access="private"
                id="CloudLogMessages_112"
                routes-to="InitializeAndFinalize_112">
                <cc:parameter
                    documentation="An instance of Iterator&lt;CloudLogAdapter> which will be used to iterate over all the messages to be placed in the cloud-log"
                    name="inLogIterator"
                    required="true"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Message_112"
                store-message="none">
                <cc:set name="inLogMessage" value="props['localLogMessage'].message"/>
                <cc:set name="inLogMessageDetail" value="props['localLogMessage'].details"/>
                <cc:set name="inLogReferenceId" value="props['localLogMessage'].referenceId"/>
                <cc:set
                    name="inLogLevel"
                    value="String.valueOf(props['localLogMessage'].level)"/>
            </cc:local-out>
            <cc:local-in
                access="public"
                icon="icons/CloudLogETVXTTMessages.png"
                id="CloudLogETVXTTMessages"
                routes-to="InitializeAndFinalize_ETVXTT_112">
                <cc:parameter
                    default="props['etv.messages']"
                    documentation="An instance of ETVInfoCollection"
                    name="inMessages"
                    required="false"
                    validation="props['inMessages'] instanceof com.workday.mediation.impl.mediators.etv.ETVInfoCollection"/>
                <cc:parameter
                    default="false"
                    documentation="Specifies whether the collection should be cleared after it is output to the log.  The default is to be cleared."
                    name="inIsClearMessages"
                    required="false"
                    type="boolean"/>
                <cc:parameter
                    default="'INFO'"
                    documentation="Minimum severity level to be reported.  Defaults to INFO"
                    name="inMinLogLevel"
                    required="false"
                    validation="['INFO','WARNING','ERROR','CRITICAL'] contains props['inMinLogLevel']"/>
                <cc:out-parameter
                    documentation="Boolean value that indicates whether an error or critical condition was detected"
                    name="etv.has.error"/>
                <cc:out-parameter
                    documentation="Number of messages reported on the current invocation"
                    name="etv.reported.messages"/>
                <cc:out-parameter
                    documentation="Total number of messages reported during the current launch"
                    name="etv.total.reported.messages"/>
            </cc:local-in>
            <cc:local-in
                access="public"
                icon="icons/CloudLogXSLTMessages.png"
                id="CloudLogXSLTMessages"
                routes-to="InitializeAndFinalize_XSLT_112">
                <cc:parameter
                    default="props['xsltstep.messages']"
                    documentation="An instance of java.util.List which contains the messages"
                    name="inMessages"
                    required="true"
                    validation="props['inMessages'] instanceof java.util.List"/>
                <cc:parameter
                    default="true"
                    documentation="Specifies whether the inXSLTMessages list should be cleared after it is output to the log.  The default is to be cleared."
                    name="inIsClearMessages"
                    required="false"
                    type="boolean"/>
                <cc:parameter
                    default="'debug'"
                    documentation="The minimum level for which messages will be output.  If no value is given a default of debug will be used"
                    name="inMinLogLevel"
                    required="false"
                    validation="['debug','info','warn','error','critical'] contains props['inMinLogLevel'].trim().toLowerCase()"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CloudLogMessages_112"
                id="Call_CloudLogMessages_XSLT_112"
                store-message="none">
                <cc:set
                    name="inLogIterator"
                    value="com.workday.custom.int0025.int0025112.CloudLogXsltStepIterator.getIterator(props['inMessages'], props['inMinLogLevel'])"/>
            </cc:local-out>
            <cc:sync-mediation
                id="InitializeAndFinalize_XSLT_112"
                routes-to="Call_CloudLogMessages_XSLT_112">
                <cc:request-steps>
            </cc:request-steps>
                <cc:response-steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>if (props['inIsClearMessages']) { props['inMessages'].clear() }</cc:expression>
                        <cc:expression>foreach (name: {'inMessages', 'inIsClearMessages', 'inMinLogLevel'}) { context.removeProperty(name) } </cc:expression>
                    </cc:eval>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CloudLogMessages_112"
                id="Call_CloudLogMessages_ETVXTT_112"
                store-message="none">
                <cc:set
                    name="inLogIterator"
                    value="com.workday.custom.int0025.int0025112.CloudLogETVIterator.getIterator(props['inMessages'], props['inMinLogLevel'])"/>
            </cc:local-out>
            <cc:sync-mediation
                id="InitializeAndFinalize_ETVXTT_112"
                routes-to="Call_CloudLogMessages_ETVXTT_112">
                <cc:request-steps/>
                <cc:response-steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>if (props['inIsClearMessages']) { props['inMessages'].clear() }</cc:expression>
                        <cc:expression>foreach (name: {'inMessages', 'inIsClearMessages', 'inMinLogLevel'}) { context.removeProperty(name) } </cc:expression>
                    </cc:eval>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:aggregator
                collate-when="props['aggregator.destination.force.collate']"
                force-batch-on-last-message="false"
                force-batch-when="props['aggregator.destination.force.batch']"
                id="AggregateFile_115"
                routes-to="SendResultsBackToMainThread_115">
                <cc:size-batch-strategy batch-size="-1"/>
                <cc:xml-message-content-collater
                    output="message"
                    output-mimetype="text/xml"
                    xpath="*/*">
                    <cc:header-text>&lt;DISRoot xmlns:tdf="urn:com.workday/tdf"></cc:header-text>
                    <cc:footer-text>&lt;/DISRoot></cc:footer-text>
                </cc:xml-message-content-collater>
            </cc:aggregator>
            <cc:local-in id="Aggregate_115" routes-to="PrepareFile">
            
            
        </cc:local-in>
            <cc:async-mediation id="Teardown_115">
                <cc:steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localLabels', 'localFileIndex', 'localFileCount', 'localTempFileName', 'localBaseFileName', 'localFindFileName']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_115" routes-to="Teardown_115"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_Message_115"
                routes-response-to="Results_115"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set name="inEntityName" value="'DIS_Aggregated_File'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Results_Error_115"
                store-message="none">
                <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while copying the DIS results from the message rootpart to variable globalDISResults.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_115'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set name="inEntityName" value="'DISResults.xml'"/>
            </cc:local-out>
            <cc:async-mediation
                execute-steps-when="props['inReturnResults'] == 'variable'"
                id="Results_115"
                routes-to="Call_Finally_115">
                <cc:steps>
                    <cc:copy
                        id="CopyMsgToVar"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="globalDISResults"/>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_115"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_115"
                id="Call_Finally_115"
                store-message="none">
            
            
            
            
            
            
            
        </cc:local-out>
            <cc:local-out
                endpoint="vm://wcc/GetEventDocuments"
                id="GetEventDocuments_115"
                routes-response-to="PrepareFileResults_115">
                <cc:set name="ie.event.wid" value="props['inEventWID']"/>
            </cc:local-out>
            <cc:local-in
                access="public"
                icon="icons/GetDISResultsParallel.png"
                id="GetDISResultsParallel"
                routes-to="GetEventDocuments_115">
                <cc:parameter
                    default="lp.isSet() ? lp.getIntegrationEventWID() : null"
                    documentation="WID of the Integration Event from which the documents will be queried.  This is typically the current event, and as such, is defaulted to the current event WID.  However, changing this WID enables retrieving documents from another related event for processing."
                    name="inEventWID"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="Specifies a Document Tag for filtering the input files on the Integration Event in addition to the default &quot;Data - Partial&quot; used by DIS.  &quot;Data - Partial&quot; is assumed and should not be provided.  If no additional tag is specified, then only the &quot;Data - Partial&quot; tag will be used."
                    name="inRetrievalDocTag"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="'variable'"
                    documentation="How the DIS results are returned to the caller, either on the message if the value is 'message', or in the 'globalDISResults' variable if the value is 'variable', which is the default."
                    name="inReturnResults"
                    required="true"
                    type="string"
                    validation="['variable', 'message'] contains props['inReturnResults'].trim().toLowerCase()"/>
                <cc:parameter
                    default="props['globalIsDebugMode']"
                    documentation="Controls whether or not the DIS results are output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
            </cc:local-in>
            <cc:sync-mediation
                id="InitializeAndFinalize_115"
                routes-response-to="Call_Debug_Message_115"
                routes-to="Call_ParallelSubroutine_115">
                <cc:request-steps>
                    <cc:eval id="SetValues">
                        <cc:expression>props['localFileIndex'] = 1;&#xd;
props['localTempFileName'] = da.getFileName(props.localDaLabels, 0);&#xd;
props['localBaseFileName'] = props['localTempFileName'].substring(0,props['localTempFileName'].lastIndexOf('-'));</cc:expression>
                    </cc:eval>
                </cc:request-steps>
                <cc:response-steps>
                    <cc:copy
                        id="CopyVarToMsg"
                        input="variable"
                        input-variable="c2pAggregatedResult"/>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:local-out
                endpoint="vm://wcc/ParallelSubroutine"
                id="Call_ParallelSubroutine_115"
                store-message="none">
                <cc:set
                    name="parallel.processing.aggregation.endpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_115'"/>
                <cc:set
                    name="parallel.processing.worker.endpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessFile_115'"/>
                <cc:set name="parallel.processing.worker.count" value="4"/>
                <cc:set name="parallel.processing.worker.timeout" value="60"/>
                <cc:set name="parallel.processing.timeout" value="1200"/>
                <cc:set
                    name="parallel.processing.splitter"
                    value="spring.getBean('SA115FileSplitter')"/>
            </cc:local-out>
            <cc:local-in id="ProcessFile_115" routes-to="ReadFile_115"/>
            <cc:async-mediation id="ReadFile_115">
                <cc:steps>
                    <cc:eval id="SetValues">
                        <cc:expression>props['localFindFileName'] = props['localBaseFileName'] # '-' # props['localFileIndex'] # '.xml';&#xd;
da.toVar(props['localFindFileName'], 'c2pDocument');</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation
                execute-steps-when="props['aggregator.destination.force.collate']"
                id="PrepareFile"
                routes-to="AggregateFile_115">
                <cc:steps>
                    <cc:copy id="CopyVarToMsg" input="variable" input-variable="c2pDocument"/>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation id="SendResultsBackToMainThread_115">
                <cc:steps>
                    <cc:copy
                        id="CopyMsgToVar"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="c2pAggregatedResult"/>
                </cc:steps>
            </cc:async-mediation>
            <cc:route id="RouteFileCount_115">
                <cc:mvel-strategy>
                    <cc:choose-route expression="props['localFileCount'] &lt; 1" route="NoFiles"/>
                    <cc:choose-route expression="true" route="Files"/>
                </cc:mvel-strategy>
                <cc:sub-route name="NoFiles" routes-to="Call_CreateLogEntry_NoFiles_Info_115"/>
                <cc:sub-route name="Files" routes-to="InitializeAndFinalize_115"/>
            </cc:route>
            <cc:async-mediation id="PrepareFileResults_115" routes-to="RouteFileCount_115">
                <cc:steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['localLabels'] = 'Data - Partial' # (props['inRetrievalDocTag'] == empty ? '' : ',' # props['inRetrievalDocTag']);&#xd;
props['localDaLabels'] = org.apache.commons.lang3.StringUtils.split(props.localLabels, ',');</cc:expression>
                        <cc:expression>props['localFileCount'] = da.size(props.localDaLabels);</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_NoFiles_Info_115"
                routes-response-to="Call_Finally_NoFiles_115"
                store-message="none">
                <cc:set name="inLogMessage" value="'No Files Found!'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'No files were found produced by the Data Initialization Service using the Document Tags [' # props.localLabels # '].'"/>
                <cc:set name="inLogReferenceId"/>
                <cc:set name="inLogLevel" value="'info'"/>
                <cc:set name="inExtraLocalIn" value="'PrepareFileResults_115'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_115"
                id="Call_Finally_NoFiles_115"
                store-message="none">
            
            
            
            
            
            
            
        </cc:local-out>
            <cc:async-mediation id="PrepareFileResults_114" routes-to="RouteFileCount_114">
                <cc:steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['localLabels'] = 'Data - Partial' # (props['inRetrievalDocTag'] == empty ? '' : ', ' # props['inRetrievalDocTag'])</cc:expression>
                        <cc:expression>props['localFileCount'] = da.size(org.apache.commons.lang3.StringUtils.split(props.localLabels, ','));</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:route id="RouteFileCount_114">
                <cc:mvel-strategy>
                    <cc:choose-route expression="props['localFileCount'] &lt; 1" route="NoFiles"/>
                    <cc:choose-route expression="true" route="Files"/>
                </cc:mvel-strategy>
                <cc:sub-route name="NoFiles" routes-to="Call_CreateLogEntry_NoFiles_Info_114"/>
                <cc:sub-route name="Files" routes-to="InitializeAndFinalize_114"/>
            </cc:route>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_114"
                id="Call_Finally_NoFiles_114"
                store-message="none">
            
            
            
            
            
            
            
        </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_NoFiles_Info_114"
                routes-response-to="Call_Finally_NoFiles_114"
                store-message="none">
                <cc:set name="inLogMessage" value="'No Files Found!'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'No files were found produced by the Data Initialization Service using the Document Tags [' # props.localLabels # '].'"/>
                <cc:set name="inLogReferenceId"/>
                <cc:set name="inLogLevel" value="'info'"/>
                <cc:set name="inExtraLocalIn" value="'PrepareFileResults_114'"/>
            </cc:local-out>
            <cc:route id="RouteSource_106">
                <cc:mvel-strategy>
                    <cc:choose-route
                        expression="props['inDataSource'] == 'variable'"
                        route="Variable"/>
                    <cc:choose-route expression="true" route="Message"/>
                </cc:mvel-strategy>
                <cc:sub-route name="Variable" routes-to="StoreVariable_106"/>
                <cc:sub-route name="Message" routes-to="StoreMessage_106"/>
            </cc:route>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_StoreMessage_Error_106"
                store-message="none">
                <cc:set name="inLogMessage" value="'Storage Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while storing data to the Integration Event.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:sync-mediation id="InitializeAndFinalize_106" routes-to="RouteSource_106">
                <cc:request-steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['localFilename'] = props['inOutputFilename'] #'.'# props['inOutputFileExtension'];</cc:expression>
                    </cc:eval>
                </cc:request-steps>
                <cc:response-steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localFilename']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                        <cc:expression>foreach (varname : ['localStoreResult']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:response-steps>
            </cc:sync-mediation>
            <cc:async-mediation id="StoreMessage_106" routes-to="PIM_Tag_106">
                <cc:steps>
                    <cc:store
                        createDocumentReference="true"
                        expiresIn="@{props['inDocumentRetentionPeriod']}"
                        id="StoreContent"
                        input="message"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="localStoreResult"
                        title="@{props['localFilename']}"/>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_StoreMessage_Error_106"/>
            </cc:async-mediation>
            <cc:async-mediation id="StoreVariable_106" routes-to="PIM_Tag_106">
                <cc:steps>
                    <cc:store
                        createDocumentReference="true"
                        expiresIn="@{props['inDocumentRetentionPeriod']}"
                        id="StoreContent"
                        input="variable"
                        input-variable="globalOutputData"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="localStoreResult"
                        title="@{props['localFilename']}"/>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_StoreVariable_Error_106"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_SoapResponse_Variable_104"
                store-message="none">
                <cc:set name="inTargetType" value="'variable'"/>
                <cc:set name="inTargetName" value="'globalSoapResults'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Response__' # props['inWebServiceApplication']"/>
            </cc:local-out>
            <cc:aggregator
                force-batch-on-last-message="false"
                force-batch-when="props['is.paged.get.last.page']"
                id="AggregateVariable_104"
                routes-to="Call_Debug_SoapResponse_Variable_104">
                <cc:size-batch-strategy batch-size="-1"/>
                <cc:xml-message-content-collater
                    output="variable"
                    output-mimetype="text/xml"
                    output-variable="globalSoapResults"
                    xpath="@{props['inXpathToResultsToAggregate']}">
                    <cc:header-text>@{props['inAggregatedResultsHeader']}</cc:header-text>
                    <cc:footer-text>@{props['inAggregatedResultsFooter']}</cc:footer-text>
                </cc:xml-message-content-collater>
            </cc:aggregator>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_SoapResponse_Message_104"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Response__' # props['inWebServiceApplication']"/>
            </cc:local-out>
            <cc:aggregator
                force-batch-on-last-message="false"
                force-batch-when="props['is.paged.get.last.page']"
                id="AggregateMessage_104"
                routes-to="Call_Debug_SoapResponse_Message_104">
                <cc:size-batch-strategy batch-size="-1"/>
                <cc:xml-message-content-collater
                    output="message"
                    output-mimetype="text/xml"
                    xpath="@{props['inXpathToResultsToAggregate']}">
                    <cc:header-text>@{props['inAggregatedResultsHeader']}</cc:header-text>
                    <cc:footer-text>@{props['inAggregatedResultsFooter']}</cc:footer-text>
                </cc:xml-message-content-collater>
            </cc:aggregator>
            <cc:route id="RouteDestination_104">
                <cc:mvel-strategy>
                    <cc:choose-route
                        expression="props['inReturnResults'] == 'message'"
                        route="AggregateToMessage"/>
                    <cc:choose-route expression="true" route="AggregateToVariable"/>
                </cc:mvel-strategy>
                <cc:sub-route name="AggregateToMessage" routes-to="AggregateMessage_104"/>
                <cc:sub-route name="AggregateToVariable" routes-to="AggregateVariable_104"/>
            </cc:route>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_ProcessResult_Warn_104"
                store-message="none">
                <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while extracing the results from the SOAP response using xpath['# props['inXpathToResultsToAggregate'] #'].  Processing of the remaining results will continue...'"/>
                <cc:set name="inLogLevel" value="'warn'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set name="inIsAbortOnError" value="false"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                id="ProcessResult_Handler_104"
                routes-to="Call_HandleError_ProcessResult_Warn_104">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation
                continue-after-error="rewind"
                handle-downstream-errors="true"
                id="ProcessResult_104"
                routes-to="RouteDestination_104">
                <cc:steps>
            </cc:steps>
                <cc:send-error id="CatchError" routes-to="ProcessResult_Handler_104"/>
            </cc:async-mediation>
            <cc:local-in id="ProcessPage_104" routes-to="ProcessResult_104">
                <cc:parameter
                    default="props['inAggregatedResultsHeader']"
                    name="inAggregatedResultsHeader"
                    required="true"
                    type="string"
                    validation="props['inAggregatedResultsHeader'] != empty"/>
                <cc:parameter
                    default="props['inAggregatedResultsFooter']"
                    name="inAggregatedResultsFooter"
                    required="true"
                    type="string"
                    validation="props['inAggregatedResultsFooter'] != empty"/>
                <cc:parameter
                    default="props['inXpathToResultsToAggregate']"
                    documentation="Xpath to the elements in the response that are to be aggregated into the globalSoapResults variable."
                    name="inXpathToResultsToAggregate"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['inReturnResults']"
                    documentation="How the SOAP results are returned to the caller, either on the message if the value is 'message', or in the 'globalSoapResults' variable if the value is 'variable', which is the default."
                    name="inReturnResults"
                    required="true"
                    type="string"
                    validation="props['inReturnResults'] == 'variable' || props['inReturnResults'] == 'message'"/>
                <cc:parameter
                    default="props['inWebServiceApplication']"
                    documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;."
                    name="inWebServiceApplication"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['inDebugMode']"
                    documentation="Controls whether or not the SOAP request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
            </cc:local-in>
            <cc:async-mediation id="Teardown_113">
                <cc:steps>
                    <cc:set-headers id="ClearHeaders">
                        <cc:remove-headers>
                            <cc:remove-header name="x-validate-only"/>
                        </cc:remove-headers>
                        <cc:add-headers/>
                    </cc:set-headers>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localIsValuedProperty','localIsDefinedProperty','localIsCorrectTypeProperty','localIsNonEmptyMapProperty','localIsValuedVariable','localIsDefinedVariable','localIsCorrectTypeVariable','localIsNonEmptyMapVariable']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                        <cc:expression>foreach (varname : ['localRequestCache113','localImportRequestArchive113']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_113" routes-to="Teardown_113"/>
            <cc:async-mediation execute-steps-when="props['inBatch']" id="StoreArchive_113">
                <cc:steps>
                    <cc:store
                        createDocumentReference="true"
                        expiresIn="@{props['globalDocumentRetentionPeriod']}"
                        id="StoreArchive"
                        output="variable"
                        output-variable="localImportRequestArchive113"
                        title="ImportRequests.zip"/>
                </cc:steps>
            </cc:async-mediation>
            <cc:aggregator
                collate-when="props['inCollate']"
                force-batch-on-last-message="false"
                force-batch-when="props['inBatch']"
                id="AggregateToArchive_113"
                routes-to="StoreArchive_113">
                <cc:size-batch-strategy batch-size="-1"/>
                <cc:zip-file-collater
                    message-entity-name="@{props['inEntityName']}"
                    output-mimetype="application/zip"/>
            </cc:aggregator>
            <cc:async-mediation
                execute-steps-when="!props['inSupportDetailedResultReporting']"
                id="NonRequest_113"
                routes-to="AggregateToArchive_113">
                <cc:steps>
                    <cc:write id="WriteMessage">
                        <cc:message>
                            <cc:text>&lt;DoNotMessageMatch/></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation
                execute-steps-when="props['inSupportDetailedResultReporting']"
                id="RestoreRequest_113"
                routes-to="NonRequest_113">
                <cc:steps>
                    <cc:copy
                        id="CopyVarToMsg"
                        input="variable"
                        input-variable="localRequestCache113"
                        output="message"
                        output-mimetype="text/xml"/>
                </cc:steps>
            </cc:async-mediation>
            <cc:async-mediation id="ValidateArchive_113" routes-to="RestoreRequest_113">
                <cc:steps>
                    <cc:validate-exp id="ValidateParameters">
                        <cc:expression
                            error-number="11300"
                            failure-message="WWS Import Request Aggregator (Aggregate_113) parameter failure.  The inCollate and inBatch arguments cannot both be false.">(!props['inCollate'] &amp;&amp; props['inBatch']) ||&#xd;
	(props['inCollate'] &amp;&amp; !props['inBatch']) ||&#xd;
	(props['inCollate'] &amp;&amp; props['inBatch'])</cc:expression>
                    </cc:validate-exp>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Aggregate_113" routes-to="ValidateArchive_113">
                <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
                <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
                <cc:parameter name="inEntityName" required="props['inCollate']" type="string"/>
                <cc:parameter
                    default="props['inSupportDetailedResultReporting']"
                    documentation="This boolean flag will cause the sub-assembly to output the request message to an archive of a fixed-name that will be accessed by the post-processor and determine if detailed data block to message level result reporting will be given."
                    name="inSupportDetailedResultReporting"
                    required="true"
                    type="boolean"/>
                <cc:out-parameter name="outEntityName"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_SoapXslt_113"
                store-message="none">
                <cc:set name="inTargetType" value="'variable'"/>
                <cc:set name="inTargetName" value="'localXsltSoapGenerator'"/>
                <cc:set
                    name="inEntityName"
                    value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            </cc:local-out>
            <cc:async-mediation
                id="Transform_Handler_113"
                routes-to="Call_HandleError_Transform_Error_113">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Transform_Error_113"
                store-message="none">
                <cc:set name="inLogMessage" value="'SOAP Preparation Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while preparing a SOAP service call.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'property'"/>
                <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
                <cc:set
                    name="inEntityName"
                    value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            </cc:local-out>
            <cc:async-mediation id="Transform_113" routes-to="Call_Debug_SoapXslt_113">
                <cc:steps>
                    <cc:xslt-plus id="WriteSoap" url="@{props['inPathToXsltFile']}"/>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Transform_Handler_113"/>
            </cc:async-mediation>
            <cc:local-in id="BuildRequest_113" routes-to="Transform_113">
                <cc:parameter
                    default="props['inApiVersion']"
                    documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;"
                    name="inApiVersion"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['inPathToXsltFile']"
                    documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;."
                    name="inPathToXsltFile"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['inDebugMode']"
                    documentation="Controls whether or not the SOAP request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="props['inIsAbortOnError']"
                    name="inIsAbortOnError"
                    required="true"
                    type="boolean"/>
            </cc:local-in>
            <cc:async-mediation
                id="Results_Handler_113"
                routes-to="Call_HandleError_Results_Error_113">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'logic';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_Results_Error_113"
                store-message="none">
                <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while copying the SOAP results from the message rootpart to variable globalSoapResults.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'property'"/>
                <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
                <cc:set
                    name="inEntityName"
                    value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            </cc:local-out>
            <cc:async-mediation
                execute-steps-when="props['inReturnResults'] == 'variable'"
                id="Results_113">
                <cc:steps>
                    <cc:copy
                        id="CopyMsgToVar"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="globalSoapResults"/>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Results_Handler_113"/>
            </cc:async-mediation>
            <cc:local-out
                clone-request="true"
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_113"
                execute-when="props['inSupportDetailedResultReporting']"
                id="Call_Aggregate_113"
                routes-response-to="Results_113"
                store-message="none">
                <cc:set name="inCollate" value="true"/>
                <cc:set name="inBatch" value="props['inIsFinalImportCall']"/>
                <cc:set name="inEntityName" value="props['outImportProcessReference'] # '.xml'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_Response_Info_113"
                routes-response-to="Call_Aggregate_113">
                <cc:set name="inLogMessage" value="'Import Web Service Started'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'Launched an import process on the ' # props['inWebServiceApplication'] # ' application.  See the Reference ID for the associated WID of the Import Process Reference.'"/>
                <cc:set name="inLogReferenceId" value="props['outImportProcessReference']"/>
                <cc:set name="inLogLevel" value="'info'"/>
            </cc:local-out>
            <cc:async-mediation
                id="RetrieveProcessReference_113"
                routes-to="Call_CreateLogEntry_Response_Info_113">
                <cc:steps>
                    <cc:eval id="SetValues">
                        <cc:expression>props['outImportProcessReference'] = parts[0].xpath('/env:Envelope/env:Body/wd:Put_Import_Process_Response/wd:Import_Process_Reference/wd:ID[@wd:type="WID"]');</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_SoapResponse_113"
                routes-response-to="RetrieveProcessReference_113"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Response__' # props['inWebServiceApplication']"/>
            </cc:local-out>
            <cc:workday-out-soap
                application="@{props['inWebServiceApplication']}"
                id="CallSoap_113"
                routes-response-to="Call_Debug_SoapResponse_113"
                version="@{props['inApiVersion']}"/>
            <cc:async-mediation
                id="RouteError_Http_Handler_113"
                routes-to="Call_HandleError_HttpError_Error_113">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'http';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_HttpError_Error_113"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="props['inWebServiceApplication'] #' application HTTP request error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while executing a SOAP request for the '# props['inWebServiceApplication'] #' application.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'property'"/>
                <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
                <cc:set
                    name="inEntityName"
                    value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            </cc:local-out>
            <cc:async-mediation
                id="RouteError_Soap_Handler_113"
                routes-to="Call_HandleError_SoapError_Error_113">
                <cc:steps>
                    <cc:eval id="UpdateValues">
                        <cc:expression>props['outIsSoapError'] = 'soap';</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_SoapError_Error_113"
                store-message="none">
                <cc:set
                    name="inLogMessage"
                    value="props['inWebServiceApplication'] #' application SOAP request error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while executing a soap request for the '# props['inWebServiceApplication'] #' application.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set name="inExtraErrorCode" value="'11301'"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
                <cc:set name="inTargetType" value="'property'"/>
                <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
                <cc:set
                    name="inEntityName"
                    value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xd;&#xa;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xd;&#xa;&#x9;props['inPathToXsltFile']"/>
            </cc:local-out>
            <cc:route id="RouteError_113">
                <cc:mvel-strategy>
                    <cc:choose-route
                        expression="parts[0].isXml() &amp;&amp; (Integer.valueOf(parts[0].xpath('count(/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault)')) > 0)"
                        route="SoapError"/>
                    <cc:choose-route expression="true" route="HttpError"/>
                </cc:mvel-strategy>
                <cc:sub-route name="SoapError" routes-to="RouteError_Soap_Handler_113"/>
                <cc:sub-route name="HttpError" routes-to="RouteError_Http_Handler_113"/>
            </cc:route>
            <cc:async-mediation
                continue-after-error="rewind"
                handle-downstream-errors="true"
                id="CallSoap_Catch_113"
                routes-to="CallSoap_113">
                <cc:steps/>
                <cc:send-error id="CatchError" routes-to="RouteError_113"/>
            </cc:async-mediation>
            <cc:async-mediation
                execute-steps-when="props['inSupportDetailedResultReporting']"
                id="CacheRequest_113"
                routes-to="CallSoap_Catch_113">
                <cc:steps>
                    <cc:copy
                        id="CopyMsgToVar"
                        input-xpath="/*:Envelope/*:Body/*"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="localRequestCache113"/>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_SoapRequest_113"
                routes-response-to="CacheRequest_113"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Request__' # props['inWebServiceApplication']"/>
            </cc:local-out>
            <cc:async-mediation id="SetHeaders_113" routes-to="Call_Debug_SoapRequest_113">
                <cc:steps>
                    <cc:set-headers id="SetHeaders">
                        <cc:remove-headers/>
                        <cc:add-headers>
                            <cc:add-header
                                name="x-validate-only"
                                value="@{props['inValidateOnly'] == true ? 1 : 0}"/>
                        </cc:add-headers>
                    </cc:set-headers>
                    <cc:wrap-soap id="WrapSoap"/>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/BuildRequest_113"
                execute-when="!props['inUseMessageRootPartAsRequest']"
                id="Call_BuildRequest_113"
                propagate-abort="true"
                routes-response-to="SetHeaders_113"
                store-message="none">
                <cc:set name="inApiVersion" value="props['inApiVersion']"/>
                <cc:set name="inPathToXsltFile" value="props['inPathToXsltFile']"/>
                <cc:set name="inDebugMode" value="props['inDebugMode']"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            </cc:local-out>
            <cc:sync-mediation
                id="InitializeAndFinalize_113"
                routes-response-to="Call_Finally_Initiate_113"
                routes-to="Call_BuildRequest_113">
                <cc:request-steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['outIsSoapError'] = '';</cc:expression>
                    </cc:eval>
                </cc:request-steps>
                <cc:response-steps/>
            </cc:sync-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113"
                id="Call_Finally_Initiate_113"
                store-message="none"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_113"
                id="Call_Aggregate_Finalize_113"
                routes-response-to="Call_Finally_Finalized_113"
                store-message="none">
                <cc:set name="inCollate" value="false"/>
                <cc:set name="inBatch" value="true"/>
            </cc:local-out>
            <cc:local-in
                icon="icons/CallSoapImport.png"
                id="CallSoapImport"
                routes-to="InitializeAndFinalize_113">
                <cc:parameter
                    default="props['globalApiVersion']"
                    documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;"
                    name="inApiVersion"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;."
                    name="inWebServiceApplication"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="true"
                    documentation="Sub-assembly supports pre-built, on-message requests as well as facilities to construct the request dynamically.  Set this parameter to true to bypass the dynamic request construction and use the message root part as the request.  If set to false, then the inPathToXsltFile parameter must be set.  The XSLT file must accommodate the XML data on the message root and produce all data elements in the Workday XML request element, ready to be wrapped in a SOAP envelope. "
                    name="inUseMessageRootPartAsRequest"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the Workday XML request for the WWS operation, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;."
                    name="inPathToXsltFile"
                    required="!props['inUseMessageRootPartAsRequest']"
                    type="string"/>
                <cc:parameter
                    default="true"
                    documentation="This boolean flag will cause the sub-assembly to output the request message to an archive of a fixed-name that will be accessed by the post-processor and determine if detailed data block to message level result reporting will be given."
                    name="inSupportDetailedResultReporting"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="'variable'"
                    documentation="How the SOAP results are returned to the caller, either on the message if the value is 'message', or in the 'globalSoapResults' variable if the value is 'variable', which is the default."
                    name="inReturnResults"
                    required="true"
                    type="string"
                    validation="props['inReturnResults'] == 'variable' || props['inReturnResults'] == 'message'"/>
                <cc:parameter
                    default="props['globalIsValidationMode']"
                    documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors."
                    name="inValidateOnly"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="props['globalIsDebugMode']"
                    documentation="Controls whether or not the SOAP request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
                <cc:parameter
                    default="true"
                    documentation="If this is the last Import WWS call that will be made by the integration, then set this parameter to true.  Otherwise, if additional Import WWS calls will be made, set this to false until the final call.  When this value is true, the ImportRequests.zip archive is produced for use in logging import results in the post-processor."
                    name="inIsFinalImportCall"
                    required="true"
                    type="boolean"/>
                <cc:out-parameter
                    documentation="A string to indicate that the request resulted in an error and identify the type.  If the error was at the API level, then outIsSoapError == 'http'.  If the error was at the tenant/application level, then outIsSoapError == 'soap'.  If there was an error unrelated to the API call, then outIsSoapError == 'logic'.  If there is no error, , then outIsSoapError == empty.  Further individual errors determined by Get_Event_Details or Get_Import_Processes are not handled here."
                    name="outIsSoapError"/>
                <cc:out-parameter
                    documentation="The WID of the Import Process returned on the SOAP response from invoking the import web service.  This WID is later used to retrieve the outcome of the import process as well as any individual data failures."
                    name="outImportProcessReference"/>
            </cc:local-in>
            <cc:async-mediation id="Teardown_118">
                <cc:steps>
                    <cc:set-headers id="ClearHeaders">
                        <cc:remove-headers>
                            <cc:remove-header name="x-validate-only"/>
                        </cc:remove-headers>
                        <cc:add-headers/>
                    </cc:set-headers>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localIsImportRequests','localIsRequestDriven','localIsParameterDriven','localProcessWID','localXPath','localNodeName','localAliasedNode','localTestClause','localMatchAll','localMatchAttributes']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                        <cc:expression>foreach (varname : ['localImportProcessMessages118','localOriginalRequests118','localPreTransformData118','localXslt118']) {&#xd;
	vars[varname] = null;&#xd;
}</cc:expression>
                    </cc:eval>
                    <cc:eval id="ReduceDebug">
                        <cc:expression>props['globalDebugPropertyList'].remove('localIsImportRequests');&#xd;
props['globalDebugPropertyList'].remove('localIsRequestDriven');&#xd;
props['globalDebugPropertyList'].remove('localIsParameterDriven');&#xd;
props['globalDebugPropertyList'].remove('localProcessWID');</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_118" routes-to="Teardown_118"/>
            <cc:aggregator
                collate-when="props['inCollate']"
                force-batch-on-last-message="false"
                force-batch-when="props['inBatch']"
                id="AggregateData_118">
                <cc:size-batch-strategy batch-size="-1"/>
                <cc:xml-message-content-collater
                    output="variable"
                    output-mimetype="text/xml"
                    output-variable="localPreTransformData118">
                    <cc:header-text>&lt;Results></cc:header-text>
                    <cc:footer-text>&lt;/Results></cc:footer-text>
                </cc:xml-message-content-collater>
            </cc:aggregator>
            <cc:local-in id="Aggregate_118" routes-to="AggregateData_118">
                <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
                <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_Variable_MergedData_118"
                store-message="none">
                <cc:set name="inTargetType" value="'variable'"/>
                <cc:set name="inTargetName" value="'localPreTransformData118'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_118"
                id="Call_Aggregate_PayloadData_118"
                routes-response-to="Call_Debug_Variable_MergedData_118"
                store-message="none">
                <cc:set name="inCollate" value="true"/>
                <cc:set name="inBatch" value="true"/>
            </cc:local-out>
            <cc:async-mediation
                id="PrepareImportProcessMessages_118"
                routes-to="Call_Aggregate_PayloadData_118">
                <cc:steps>
                    <cc:copy
                        id="CopyVarToMsg"
                        input="variable"
                        input-variable="localImportProcessMessages118"
                        output-mimetype="text/xml"/>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_118"
                id="Call_Aggregate_EnrichmentData_118"
                routes-response-to="PrepareImportProcessMessages_118"
                store-message="none">
                <cc:set name="inCollate" value="true"/>
                <cc:set name="inBatch" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                id="PrepareImportRequests_118"
                routes-to="Call_Aggregate_EnrichmentData_118">
                <cc:steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['localTestClause'] = 'local-name(.) eq \'' # props['inNodeName'] # '\'';</cc:expression>
                        <cc:expression>props['localMatchAll'] = '@*|node()';</cc:expression>
                        <cc:expression>props['localMatchAttributes'] = '@*';</cc:expression>
                    </cc:eval>
                    <cc:write id="LoadXslt" output="variable" output-variable="localXslt118">
                        <cc:message>
                            <cc:text>&lt;?xml version="1.0" encoding="UTF-8"?>&#xd;
&lt;xsl:stylesheet&#xd;
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&#xd;
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"&#xd;
    xmlns:wd="urn:com.workday/bsvc"&#xd;
    exclude-result-prefixes="xsd"&#xd;
    version="3.0">&#xd;
    &#xd;
    &lt;xsl:mode streamable="yes" on-no-match="shallow-skip"/>&#xd;
    &#xd;
    &lt;xsl:output method="xml" indent="no" encoding="UTF-8"/>&#xd;
    &#xd;
    &lt;xsl:template match="/">&#xd;
        &lt;wd:Batch xmlns:wd="urn:com.workday/bsvc">&#xd;
            &lt;xsl:apply-templates select="@{props['inXPath']}"/>&#xd;
        &lt;/wd:Batch>&#xd;
    &lt;/xsl:template>&#xd;
    &#xd;
    &lt;!-- standard copy template -->&#xd;
    &lt;xsl:template match="@{props['localMatchAll']}">&#xd;
        &lt;xsl:copy>&#xd;
            &lt;xsl:choose>&#xd;
                &lt;xsl:when test="@{props['localTestClause']}">&#xd;
                    &lt;xsl:apply-templates select="@{props['localMatchAttributes']}"/>&#xd;
                    &lt;wd:LogPosition>&lt;xsl:value-of select="position()"/>&lt;/wd:LogPosition>&#xd;
                    &lt;xsl:apply-templates/>&#xd;
                &lt;/xsl:when>&#xd;
                &lt;xsl:otherwise>&#xd;
                    &lt;xsl:apply-templates select="@{props['localMatchAttributes']}"/>&#xd;
                    &lt;xsl:apply-templates/>&#xd;
                &lt;/xsl:otherwise>&#xd;
            &lt;/xsl:choose>&#xd;
        &lt;/xsl:copy>&#xd;
    &lt;/xsl:template>	&#xd;
&lt;/xsl:stylesheet></cc:text>
                        </cc:message>
                    </cc:write>
                    <cc:xslt-plus
                        id="TransformRequests"
                        input="variable"
                        input-variable="localOriginalRequests118"
                        output-mimetype="text/xml"
                        url="mctx:vars/localXslt118"/>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in
                id="MergeRequestsWithResponses_118"
                routes-to="PrepareImportRequests_118">
                <cc:parameter
                    documentation="The XPath (relative to the root, not absolute) to the data elements in the WWS Import Request.  For example, if using the Import_Eligible_Earnings_Override_Request, then this value would be 'wd:Import_Eligible_Earnings_Override_Request/wd:Eligible_Earnings'.  This will effectively eliminate other nodes, such as Eligible_Earnings_Override_Period_Reference in the example, from interfering with the positional matching between the data elments and the process message line numbers.  The last node of the XPath is used to determine when to write the positional data and therefore cannot be a wildcard."
                    name="inXPath"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The name of the data element in the WWS Import Request."
                    name="inNodeName"
                    required="true"
                    type="string"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_GetImportProcessMessagesResponse_118"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set name="inTargetName" value="'localImportProcessMessages118'"/>
                <cc:set
                    name="inEntityName"
                    value="'SOAP-Response__Get_Import_Process_Messages'"/>
            </cc:local-out>
            <cc:aggregator
                force-batch-on-last-message="false"
                force-batch-when="props['is.paged.get.last.page']"
                id="AggregateImportProcessMessages_118"
                routes-to="Call_Debug_GetImportProcessMessagesResponse_118">
                <cc:size-batch-strategy batch-size="-1"/>
                <cc:xml-message-content-collater
                    output="variable"
                    output-mimetype="text/xml"
                    output-variable="localImportProcessMessages118"
                    xpath="/env:Envelope/env:Body/wd:Get_Import_Process_Messages_Response/wd:Response_Data/wd:Import_Process_Message">
                    <cc:header-text>&lt;wd:Import_Process_Messages xmlns:wd="urn:com.workday/bsvc"></cc:header-text>
                    <cc:footer-text>&lt;/wd:Import_Process_Messages></cc:footer-text>
                </cc:xml-message-content-collater>
            </cc:aggregator>
            <cc:local-in
                id="GetImportProcessMessages_Worker_118"
                routes-to="AggregateImportProcessMessages_118">
                <cc:parameter
                    default="props['inDebugMode']"
                    documentation="Controls whether or not the SOAP request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
            </cc:local-in>
            <cc:local-out endpoint="vm://wcc/PagedGet" id="CallSoapPagedGet_118">
                <cc:set
                    name="is.paged.get.request.current.page.xpath"
                    value="'/env:Envelope/env:Body/*/wd:Response_Filter/wd:Page'"/>
                <cc:set
                    name="is.paged.get.response.current.page.xpath"
                    value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Page'"/>
                <cc:set
                    name="is.paged.get.response.total.pages.xpath"
                    value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Pages'"/>
                <cc:set
                    name="is.paged.get.response.total.results.xpath"
                    value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Results'"/>
                <cc:set
                    name="is.paged.get.process.endpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/GetImportProcessMessages_Worker_113'"/>
                <cc:set name="is.paged.get.application" value="'Integrations'"/>
                <cc:set name="is.paged.get.version" value="props['inApiVersion']"/>
                <cc:set name="is.paged.get.page.zero" value="false"/>
                <cc:set name="is.paged.get.store.requests" value="true"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_GetImportProcessMessagesRequest_118"
                routes-response-to="CallSoapPagedGet_118"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set name="inEntityName" value="'SOAP-Request__Get_Import_Process_Messages'"/>
            </cc:local-out>
            <cc:async-mediation
                id="GetImportProcessMessages_PrepareSoap_118"
                routes-to="Call_Debug_GetImportProcessMessagesRequest_118">
                <cc:steps>
                    <cc:write id="WriteSoapRequest">
                        <cc:message>
                            <cc:text>&lt;soapenv:Envelope xmlns:wd="urn:com.workday/bsvc" xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">&#xd;
    &lt;soapenv:Header>&#xd;
        &lt;wd:Workday_Common_Header>&lt;wd:Include_Reference_Descriptors_In_Response>true&lt;/wd:Include_Reference_Descriptors_In_Response>&lt;/wd:Workday_Common_Header>&#xd;
    &lt;/soapenv:Header>&#xd;
    &lt;soapenv:Body>&#xd;
        &lt;wd:Get_Import_Process_Messages_Request wd:version="@{props['inApiVersion']}">&#xd;
            &lt;wd:Request_Criteria>&#xd;
                &lt;wd:Import_Process_Reference>&#xd;
                    &lt;wd:ID wd:type="WID">@{props['inProcessWID']}&lt;/wd:ID>&#xd;
                &lt;/wd:Import_Process_Reference>&#xd;
            &lt;/wd:Request_Criteria>&#xd;
            &lt;wd:Response_Filter>&#xd;
                &lt;wd:Page>1&lt;/wd:Page>&#xd;
                &lt;wd:Count>999&lt;/wd:Count>&#xd;
            &lt;/wd:Response_Filter>&#xd;
        &lt;/wd:Get_Import_Process_Messages_Request>&#xd;
    &lt;/soapenv:Body>&#xd;
&lt;/soapenv:Envelope></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in
                id="GetImportProcessMessages_118"
                routes-to="GetImportProcessMessages_PrepareSoap_118">
                <cc:parameter
                    default="props['inApiVersion']"
                    documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;"
                    name="inApiVersion"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['inProcessWID']"
                    documentation="The WID of the background process for which messages are being requested."
                    name="inProcessWID"
                    required="true"
                    type="string"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_ResponseMessage_Dynamic_118"
                store-message="none">
                <cc:set name="inLogMessage" value="'Issue with Import WWS Data'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="parts[0].xstream('/*/*/wd:Message_Summary')"/>
                <cc:set name="inLogReferenceId" value="props['inProcessWID']"/>
                <cc:set name="inLogLevel" value="parts[0].xstream('/*/*/wd:Severity')"/>
                <cc:set
                    name="inExtraLocalIn"
                    value="'Call_CreateLogEntry_ResponseMessage_Dynamic_118'"/>
                <cc:set
                    name="inExtraRecordNumber"
                    value="parts[0].xstream('/*/*/wd:Line_Number')"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'The Reference Id contains the WID of the background process executing the import.  The timestamp of the error reported by the tenant is ' # (parts[0].xstream('/*/*/wd:Timestamp')) # '.'"/>
                <cc:set name="inExtraErrorCode" value="'11803'"/>
            </cc:local-out>
            <cc:splitter id="ResponseMessageSplitter_118" no-split-message-error="false">
                <cc:sub-route
                    name="ProcessMessage"
                    routes-to="Call_CreateLogEntry_ResponseMessage_Dynamic_118"/>
                <cc:xml-stream-splitter xpath="/*/*"/>
            </cc:splitter>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_SimpleTransform_Error_118"
                store-message="none">
                <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred executing the transformation of message data.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                handle-downstream-errors="true"
                id="PrepareResponseMessages_118"
                routes-to="ResponseMessageSplitter_118">
                <cc:steps>
                    <cc:copy
                        id="CopyVarToMsg"
                        input="variable"
                        input-variable="localImportProcessMessages118"
                        output-mimetype="text/xml"/>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_SimpleTransform_Error_118"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_DetailedMessage_Dynamic_118"
                store-message="none">
                <cc:set name="inLogMessage" value="'Issue with Import WWS Data'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="parts[0].xstream('/*/*/wd:Message_Summary')"/>
                <cc:set name="inLogReferenceId" value="props['inProcessWID']"/>
                <cc:set name="inLogLevel" value="parts[0].xstream('/*/*/wd:Severity')"/>
                <cc:set
                    name="inExtraLocalIn"
                    value="'Call_CreateLogEntry_DetailedMessage_Dynamic_118'"/>
                <cc:set
                    name="inExtraRecordNumber"
                    value="parts[0].xstream('/*/*/wd:Line_Number')"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'The Reference Id contains the WID of the background process executing the import.  The timestamp of the error reported by the tenant is ' # (parts[0].xstream('/*/*/wd:Timestamp')) # '.  The original import request data (note the wd:LogPosition was added for reporting purposes and is not a part of the API) was: ' # (org.apache.commons.lang3.StringUtils.normalizeSpace(parts[0].xpath('serialize(/*/*/wd:Request/*)')))"/>
                <cc:set name="inExtraErrorCode" value="'11802'"/>
            </cc:local-out>
            <cc:splitter id="DetailedMessageSplitter_118" no-split-message-error="false">
                <cc:sub-route
                    name="ProcessMessage"
                    routes-to="Call_CreateLogEntry_DetailedMessage_Dynamic_118"/>
                <cc:xml-stream-splitter xpath="/*/*"/>
            </cc:splitter>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_DetailedTransform_Error_118"
                store-message="none">
                <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred executing the payload transformation using enrichment data.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                handle-downstream-errors="true"
                id="PrepareDetailedMessages_118"
                routes-to="DetailedMessageSplitter_118">
                <cc:steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['localMatchAll'] = '@*|node()';</cc:expression>
                        <cc:expression>props['localMatchAttributes'] = '@*';</cc:expression>
                    </cc:eval>
                    <cc:write id="LoadXslt" output="variable" output-variable="localXslt118">
                        <cc:message>
                            <cc:text>&lt;?xml version="1.0" encoding="UTF-8"?>&#xd;
&lt;xsl:stylesheet&#xd;
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&#xd;
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"&#xd;
    xmlns:wd="urn:com.workday/bsvc"&#xd;
    exclude-result-prefixes="xsd"&#xd;
    version="3.0">&#xd;
    &#xd;
    &lt;xsl:mode streamable="yes" on-no-match="shallow-skip"/>&#xd;
&#xd;
    &lt;xsl:output method="xml" indent="no" encoding="UTF-8"/>&#xd;
    &#xd;
    &lt;xsl:key name="lookupKey" match="@{props['localAliasedNode']}" use="wd:LogPosition"/>&#xd;
    &#xd;
    &lt;xsl:template match="Results">&#xd;
        &lt;xsl:iterate select="*">&#xd;
            &lt;xsl:param name="lookup" as="item()?"/>&#xd;
            &#xd;
            &lt;xsl:choose>&#xd;
                &lt;xsl:when test="exists($lookup)">&#xd;
                    &lt;xsl:apply-templates select=".">&#xd;
                        &lt;xsl:with-param name="lookup" select="$lookup"/>&#xd;
                    &lt;/xsl:apply-templates>&#xd;
&#xd;
                    &lt;xsl:next-iteration>&#xd;
                        &lt;xsl:with-param name="lookup" select="$lookup"/>&#xd;
                    &lt;/xsl:next-iteration>&#xd;
                &lt;/xsl:when>&#xd;
                &lt;xsl:otherwise>&#xd;
                    &lt;xsl:next-iteration>&#xd;
                        &lt;xsl:with-param name="lookup" select="snapshot()"/>&#xd;
                    &lt;/xsl:next-iteration>&#xd;
                &lt;/xsl:otherwise>&#xd;
            &lt;/xsl:choose>&#xd;
        &lt;/xsl:iterate>        &#xd;
    &lt;/xsl:template>&#xd;
    &#xd;
    &lt;xsl:template match="wd:Import_Process_Messages">&#xd;
        &lt;xsl:param name="lookup" as="item()?"/>&#xd;
&#xd;
        &lt;wd:Root>	&#xd;
            &lt;xsl:for-each select="wd:Import_Process_Message/copy-of()">&#xd;
                &lt;wd:Import_Process_Message>&#xd;
                    &lt;xsl:apply-templates select="./*">&#xd;
                        &lt;xsl:with-param name="lookup" select="$lookup"/>&#xd;
                        &lt;xsl:with-param name="lineNumber" select="./wd:Import_Process_Message_Data/wd:Line_Number/text()">&lt;/xsl:with-param>&#xd;
                    &lt;/xsl:apply-templates>&#xd;
                &lt;/wd:Import_Process_Message>&#xd;
            &lt;/xsl:for-each>&#xd;
        &lt;/wd:Root>&#xd;
    &lt;/xsl:template>&#xd;
    &#xd;
	&lt;!-- standard copy template -->&#xd;
	&lt;xsl:template match="@{props['localMatchAll']}">&#xd;
        &lt;xsl:param name="lookup" as="item()?"/>&#xd;
        &lt;xsl:param name="lineNumber" as="item()?"/>&#xd;
&#xd;
        &lt;xsl:copy>&#xd;
            &lt;xsl:choose>&#xd;
                &lt;xsl:when test="local-name(.) eq 'Import_Process_Message_Data'">&#xd;
                    &lt;xsl:apply-templates select="@{props['localMatchAttributes']}">&#xd;
                        &lt;xsl:with-param name="lookup" select="$lookup"/>&#xd;
                        &lt;xsl:with-param name="lineNumber" select="$lineNumber">&lt;/xsl:with-param>&#xd;
                    &lt;/xsl:apply-templates>&#xd;
                    &lt;wd:Request>&lt;xsl:copy-of select="key('lookupKey', $lineNumber, $lookup)"/>&lt;/wd:Request>&#xd;
                    &lt;xsl:apply-templates>&#xd;
                        &lt;xsl:with-param name="lookup" select="$lookup"/>&#xd;
                        &lt;xsl:with-param name="lineNumber" select="$lineNumber">&lt;/xsl:with-param>&#xd;
                    &lt;/xsl:apply-templates>&#xd;
                &lt;/xsl:when>&#xd;
                &lt;xsl:otherwise>&#xd;
                    &lt;xsl:apply-templates select="@{props['localMatchAttributes']}">&#xd;
                        &lt;xsl:with-param name="lookup" select="$lookup"/>&#xd;
                        &lt;xsl:with-param name="lineNumber" select="$lineNumber">&lt;/xsl:with-param>&#xd;
                    &lt;/xsl:apply-templates>&#xd;
                    &lt;xsl:apply-templates>&#xd;
                        &lt;xsl:with-param name="lookup" select="$lookup"/>&#xd;
                        &lt;xsl:with-param name="lineNumber" select="$lineNumber">&lt;/xsl:with-param>&#xd;
                    &lt;/xsl:apply-templates>&#xd;
                &lt;/xsl:otherwise>&#xd;
            &lt;/xsl:choose>&#xd;
        &lt;/xsl:copy>&#xd;
	&lt;/xsl:template>	&#xd;
&lt;/xsl:stylesheet></cc:text>
                        </cc:message>
                    </cc:write>
                    <cc:xslt-plus
                        id="TranformToMessages"
                        input="variable"
                        input-variable="localPreTransformData118"
                        output-mimetype="text/xml"
                        url="mctx:vars/localXslt118"/>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_DetailedTransform_Error_118"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/MergeRequestsWithResponses_118"
                id="Call_MergeRequestsWithResponses_118"
                routes-response-to="PrepareDetailedMessages_118"
                store-message="none">
                <cc:set name="inXPath" value="props['localXPath']"/>
                <cc:set name="inNodeName" value="props['localNodeName']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_PrepareDynamicXPath_Error_118"
                store-message="none">
                <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred executing the payload transformation using enrichment data.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                handle-downstream-errors="true"
                id="PrepareDynamicXPath_118"
                routes-to="Call_MergeRequestsWithResponses_118">
                <cc:steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['localXPath'] = org.apache.commons.lang3.StringUtils.removeStart(props['inXPathToRequestData'], '/');</cc:expression>
                        <cc:expression>props['localXPath'] = org.apache.commons.lang3.StringUtils.removeEnd(props['localXPath'], '/');</cc:expression>
                        <cc:expression>props['localNodeName'] = org.apache.commons.lang3.StringUtils.substringAfterLast(props['localXPath'], ':');</cc:expression>
                        <cc:expression>props['localAliasedNode'] = org.apache.commons.lang3.StringUtils.substringAfterLast(props['localXPath'], '/');</cc:expression>
                    </cc:eval>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_PrepareDynamicXPath_Error_118"/>
            </cc:async-mediation>
            <cc:route id="RouteLogChoice_118">
                <cc:mvel-strategy>
                    <cc:choose-route expression="!props['inIsRequestDriven']" route="LinkToRequest"/>
                    <cc:choose-route expression="true" route="MessageOnly"/>
                </cc:mvel-strategy>
                <cc:sub-route name="LinkToRequest" routes-to="PrepareDynamicXPath_118"/>
                <cc:sub-route name="MessageOnly" routes-to="PrepareResponseMessages_118"/>
            </cc:route>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/GetImportProcessMessages_118"
                id="Call_GetImportProcessMessages_118"
                routes-response-to="RouteLogChoice_118"
                store-message="none">
                <cc:set name="inApiVersion" value="props['inApiVersion']"/>
                <cc:set name="inProcessWID" value="props['inProcessWID']"/>
            </cc:local-out>
            <cc:local-in
                id="ProcessRequest_118"
                routes-to="Call_GetImportProcessMessages_118">
                <cc:parameter
                    default="props['inApiVersion']"
                    documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;"
                    name="inApiVersion"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="props['localProcessWID']"
                    documentation="The WID of the background process for which messages are being requested."
                    name="inProcessWID"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The XPath (relative to the root, not absolute) to the data elements in the WWS Import Request.  For example, if using the Import_Eligible_Earnings_Override_Request, then this value would be 'wd:Import_Eligible_Earnings_Override_Request/wd:Eligible_Earnings'.  This will effectively eliminate other nodes, such as Eligible_Earnings_Override_Period_Reference in the example, from interfering with the positional matching between the data elments and the process message line numbers.  The last node of the XPath is used to determine when to write the positional data and therefore cannot be a wildcard."
                    name="inXPathToRequestData"
                    required="false"
                    type="string"/>
                <cc:parameter default="props['localIsRequestDriven']" name="inIsRequestDriven"/>
                <cc:parameter
                    default="props['localIsParameterDriven']"
                    name="inIsParameterDriven"/>
                <cc:parameter
                    default="props['inKeyFunctionUse']"
                    documentation="The XPath query for the 'use' attribute of the key element.  This value starts from the second level node of the request data as exported by SA-113, e.g. if the import WWS were Import_Eligible_Earnings_Override then this parameter would be valued as 'wd:Eligible_Earnings' (no / rooting should be used).  When the request initiator didn't intend for detailed reporting, and the data were not included with the background process WID, then this should be null."
                    name="inKeyFunctionUse"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="props['inKeyFunctionMatch']"
                    documentation="The name of the node to use for the 'match' attribute of the key element.  This value is the first level node of the request data as exported by SA-113, e.g. if the import WWS were Import_Eligible_Earnings_Override then this parameter would be valued as 'wd:Import_Eligible_Earnings_Override_Request' (no / rooting should be used).  When the request initiator didn't intend for detailed reporting, and the data were not included with the background process WID, then this should be null."
                    name="inKeyFunctionMatch"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="props['globalIsValidationMode']"
                    documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors."
                    name="inValidateOnly"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="props['inDebugMode']"
                    documentation="Controls whether or not the SOAP request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
            </cc:local-in>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessRequest_118"
                id="Call_ProcessRequest_118"
                propagate-abort="false"
                store-message="none">
                <cc:set name="inApiVersion" value="props['inApiVersion']"/>
                <cc:set name="inProcessWID" value="props['localProcessWID']"/>
                <cc:set name="inIsParameterDriven" value="props['localIsParameterDriven']"/>
                <cc:set name="inIsRequestDriven" value="props['localIsRequestDriven']"/>
                <cc:set name="inDebugMode" value="props['inDebugMode']"/>
                <cc:set name="inKeyFunctionUse" value="props['inKeyFunctionUse']"/>
                <cc:set name="inKeyFunctionMatch" value="props['inKeyFunctionMatch']"/>
                <cc:set name="inXPathToRequestData" value="props['inXPathToRequestData']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_Properties_118"
                routes-response-to="Call_ProcessRequest_118"
                store-message="none">
                <cc:set name="inTargetType" value="'properties'"/>
                <cc:set name="inTargetName" value="'globalDebugPropertyList'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_LoggingDetail_Error_118"
                store-message="none">
                <cc:set name="inLogMessage" value="'Error Parsing Archive File'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while parsing the file from the archive to determine how to log Import Process Messages.'"/>
                <cc:set name="inLogReferenceId" value="props['inImportIntegrationEventWID']"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                handle-downstream-errors="true"
                id="LoggingDetail_118"
                routes-to="Call_Debug_Properties_118">
                <cc:steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['localIsRequestDriven'] = Boolean.valueOf(parts[0].xstreamB('/DoNotMessageMatch'));&#xd;
props['localIsParameterDriven'] = props['inXPathToRequestData'] != empty;</cc:expression>
                        <cc:expression>props['localProcessWID'] = org.apache.commons.lang3.StringUtils.removeEnd(util.currentFilename, '.xml');</cc:expression>
                    </cc:eval>
                    <cc:eval id="UpdateDebug">
                        <cc:expression>props['globalDebugPropertyList'].add('localIsRequestDriven');&#xd;
props['globalDebugPropertyList'].add('localIsParameterDriven');&#xd;
props['globalDebugPropertyList'].add('localProcessWID');</cc:expression>
                    </cc:eval>
                    <cc:validate-exp id="Validate">
                        <cc:expression
                            error-number="11804"
                            failure-message="The background process WID could not determined from the filename within the ImportRequests.zip archive.  The value is empty, and therefore, retrieving process messages is not possible.">props['localProcessWID'] != empty</cc:expression>
                        <cc:expression
                            error-number="11805"
                            failure-message="Unable to determine how to log process messages.  The archived file includes the request details for logging, but the inXpathToData parameter does not contain an XPath expression to identify the data elements of the request within the archived file.  Either the archived file should specify the requests and the inXpathToData parameter is set, or the archived file contains an empty DoNotMessageMatch root element and the inXpathToData parameter is not set.">!(!props['localIsRequestDriven'] &amp;&amp; !props['localIsParameterDriven'])</cc:expression>
                        <cc:expression
                            error-number="11806"
                            failure-message="Unable to determine how to log process messages.  The archived file does not contain the request details for logging, but the inXpathToData parameter has been set with an XPath expression to identify the data elements of the request within the archived file.  Either the archived file should specify the requests and the inXpathToData parameter is set, or the archived file contains an empty DoNotMessageMatch root element and the inXpathToData parameter is not set.">!(props['localIsRequestDriven'] &amp;&amp; props['localIsParameterDriven'])</cc:expression>
                        <cc:expression
                            error-number="11807"
                            failure-message="Unable to determine how to log process messages.  The archived file contains the request details for logging, but the inXPathToData parameter value does not match any results within those request details.  Check the inXPathToData parameter value and verify that it matches the request content.">(props['localIsRequestDriven'] &amp;&amp; (props['inXPathToRequestData'] == empty)) || &#xd;
(props['localIsParameterDriven'] &amp;&amp; parts[0].xstreamB('/' # props['inXPathToRequestData']))</cc:expression>
                    </cc:validate-exp>
                    <cc:copy
                        id="CopyMsgToVar"
                        output="variable"
                        output-mimetype="text/xml"
                        output-variable="localOriginalRequests118"/>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_LoggingDetail_Error_118"/>
            </cc:async-mediation>
            <cc:splitter id="ImportRequestsSplitter_118">
                <cc:sub-route name="ProcessRequest" routes-to="LoggingDetail_118"/>
                <cc:unzip-splitter format="zip"/>
            </cc:splitter>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_EmptyFile_Warn_118"
                store-message="none">
                <cc:set name="inLogMessage" value="'No Import Processes Found Within File'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'The ImportRequests.zip file was found; however, it did not contain any files identifying the background process WIDs.'"/>
                <cc:set name="inLogReferenceId" value="props['inImportIntegrationEventWID']"/>
                <cc:set name="inLogLevel" value="'warn'"/>
                <cc:set name="inExtraLocalIn" value="'ImportRequestsSplitter_118'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'ImportRequests.zip was found on the Integration Event, but was empty.  See the Reference Id for the WID of that event.'"/>
                <cc:set name="inExtraErrorCode" value="'11801'"/>
            </cc:local-out>
            <cc:async-mediation
                handle-downstream-errors="true"
                id="ImportRequestsSplitter_Catch_118"
                routes-to="ImportRequestsSplitter_118">
                <cc:steps/>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_CreateLogEntry_EmptyFile_Warn_118"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_NoImports_Warn_118"
                store-message="none">
                <cc:set name="inLogMessage" value="'No Import Process File Found'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'The ImportRequests.zip file was not found; therefore, the background process WIDs are unknown and status cannot be queried.'"/>
                <cc:set name="inLogReferenceId" value="props['inImportIntegrationEventWID']"/>
                <cc:set name="inLogLevel" value="'warn'"/>
                <cc:set name="inExtraLocalIn" value="'DocumentAccessor_118'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'ImportRequests.zip was not found on Integration Event.  See the Reference Id for the WID of that event.'"/>
                <cc:set name="inExtraErrorCode" value="'11800'"/>
            </cc:local-out>
            <cc:route id="RouteResults_118">
                <cc:mvel-strategy>
                    <cc:choose-route expression="!props['localIsImportRequests']" route="NoImports"/>
                    <cc:choose-route expression="true" route="HasImports"/>
                </cc:mvel-strategy>
                <cc:sub-route
                    name="NoImports"
                    routes-to="Call_CreateLogEntry_NoImports_Warn_118"/>
                <cc:sub-route name="HasImports" routes-to="ImportRequestsSplitter_Catch_118"/>
            </cc:route>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_DocumentAccessor_Error_118"
                store-message="none">
                <cc:set name="inLogMessage" value="'GetEventDocuments Processing Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while parsing the Get_Event_Documents response.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                handle-downstream-errors="true"
                id="DocumentAccessor_118"
                routes-to="RouteResults_118">
                <cc:steps>
                    <cc:eval id="SetValues">
                        <cc:expression>props['localIsImportRequests'] = da.hasFile(props.inRequestFilename)</cc:expression>
                        <cc:expression>if (props['localIsImportRequests']) {&#xd;
	parts[0] = da.getData(props.inRequestFilename);&#xd;
}</cc:expression>
                    </cc:eval>
                    <cc:eval id="UpdateDebug">
                        <cc:expression>props['globalDebugPropertyList'].add('localIsImportRequests');</cc:expression>
                    </cc:eval>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_DocumentAccessor_Error_118"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://wcc/GetEventDocuments"
                id="GetEventDocuments_118"
                routes-response-to="DocumentAccessor_118">
                <cc:set name="ie.event.wid" value="props['inImportIntegrationEventWID']"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_GetEventDocs_Error_118"
                store-message="none">
                <cc:set name="inLogMessage" value="'GetEventDocuments Execution Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while calling Get_Event_Documents.'"/>
                <cc:set name="inLogReferenceId"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set name="inExtraRecordNumber"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIncludeDebugOutput" value="false"/>
            </cc:local-out>
            <cc:sync-mediation
                handle-downstream-errors="true"
                id="InitializeAndFinalize_118"
                routes-response-to="Call_Finally_Report_118"
                routes-to="GetEventDocuments_118">
                <cc:request-steps/>
                <cc:response-steps/>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_GetEventDocs_Error_118"/>
            </cc:sync-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118"
                id="Call_Finally_Report_118"
                store-message="none"/>
            <cc:local-in
                icon="icons/ReportResultsOfCallSoapImport.png"
                id="ReportResultsOfCallSoapImport"
                routes-to="InitializeAndFinalize_118">
                <cc:parameter
                    default="props['globalApiVersion']"
                    documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;"
                    name="inApiVersion"
                    required="true"
                    type="string"/>
                <cc:parameter
                    documentation="The XPath (relative to the root, not absolute) to the data elements in the WWS Import Request.  For example, if using the Import_Eligible_Earnings_Override_Request, then this value would be 'wd:Import_Eligible_Earnings_Override_Request/wd:Eligible_Earnings'.  This will effectively eliminate other nodes, such as Eligible_Earnings_Override_Period_Reference in the example, from interfering with the positional matching between the data elments and the process message line numbers.  The last node of the XPath is used to determine when to write the positional data and therefore cannot be a wildcard."
                    name="inXPathToRequestData"
                    required="false"
                    type="string"/>
                <cc:parameter
                    default="props['globalIsValidationMode']"
                    documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors."
                    name="inValidateOnly"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="props['globalIsDebugMode']"
                    documentation="Controls whether or not the SOAP request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
                <cc:parameter
                    default="lp.isSet() ? lp.getIntegrationEventWID() : null"
                    documentation="The WID of the Integration Event that initiated the Import WWS call and from which we need to retrieve information to know what background processes to query for status.  If not provided, the post processor is assumed to be linked to the Import WWS initiating system by way of the Integration BP and the current WID is defaulted."
                    name="inImportIntegrationEventWID"
                    required="true"
                    type="string"/>
                <cc:parameter
                    default="'ImportRequests.zip'"
                    documentation="The filename of the zip archive produced by the pre-processor that initiated the requests.  Presumably, if initiated with SSK and SA-113, then this should be ImportRequests.zip, which is the default."
                    name="inRequestFilename"
                    required="true"
                    type="string"/>
            </cc:local-in>
            <cc:local-in
                icon="icons/FinalizeCallSoapImport.png"
                id="FinalizeCallSoapImport"
                routes-to="Call_Aggregate_Finalize_113"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113"
                id="Call_Finally_Finalized_113"
                store-message="none"/>
            <cc:local-in
                icon="icons/DeadCodeDetection.png"
                id="StaticCodeAnalysis"
                routes-to="InitializeAndFinalize_121">
                <cc:parameter
                    default="props['globalStaticCodeAnalysisExemptionList']"
                    documentation="A list of sub-assemblies to exclude from warning generation in the static code analysis because of use by dynamic endpoints."
                    name="inStaticCodeAnalysisExemptionList"
                    required="false"/>
                <cc:parameter
                    default="props['globalIsDebugMode']"
                    documentation="Controls whether or not the REST request is output on debug."
                    name="inDebugMode"
                    required="true"
                    type="boolean"/>
                <cc:parameter
                    default="false"
                    documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler."
                    name="inIsAbortOnError"
                    required="false"
                    type="boolean"/>
            </cc:local-in>
            <cc:sync-mediation
                handle-downstream-errors="true"
                id="InitializeAndFinalize_121"
                routes-response-to="Call_Finally_121"
                routes-to="Call_Debug_PropertyList_121">
                <cc:request-steps>
                    <cc:eval id="InitValues">
                        <cc:expression>props['localAssemblyXml'] = 'assembly.xml';</cc:expression>
                        <cc:expression>props['localSubAssemblyDetailMap'] = new java.util.HashMap();</cc:expression>
                        <cc:expression>props['localSubAssemblyDetailMap'].put('InitializeFrameworkThenRunMain','Studio StarterKit Library > CORE COMPONENTS > 109 - Initialization');&#xd;
props['localSubAssemblyDetailMap'].put('HandleError','Studio StarterKit Library > CORE COMPONENTS > 109 - Error Handling');&#xd;
props['localSubAssemblyDetailMap'].put('SetupLog','Studio StarterKit Library > CORE COMPONENTS > 109 - General Cloud Logging');&#xd;
props['localSubAssemblyDetailMap'].put('CreateLogEntry','Studio StarterKit Library > CORE COMPONENTS > 109 - General Cloud Logging');&#xd;
props['localSubAssemblyDetailMap'].put('StoreLog','Studio StarterKit Library > CORE COMPONENTS > 109 - General Cloud Logging');&#xd;
props['localSubAssemblyDetailMap'].put('LogStats','Studio StarterKit Library > CORE COMPONENTS > 109 - General Cloud Logging');&#xd;
props['localSubAssemblyDetailMap'].put('Debug','Studio StarterKit Library > CORE COMPONENTS > 109 - General Cloud Logging');&#xd;
props['localSubAssemblyDetailMap'].put('CloudLogXSLTMessages','Studio StarterKit Library > CORE COMPONENTS &gt; 112 - XSLT / ETV / XTT Cloud Logging');&#xd;
props['localSubAssemblyDetailMap'].put('CloudLogETVXTTMessages','Studio StarterKit Library > CORE COMPONENTS > 112 - XSLT / ETV / XTT Cloud Logging');&#xd;
props['localSubAssemblyDetailMap'].put('IntegrationEventProgress','Studio StarterKit Library > CORE COMPONENTS > 108 - Integration Event Progress Update');&#xd;
props['localSubAssemblyDetailMap'].put('StaticCodeAnalysis','Studio StarterKit Library > CORE COMPONENTS > 121 - Static Code Analysis');&#xd;
props['localSubAssemblyDetailMap'].put('AddReportPromptFromProperty','Studio StarterKit Library > REPORTS AS A SERVICE > 101 - Build Reports-as-a-Service Report Prompts');&#xd;
props['localSubAssemblyDetailMap'].put('AddReportPromptFromXml','Studio StarterKit Library > REPORTS AS A SERVICE > 101 - Build Reports-as-a-Service Report Prompts');&#xd;
props['localSubAssemblyDetailMap'].put('CallRaaS','Studio StarterKit Library > REPORTS AS A SERVICE > 102 - Reports-as-a-Service Execution');&#xd;
props['localSubAssemblyDetailMap'].put('CallSoap','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 103 - Workday Web Service (SOAP) Execution');&#xd;
props['localSubAssemblyDetailMap'].put('CallSoapPaged','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 104 - Workday Web Service (SOAP) Paged Execution');&#xd;
props['localSubAssemblyDetailMap'].put('CallSoapImport','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 113 - Workday Web Service (SOAP) Import APIs (Process)');&#xd;
props['localSubAssemblyDetailMap'].put('FinalizeCallSoapImport','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 113 - Workday Web Service (SOAP) Import APIs (Process)');&#xd;
props['localSubAssemblyDetailMap'].put('ReportResultsOfCallSoapImport','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 118 - Workday Web Service (SOAP) Import APIs (Post-Process)');&#xd;
props['localSubAssemblyDetailMap'].put('GenerateOutput','Studio StarterKit Library > FILE UTILITIES > 106 - Output Generation');&#xd;
props['localSubAssemblyDetailMap'].put('GetDocumentList','Studio StarterKit Library > FILE UTILITIES > 110 - Build Retrieved File Metadata');&#xd;
props['localSubAssemblyDetailMap'].put('LoadFile','Studio StarterKit Library > FILE UTILITIES > 111 - Read File From Metadata');&#xd;
props['localSubAssemblyDetailMap'].put('GetDISResults','Studio StarterKit Library > FILE UTILITIES > 114 - Data Initialization Service (Single Threaded)');&#xd;
props['localSubAssemblyDetailMap'].put('GetDISResultsParallel','Studio StarterKit Library > FILE UTILITIES &gt; 115 - Data Initialization Service (Parallel Threading)');&#xd;
props['localSubAssemblyDetailMap'].put('PopulateJavaMap','Studio StarterKit Library > XSLT 3.0 > 105 - Populate Java Map');&#xd;
props['localSubAssemblyDetailMap'].put('StreamDataMerge','Studio StarterKit Library > XSLT 3.0 > 107 - Streaming Data Merge');</cc:expression>
                        <cc:expression>props['localSubAssemblyList'] = new java.util.ArrayList();&#xd;
props['localCoreList'] = new java.util.ArrayList();</cc:expression>
                        <cc:expression>foreach (key : props['localSubAssemblyDetailMap'].keySet()) {&#xd;
	if (org.apache.commons.lang3.StringUtils.contains(props['localSubAssemblyDetailMap'].get(key), 'CORE COMPONENTS')) {&#xd;
		props['localCoreList'].add(key);&#xd;
	}&#xd;
	props['localSubAssemblyList'].add(key);&#xd;
}&#xd;
props['localSubAssemblyList'] = util.listToCommaDelimString(props['localSubAssemblyList']);</cc:expression>
                        <cc:expression>if (props['inStaticCodeAnalysisExemptionList'] == empty) {&#xd;
	props['inStaticCodeAnalysisExemptionList'] = new java.util.ArrayList();&#xd;
}</cc:expression>
                        <cc:expression>props['localExemptionList'] = util.listToCommaDelimString(props['inStaticCodeAnalysisExemptionList']);</cc:expression>
                    </cc:eval>
                    <cc:eval id="UpdateDebug">
                        <cc:expression>props['globalDebugPropertyList'].add('localAssemblyXml');&#xd;
props['globalDebugPropertyList'].add('localSubAssemblyList');&#xd;
props['globalDebugPropertyList'].add('localExemptionList');</cc:expression>
                    </cc:eval>
                </cc:request-steps>
                <cc:response-steps/>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_InitializeAndFinalize_Error_121"/>
            </cc:sync-mediation>
            <cc:async-mediation id="Teardown_121">
                <cc:steps>
                    <cc:eval id="CleanUp">
                        <cc:expression>foreach (propname : ['localAssemblyXml','localSubAssemblyDetailMap','localSubAssemblyList','localCoreList','localExemptionList']) {&#xd;
	context.removeProperty(propname);&#xd;
}</cc:expression>
                    </cc:eval>
                    <cc:eval id="ReduceDebug">
                        <cc:expression>props['globalDebugPropertyList'].remove('localAssemblyXml');&#xd;
props['globalDebugPropertyList'].remove('localSubAssemblyList');&#xd;
props['globalDebugPropertyList'].remove('localExemptionList');</cc:expression>
                    </cc:eval>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-in id="Finally_121" routes-to="Teardown_121"/>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_InitializeAndFinalize_Error_121"
                store-message="none">
                <cc:set name="inLogMessage" value="'Static Code Analysis Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while preparing the control values to perform static analysis.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_121'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIsResetError" value="false"/>
                <cc:set name="inIncludeDebugOutput" value="props['globalIsDebugMode']"/>
                <cc:set name="inTargetType" value="'properties'"/>
                <cc:set name="inTargetName" value="'globalDebugPropertyList'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_121"
                id="Call_Finally_121"
                store-message="none"/>
            <cc:async-mediation
                id="DeadCode_121"
                routes-to="Call_Debug_Message_DeadCode_121">
                <cc:steps>
                    <cc:write id="WriteAssemblyToMsg" output-mimetype="text/xml">
                        <cc:message>
                            <cc:static-file input-file="@{props['localAssemblyXml']}"/>
                        </cc:message>
                    </cc:write>
                    <cc:xslt-plus
                        id="FindUnusedLocalIns"
                        output-mimetype="text/xml"
                        url="xslt/sa121/SA121_DeadCodeDetection.xsl"/>
                </cc:steps>
                <cc:send-error id="CatchError" routes-to="Call_HandleError_DeadCode_Error_121"/>
            </cc:async-mediation>
            <cc:splitter id="Splitter_DeadCode_121" no-split-message-error="false">
                <cc:sub-route
                    name="ReportDeadCode"
                    routes-to="Call_CreateLogEntry_DeadCode_Warn_121"/>
                <cc:xml-stream-splitter xpath="/*/*"/>
            </cc:splitter>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_DeadCode_Error_121"
                store-message="none">
                <cc:set name="inLogMessage" value="'Dead Code Analysis Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while performing the dead code portion of the static analysis.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_121'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIsResetError" value="false"/>
                <cc:set name="inIncludeDebugOutput" value="props['globalIsDebugMode']"/>
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set name="inEntityName" value="'StaticAnalysis_Assembly'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_DeadCode_Warn_121"
                store-message="none">
                <cc:set name="inLogMessage" value="'Potential Dead Code Detected'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'Static code analysis suggests that the sub-assembly defined by local-in with id=' # &#xd;&#xa;(parts[0].xpath('./text()')) # ' may not be used in the integration.  See Support Data for more details.'"/>
                <cc:set name="inLogLevel" value="'warn'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'Static code analysis does not read dynamic endpoints, so if you have referenced this sub-assembly dynamically, this may be a false-positive and you should make no code changes.  ' #&#xd;&#xa;'In this case, add your local-in id to the globalStaticCodeAnalysisExemptionList property in StaticCodeAnalysis@Initialize, which can be found in the InitializeFrameworkThenRunMain sub-assembly.  ' #&#xd;&#xa;'Otherwise, consider removing the sub-assembly from the ' # (props['localSubAssemblyDetailMap'].get(parts[0].xpath('./text()'))) # ' swimlane, or removing the entire swimlane if no other sub-assemblies in that swimlane are being used.'"/>
                <cc:set name="inExtraErrorCode" value="'12100'"/>
            </cc:local-out>
            <cc:route id="Route_121">
                <cc:all-strategy/>
                <cc:sub-route name="DeadCode" routes-to="DeadCode_121"/>
                <cc:sub-route name="MissingCode" routes-to="PrepareMissingCode_Assembly_121"/>
            </cc:route>
            <cc:splitter id="Splitter_MissingCode_121" no-split-message-error="false">
                <cc:sub-route
                    name="ReportMissingCode"
                    routes-to="Call_CreateLogEntry_MissingCode_Warn_121"/>
                <cc:xml-stream-splitter xpath="/*/*"/>
            </cc:splitter>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"
                id="Call_HandleError_MissingCode_Error_121"
                store-message="none">
                <cc:set name="inLogMessage" value="'Missing Code Analysis Error'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'An error occurred while performing the missing code portion of the static analysis.'"/>
                <cc:set name="inLogLevel" value="'error'"/>
                <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
                <cc:set
                    name="inExtraSupportData"
                    value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
                <cc:set
                    name="inExtraErrorCode"
                    value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
                <cc:set
                    name="inFinallyEndpoint"
                    value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_121'"/>
                <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
                <cc:set name="inIsResetError" value="false"/>
                <cc:set name="inIncludeDebugOutput" value="props['globalIsDebugMode']"/>
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set name="inEntityName" value="'StaticAnalysis_Assembly'"/>
            </cc:local-out>
            <cc:async-mediation
                id="MissingCode_121"
                routes-to="Call_Debug_Message_MissingCode_121">
                <cc:steps>
                    <cc:xslt-plus
                        id="FindDeletedCommonComponents"
                        output-mimetype="text/xml"
                        url="xslt/sa121/SA121_MissingCodeDetection.xsl"/>
                </cc:steps>
                <cc:send-error
                    id="CatchError"
                    routes-to="Call_HandleError_MissingCode_Error_121"/>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"
                id="Call_CreateLogEntry_MissingCode_Warn_121"
                store-message="none">
                <cc:set name="inLogMessage" value="'SSK Core Component Missing'"/>
                <cc:set
                    name="inLogMessageDetail"
                    value="'Static code analysis was unable to locate the SSK core component sub-assembly ' # &#xd;&#xa;(parts[0].xpath('./text()')) # '.  This may have been deleted from the integration.  See Support Data for more details.'"/>
                <cc:set name="inLogLevel" value="'warn'"/>
                <cc:set
                    name="inExtraSupportData"
                    value="'SSK core components should not be removed, even if identified as potential dead code in static analysis.  All other SSK sub-assemblies assume the core components as dependencies, and you may inadvertently break another sub-assembly in-use by removing a core component.  ' #&#xd;&#xa;'If a core component is being flagged in static analysis, then add the local-in id to the globalStaticCodeAnalysisExemptionList property in StaticCodeAnalysis@Initialize, which can be found in the InitializeFrameworkThenRunMain sub-assembly.  ' #&#xd;&#xa;'Otherwise, restore the deleted code for ' # (parts[0].xpath('./text()')) # ' in the ' # (props['localSubAssemblyDetailMap'].get(parts[0].xpath('./text()'))) # ' swimlane from a clean copy of SSK.'"/>
                <cc:set name="inExtraErrorCode" value="'12101'"/>
            </cc:local-out>
            <cc:local-out
                clone-request="true"
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StaticCodeAnalysis"
                id="Call_StaticCodeAnalysis"
                propagate-abort="false"
                routes-response-to="Call_StoreLog"
                store-message="none">
                <cc:set
                    name="inStaticCodeAnalysisExemptionList"
                    value="props['globalStaticCodeAnalysisExemptionList']"/>
                <cc:set name="inDebugMode" value="props['globalIsDebugMode']"/>
                <cc:set name="inIsAbortOnError" value="true"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_PropertyList_121"
                routes-response-to="Route_121"
                store-message="none">
                <cc:set name="inTargetType" value="'properties'"/>
                <cc:set name="inTargetName" value="'globalDebugPropertyList'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_Message_DeadCode_121"
                routes-response-to="Splitter_DeadCode_121"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set name="inEntityName" value="'StaticAnalysis_DeadCode'"/>
            </cc:local-out>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"
                execute-when="props['inDebugMode']"
                id="Call_Debug_Message_MissingCode_121"
                routes-response-to="Splitter_MissingCode_121"
                store-message="none">
                <cc:set name="inTargetType" value="'message'"/>
                <cc:set name="inEntityName" value="'StaticAnalysis_MissingCode'"/>
            </cc:local-out>
            <cc:aggregator
                collate-when="props['inCollate']"
                force-batch-on-last-message="false"
                force-batch-when="props['inBatch']"
                id="AggregateData_121">
                <cc:size-batch-strategy batch-size="-1"/>
                <cc:xml-message-content-collater output="message" output-mimetype="text/xml">
                    <cc:header-text>&lt;Root></cc:header-text>
                    <cc:footer-text>&lt;/Root></cc:footer-text>
                </cc:xml-message-content-collater>
            </cc:aggregator>
            <cc:local-in id="Aggregate_121" routes-to="AggregateData_121">
                <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
                <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
            </cc:local-in>
            <cc:async-mediation
                id="PrepareMissingCode_Assembly_121"
                routes-to="Call_Aggregate_Assembly_121">
                <cc:steps>
                    <cc:write id="WriteAssemblyToMsg" output-mimetype="text/xml">
                        <cc:message>
                            <cc:static-file input-file="@{props['localAssemblyXml']}"/>
                        </cc:message>
                    </cc:write>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_121"
                id="Call_Aggregate_Assembly_121"
                routes-response-to="PrepareMissingCode_Metadata_121"
                store-message="none">
                <cc:set name="inCollate" value="true"/>
                <cc:set name="inBatch" value="false"/>
            </cc:local-out>
            <cc:async-mediation
                id="PrepareMissingCode_Metadata_121"
                routes-to="Call_Aggregate_Metadata_121">
                <cc:steps>
                    <cc:write id="WriteMessage" output-mimetype="text/xml">
                        <cc:message>
                            <cc:text>&lt;SubAssemblies>&#xd;
	@foreach{props.localCoreList}&#xd;
	&lt;SubAssembly>@{item}&lt;/SubAssembly>&#xd;
	@end{}&#xd;
&lt;/SubAssemblies></cc:text>
                        </cc:message>
                    </cc:write>
                </cc:steps>
            </cc:async-mediation>
            <cc:local-out
                endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_121"
                id="Call_Aggregate_Metadata_121"
                routes-response-to="MissingCode_121"
                store-message="none">
                <cc:set name="inCollate" value="true"/>
                <cc:set name="inBatch" value="true"/>
            </cc:local-out>
        </cc:assembly>
        <bean
            class="com.workday.custom.int0025.int0025115.SimpleSplitter"
            id="SA115FileSplitter"/>
    </beans>
    <SubAssemblies>
        <SubAssembly>SetupLog</SubAssembly>
        <SubAssembly>CreateLogEntry</SubAssembly>
        <SubAssembly>Debug</SubAssembly>
        <SubAssembly>HandleError</SubAssembly>
        <SubAssembly>LogStats</SubAssembly>
        <SubAssembly>StaticCodeAnalysis</SubAssembly>
        <SubAssembly>StoreLog</SubAssembly>
        <SubAssembly>IntegrationEventProgress</SubAssembly>
        <SubAssembly>InitializeFrameworkThenRunMain</SubAssembly>
        <SubAssembly>CloudLogXSLTMessages</SubAssembly>
        <SubAssembly>CloudLogETVXTTMessages</SubAssembly>
    </SubAssemblies>
</Root>
