<?xml version="1.0" encoding="UTF-8"?>
<beans
     xmlns="http://www.springframework.org/schema/beans"
     xmlns:beans="http://www.springframework.org/schema/beans"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:cc="http://www.capeclear.com/assembly/10"
     xmlns:cloud="urn:com.workday/esb/cloud/10.0"
     xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"
     xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
     xmlns:pi="urn:com.workday/picof"
     xmlns:wd="urn:com.workday/bsvc"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 
	<cc:assembly id="WorkdayAssembly" version="2022.37">
        <cc:local-out id="PIM_Debug_Stats_Primary_142" store-message="none" execute-when="props['int0025PrimaryLogCountDebug'] > 0" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'DEBUG'"/>
            <cc:set name="is.message.summary" value="props['int0025PrimaryLogCountDebug'] + ' debug message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Info_Stats_Primary_142" store-message="none" execute-when="props['int0025PrimaryLogCountInfo'] > 0" routes-response-to="PIM_Debug_Stats_Primary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="props['int0025PrimaryLogCountInfo'] + ' informational message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Warning_Stats_Primary_142" store-message="none" execute-when="props['int0025PrimaryLogCountWarn'] > 0" routes-response-to="PIM_Info_Stats_Primary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'WARNING'"/>
            <cc:set name="is.message.summary" value="props['int0025PrimaryLogCountWarn'] + ' warning(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Error_Stats_Primary_142" store-message="none" execute-when="props['int0025PrimaryLogCountError'] > 0" routes-response-to="PIM_Warning_Stats_Primary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'ERROR'"/>
            <cc:set name="is.message.summary" value="props['int0025PrimaryLogCountError'] + ' error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Critical_Stats_Primary_142" store-message="none" execute-when="props['int0025PrimaryLogCountCritical'] > 0" routes-response-to="PIM_Error_Stats_Primary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'CRITICAL'"/>
            <cc:set name="is.message.summary" value="props['int0025PrimaryLogCountCritical'] + ' critical error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-in id="LogStatsPrimary" routes-to="PIM_Critical_Stats_Primary_142" access="private"/>
        <cc:local-out id="Call_LogStatsPrimary_142" execute-when="props['inLogFinalize']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/LogStatsPrimary"/>
        <cc:async-mediation id="OutputPrimaryLog_142" routes-to="PIM_PrimaryTag_142" execute-steps-when="props['localIsLogReady142']">
            <cc:steps>
                <cc:eval id="Setup">
                    <cc:expression>props['int0025PrimaryLogFilesStored'] = props['int0025PrimaryLogFilesStored'] + 1</cc:expression>
                    <cc:expression>if (props['int0025PrimaryLogFileFormat'] == 'HTML') {&#xD;
	props['localPrimaryLogFileExtension'] = '.html';&#xD;
} else if (props['int0025PrimaryLogFileFormat'] == 'CSV') {&#xD;
	props['localPrimaryLogFileExtension'] = '.csv';&#xD;
} else {&#xD;
	props['localPrimaryLogFileExtension'] = '.xlsx';&#xD;
}</cc:expression>
                    <cc:expression>props['localPrimaryLogFilenameForStorage'] = (props['int0025PrimaryLogMaxCountPerFile'] == 0) ? props['int0025PrimaryLogFilename'] # props['localPrimaryLogFileExtension'] : props['int0025PrimaryLogFilename'] # &quot;_&quot; # props['int0025PrimaryLogFilesStored'] # props['localPrimaryLogFileExtension']</cc:expression>
                </cc:eval>
                <cc:store id="StoreCloudLog" output="variable" output-variable="logStoreResult" input="variable" input-variable="cloud-log-primary" createDocumentReference="false" expiresIn="@{props['int0025PrimaryLogExpires']}" title="@{props['localPrimaryLogFilenameForStorage']}"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="StoreLogPrimary" routes-to="PrimaryDetermineOutput_142" access="public">
            <cc:parameter default="false" name="inLogFinalize" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_StoreLogPrimary_142" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLogPrimary">
            <cc:set name="inLogFinalize" value="false"/>
        </cc:local-out>
        <cc:local-in id="CreateLogEntry" routes-to="RoutePrimaryLogType_142" access="public" icon="icons/CreateLogEntry.png">
            <cc:parameter documentation="Value that will be written to the Message attribute of the Cloud Logger." name="inLogMessage" required="true" type="string"/>
            <cc:parameter documentation="Value that will be written to the Message Details attribute of the Cloud Logger." name="inLogMessageDetail" required="false" type="string"/>
            <cc:parameter documentation="Value that will be written to the Reference Id attribute of the Cloud Logger.  This is most commonly used to record the WID of the record to which this message pertains and can save the MVEL code of concatenating it into the Message Detail." name="inLogReferenceId" required="false" type="string"/>
            <cc:parameter documentation="Value that determines the Level attribute of the Cloud Logger.  Must be one of: debug, info, warn, error, critical." name="inLogLevel" required="true" type="string" validation="['debug','info','warn','error','critical'] contains props['inLogLevel'].trim().toLowerCase()"/>
            <cc:parameter documentation="Value written to the LocalIn Extra Column on the log.  This field is a convention of SSK and used to record the name of a Mediation related to the message, e.g. the errorComponentId causing an error to be raised." name="inExtraLocalIn" required="false"/>
            <cc:parameter documentation="Value written to the RecordNumber Extra Column on the log.  This field is a convention of SSK and used to record the position/count of a data record in a set to which this message pertains." name="inExtraRecordNumber" required="false"/>
            <cc:parameter documentation="Value written to the SupportData Extra Column on the log.  This field is a convention of SSK and used to provide open-ended advice for support.  This may constitute additional data values, or it may mean remediation advice for a particular error." name="inExtraSupportData" required="false"/><cc:parameter documentation="Value written to the ErrorCode Extra Column on the log.  This field is a convention of SSK and used to provide the value of the error code when the message is logging error information.  This code may be given by the ESB, or it may be a custom code defined by the developer.  Note that this field is a String whereas Studio/ESB codes are integers, so type conversion is required." name="inExtraErrorCode" required="false"/>
        </cc:local-in>
        <cc:local-out id="Call_StoreLogPrimary_GEH" routes-response-to="Call_StoreLogSecondary_GEH" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLogPrimary" propagate-abort="false">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="PIM_CriticalUnhandledException_GEH" store-message="none" routes-response-to="Call_StoreAllFlexLogs_GEH" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'CRITICAL'"/>
            <cc:set name="is.message.summary" value="'An unhandled error was encountered!'"/>
            <cc:set name="is.message.detail" value="'Error Message: ' + context.getErrorMessage()"/>
        </cc:local-out>
        <cc:send-error id="GlobalErrorHandler" routes-to="PIM_CriticalUnhandledException_GEH"/>
        <cc:local-out id="Call_StoreLogPrimary" store-message="none" routes-response-to="Call_StoreLogSecondary" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLogPrimary">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="Call_Main_109" store-message="none" endpoint="@{props['inMainEndpoint']}" propagate-abort="false"/>
        <cc:async-mediation id="Initialize_Handler_109">
            <cc:steps>
                <cc:eval id="Abort">
                    <cc:expression>context.setAbort(true);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_Error_109" store-message="none" routes-response-to="Call_StoreAllFlexLogs_Error_109" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'An error occurred within the integration flow and has been caught by the SSK framework.'"/>
            <cc:set name="inLogMessageDetail" value="'The exception was trapped at the top-level just before the Global Error Handler.  See the Support Detail for additional error information, and see the Local-In for the component at which the exception was raised.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            
        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inExtraSupportDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/></cc:local-out>
        <cc:async-mediation id="TopLevelErrorTrap_109" routes-to="Call_Debug_Core_109" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntry_Error_109"/>
        </cc:async-mediation>
        <cc:workday-in id="StartHere" routes-to="SSK152_ConfigurationSetup">
            <cc:integration-system name="INT0025_CheckWorkRights_VisaCheck_Inbound">
        <cloud:attribute-map-service name="INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - General">
          <cloud:attribute name="Document Retention in Days">
            <cloud:type>
              <cloud:simple-type>number</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Run with Debug Logging (Listener Service Only)">
            <cloud:type>
              <cloud:simple-type>boolean</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Run in Validation Mode (Listener Service Only)">
            <cloud:type>
              <cloud:simple-type>boolean</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
        </cloud:attribute-map-service>
        <cloud:attribute-map-service name="INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - Primary Logging">
          <cloud:attribute name="Log File Name (Exclude File Extension)">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Log Retention in Days">
            <cloud:type>
              <cloud:simple-type>number</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Max Entries per Log File">
            <cloud:type>
              <cloud:simple-type>number</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Cloud Log Output File Type">
            <cloud:type>
              <cloud:enumeration-type name="CloudLogOutputFileType">
                <cloud:enumeration>HTML</cloud:enumeration>
                <cloud:enumeration>CSV</cloud:enumeration>
                <cloud:enumeration>XLSX</cloud:enumeration>
              </cloud:enumeration-type>
            </cloud:type>
            <cloud:display-option>required-for-launch</cloud:display-option>
          </cloud:attribute>
          <cloud:attribute name="Tag for Log Aggregator (overrides Cloud Log Output File Type)">
            <cloud:type>
              <cloud:class-report-field description="Document Tag" type="WID" singular="false">5242ed284a574130affb6653f3e0d93b</cloud:class-report-field>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Tab Name for Log Aggregator">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
        </cloud:attribute-map-service>
        <cloud:attribute-map-service name="INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - Functional">
          <cloud:attribute name="Output File Name (Include File Extension)">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Delivery Document Tag(s)">
            <cloud:type>
              <cloud:class-report-field description="Document Tags" type="WID" singular="false">eef1d7fe8ea9408e85a43ce755c69ef2</cloud:class-report-field>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Retrieval Document Tag(s)">
            <cloud:type>
              <cloud:class-report-field description="Document Tag" type="WID" singular="false">5242ed284a574130affb6653f3e0d93b</cloud:class-report-field>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Retrieval Document Tag Match Strategy">
            <cloud:type>
              <cloud:enumeration-type name="DocumentTagMatchType">
                <cloud:enumeration>Any</cloud:enumeration>
                <cloud:enumeration>All</cloud:enumeration>
              </cloud:enumeration-type>
            </cloud:type>
          </cloud:attribute>
          <cloud:attribute name="Decryption Key">
            <cloud:type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:type>
            <cloud:display-option>required-for-launch</cloud:display-option>
            <cloud:display-option>display-as-password</cloud:display-option>
          </cloud:attribute>
          <cloud:map name="Workday Visa to CWR Visa">
            <cloud:internal-type>
              <cloud:class-report-field description="Visa ID Type" type="WID">df40ca5f2cd442caac4a58364b7ccf18</cloud:class-report-field>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="Visa Country">
            <cloud:internal-type>
              <cloud:class-report-field description="The country issuing the visa." type="WID">74a98319ab6a40d5aef487b2ddb2bee3</cloud:class-report-field>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="Passport Country">
            <cloud:internal-type>
              <cloud:class-report-field description="The country issuing the passport." type="WID">59391838ad464b359be146affca771da</cloud:class-report-field>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
          <cloud:map name="Passport ID Type">
            <cloud:internal-type>
              <cloud:class-report-field description="Passport ID Type" type="WID">98a4661985224f8da29d742859908060</cloud:class-report-field>
            </cloud:internal-type>
            <cloud:external-type>
              <cloud:simple-type>text</cloud:simple-type>
            </cloud:external-type>
          </cloud:map>
        </cloud:attribute-map-service>
        <cloud:listener-service name="INT0025 Listener Service - CWR Webhook"/>
      </cc:integration-system>
        </cc:workday-in>
        <cc:async-mediation id="InitializeAttributesAndLaunchParameters" routes-to="CallGetWebhookResponse" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="LaunchParameters">
                    <cc:expression>//SSK LP's are already taken care of&#xD;
//Add your own Launch Parameter handling for any LP's you might have added here&#xD;
//If additional launch paramaters are not needed, the LaunchParameters eval step can be deleted.&#xD;
</cc:expression>
                </cc:eval>
                <cc:eval id="IntegrationAttributes">
                    <cc:expression>//SSK Attributes are already taken care of&#xD;
//Add your own Integration Attribute handling here for any new services or new attributes you've added to already-defined services.&#xD;
//If additional attributes are not needed, the IntegrationAttributes eval step can be deleted.&#xD;
</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="HandleError_CustomLogic"/>
        </cc:async-mediation>
        <cc:async-mediation id="Results_Handler_103" routes-to="Call_HandleError_Results_Error_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Results_Error_103" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the SOAP results from the message rootpart to variable '# props['inReturnResults'] #'.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inReturnResults'"/>
            
         <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:async-mediation id="Results_103" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Results_Handler_103"/>
        </cc:async-mediation>
        <cc:async-mediation id="RouteError_Http_Handler_103" routes-to="Call_HandleError_HttpError_Error_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'http';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_HttpError_Error_103" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application HTTP request error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing a SOAP request for the '# props['inWebServiceApplication'] #' application.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? context.errorCode : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inWebServiceApplication']"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:async-mediation id="CallSoap_Catch_103" routes-to="CallSoap_103" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="RouteError_103"/>
        </cc:async-mediation>
        <cc:workday-out-soap id="CallSoap_103" store-message="none" routes-response-to="Call_Debug_SoapResponse_103" application="@{props['inWebServiceApplication']}" version="@{props['inApiVersion']}"/>
        <cc:sync-mediation id="InitializeAndFinalize_103" routes-to="Call_BuildRequest_103" routes-response-to="Call_Finally_103">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outIsSoapError'] = '';&#xD;
props['outErrorMessage'] = '';</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_103">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="wd-external-request-id"/>
                        <cc:remove-header name="wd-external-application-id"/>
                        <cc:remove-header name="wd-external-originator-id"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsQualifierTyped','localIsValueDefined','localIsValueTyped']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_103" routes-to="Teardown_103"/>
        <cc:local-out id="Call_Finally_103" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103"/>
        <cc:local-in id="CallSoap" routes-to="InitializeAndFinalize_103" access="public" icon="icons/CallSoap.png">
            <cc:parameter default="props['globalApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;." name="inWebServiceApplication" required="true" type="string"/>
            <cc:parameter documentation="The location that holds the data to be used in the transform provided on the inPathToXsltFile parameter.  This value is dependent on the value of inDataLocationId.  The parameter can have one of three values: message, variable, or property.  When the value is 'message', then the message part identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  Similarly, if this parameter value is 'variable', then the variable identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  if this parameter value is 'property', then the property identified by inDataLocationId is interpreted as a java.util.Map instance whose key/value pairs match pre-defined keys in the inPathToXsltFile xslt for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="props['inBuildRequestPathToXsltFile'] != empty" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (['message','variable','property'] contains props['inBuildRequestDataLocation'].trim().toLowerCase())) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocation'] == empty))"/>
            <cc:parameter documentation="The name that, when used with inBuildReqeustDataLocation, uniquely identifies which variable or property is to be used as the source data to which the transform provided on the inBuildReqeustPathToXsltFile parameter will be applied.  When inBuildReqeustDataLocation is 'message', then this parameter is ignored and the message root part is assumed." name="inBuildRequestDataLocationId" required="(props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message')" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message') &amp;&amp; (props['inBuildRequestDataLocationId'] != empty)) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocationId'] == empty))"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot; using the data identified by the inDataLocation and inDataLocationId input parameters.  This SSK Component also supports pre-built, on-message requests as well as facilities to construct the request dynamically.  If this parameter is omitted or set to null / an empty string, then inDataLocation and inDataLocationId can also be omitted (they are ignored), and then the dynamic request construction will be bypassed and the message root part will be used as the request." name="inBuildRequestPathToXsltFile" required="(props['inBuildRequestDataLocation'] != empty) || (props['inBuildRequestDataLocationId'] != empty)" type="string"/>
            <cc:parameter default="context.containsProperty('outRequestIdHeader119') ? props['outRequestIdHeader119'] : null" documentation="Optional value to be set to the wd-external-request-id HTTP header." name="inHeaderRequestId" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('outApplicationIdHeader119') ? props['outApplicationIdHeader119'] : null" documentation="Optional value to be set to the wd-external-application-id HTTP header." name="inHeaderApplicationId" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('outOriginatorIdHeader119') ? props['outOriginatorIdHeader119'] : null" documentation="Optional value to be set to the wd-external-originator-id HTTP header." name="inHeaderOriginatorId" required="false" type="string"/>
            <cc:parameter default="'message'" documentation="How the SOAP results are returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found.  " name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="'primary'" documentation="In the event of a SOAP error from the tenant, this parameter controls whether the message is logged to the primary or secondary logs.  Component processing, Studio validation messages, and hard HTTP errors will still go to the primary log, but data-level messages returned on the SOAP API will be directed per this configuration.  Note that the Extra Column configuration of the default secondary log is still coded and therefore assumed." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
            <cc:parameter default="context.containsProperty('outCloudLogFieldOverrideMap145') ? props['outCloudLogFieldOverrideMap145'] : null" documentation="This parameter provides the opportunity to specify a Java HashMap from a context property to replace the error values being reported internally by the component.  The map is keyed by the attribute name of the SSK141 HandleError input parameter, and the value is a string to be used in place of the SSK103 default.  If the map is not provided, or if a map is given but does not contain a key for the logged parameter, then the SSK103 default behavior applies.  If only a single value is desired to be changed from the out-of-the-box behavior, then a map with a single entry could be provided.  In some cases, the logged value is not available to be override, e.g. inLocalIn or inLogLevel when there are hard errors." name="inErrorLogOverrideMap" required="false"/>
        	
        	<cc:out-parameter documentation="A string to indicate that the request resulted in an error and identify the type.  If the error was at the API level, then outIsSoapError == 'http'.  If the error was at the tenant/application level, then outIsSoapError == 'soap'.  If there was an error unrelated to the API call, then outIsSoapError == 'logic'.  If there is no error, , then outIsSoapError == empty.  Further individual errors determined by Get_Event_Details or Get_Import_Processes are not handled here." name="outIsSoapError"/>
	        <cc:out-parameter documentation="The error message of the exception for possible higher-level logging needs." name="outErrorMessage"/>
	    </cc:local-in>
        <cc:sync-mediation id="LoadMap_105" routes-to="Call_LogXsltMessages_105">
            <cc:request-steps>
                <cc:xslt-plus id="LoadMap" messages-property="localMessages105" url="mctx:vars/localXslt105"/>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_LoadMap_Error_105"/>
        </cc:sync-mediation>
        <cc:sync-mediation id="PrepareForLoadMap_105" routes-to="LoadMap_105" routes-response-to="Call_Finally_105">
            <cc:request-steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10500" failure-message="Property 'inMap' does not contain a Java Map">map = props['inMap'];
return (map == null ) ||
	(( map != null) &amp;&amp; (map instanceof java.util.Map));</cc:expression>
                </cc:validate-exp>
                <cc:eval id="SetValues">
                    <cc:expression>props['outMap'] = props['inMap'];</cc:expression>
                    <cc:expression>// If the map property is not current assigned then create a new HashMap in it
if (props['outMap'] == empty) {&#xD;
	props['outMap'] = new java.util.HashMap();&#xD;
}</cc:expression>
                    <cc:expression>props['localMapPropertyName'] = 'outMap'</cc:expression>
                </cc:eval>
                <cc:write id="LoadXslt" output="variable" output-variable="localXslt105">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;xsl:stylesheet version=&quot;3.0&quot; &#xD;
    xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&#xD;
    xmlns:tube=&quot;java:com.capeclear.mediation.impl.cc.MediationTube&quot;&#xD;
    xmlns:ctx=&quot;java:com.capeclear.mediation.MediationContext&quot;&#xD;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&#xD;
    xmlns:jmap=&quot;java:java.util.Map&quot;&#xD;
    xmlns:jt=&quot;http://saxon.sf.net/java-type&quot;&#xD;
	xmlns:cl=&quot;java:com.workday.custom.int0025.ssk112.CloudLogEntry&quot; &#xD;
    xmlns:this=&quot;urn:this&quot;>&#xD;
    &#xD;
    &lt;xsl:param name=&quot;inStoreDataAs&quot; as=&quot;xs:string&quot;/>&#xD;
    &lt;xsl:param name=&quot;inQueryToEntry&quot; as=&quot;xs:string&quot;/>&#xD;
    &lt;xsl:param name=&quot;inQueryToKey&quot; as=&quot;xs:string&quot;/>&#xD;
    &lt;xsl:param name=&quot;inQueryToValue&quot; as=&quot;xs:string&quot;/>&#xD;
    &lt;xsl:param name=&quot;localMapPropertyName&quot; as=&quot;xs:string&quot;/>&#xD;
    &lt;xsl:param name=&quot;inEmptyValueIsError&quot; as=&quot;xs:boolean&quot; select=&quot;true()&quot;/>&#xD;
    &#xD;
    &lt;!-- This stylesheet is designed to be streamable so that only one record is held in memory at any one time -->&#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;shallow-skip&quot;/>&#xD;
    &lt;xsl:mode streamable=&quot;no&quot; name=&quot;in-memory&quot;/>&#xD;
    &#xD;
    &lt;!-- Obtain the current MediationContext in use in the assembly -->&#xD;
    &lt;xsl:variable name=&quot;ctx&quot; select=&quot;tube:getCurrentMediationContext()&quot;/>&#xD;
    &#xD;
    &lt;!-- Retrieve the Java Map stored in the context property named HashMap -->&#xD;
    &lt;xsl:variable name=&quot;Map&quot; select=&quot;ctx:getProperty($ctx, $localMapPropertyName)&quot; as=&quot;jt:java.util.Map&quot;/>&#xD;
    &#xD;
    &lt;!-- Based on the configuration of the StoreDataAs property determine the function which will be used to store the values in the map.  Using the function reference allows us to avoid the inefficiency of comparing the value of StoreDataAs for each entry -->&#xD;
    &lt;xsl:variable name=&quot;StoreDataInMap&quot; select=&quot;if ( $inStoreDataAs = 'SimpleString') then this:StoreDataAsSimpleString#2 else if ($inStoreDataAs = 'DOM') then this:StoreDataAsDOM#2 else this:StoreDataAsXMLString#2&quot; />&#xD;
    &#xD;
    &lt;xsl:template match=&quot;/&quot;>&#xD;
        &lt;MapHelper>&#xD;
            &lt;xsl:if test=&quot;$inStoreDataAs = 'XMLString'&quot;>&#xD;
				&lt;xsl:message>&lt;xsl:value-of select=&quot;cl:createMessage('warn', 'Warning generated during loading of Java Map', 'Map entries are configured to be stored as XMLStrings.  Using this will require that data is re-parsed every time the data is used.  This could impose a significant runtime performance overhead if each entry is, on average, accessed more than once.', '', '', 'LoadMap_105', '10501', '')&quot;/>&lt;/xsl:message>&#xD;
            &lt;/xsl:if>&#xD;
            &lt;xsl:if test=&quot;$inStoreDataAs = 'DOM'&quot;>&#xD;
				&lt;xsl:message>&lt;xsl:value-of select=&quot;cl:createMessage('warn', 'Warning generated during loading of Java Map', 'Map entries are configured to be stored as an XML DOM.  Using this option may require large amounts of memory.  Consider transforming the data before storage so as to only store the minimum required.  For very large documents consider moving to a custom Java solution with optimized data storage.', '', '', 'LoadMap_105', '10502', '')&quot;/>&lt;/xsl:message>&#xD;
            &lt;/xsl:if>&#xD;
            &#xD;
            &lt;!-- Now process the input file.  The EntryFilter variable can then be optionally used to only select those entries matching that value.  The filter can only navigate the descendant axis since only the node and and descendants returned by the QueryToEntry expression are brought into memory -->&#xD;
            &lt;xsl:apply-templates select=&quot;@{props['inQueryToEntry']}/copy-of()@if{props['inEntryFilter'] != empty}[@{props['inEntryFilter']}]@end{}&quot; mode=&quot;in-memory&quot;/>    		&#xD;
        &lt;/MapHelper>&#xD;
    &lt;/xsl:template>&#xD;
    &#xD;
    &lt;!-- Process each entry -->&#xD;
    &lt;xsl:template match=&quot;*&quot; mode=&quot;in-memory&quot;>&#xD;
        &lt;xsl:variable name=&quot;key&quot;	select=&quot;@{props['inQueryToKey']}&quot;/>&#xD;
        &lt;xsl:variable name=&quot;value&quot;	select=&quot;@{props['inQueryToValue']}&quot;/>&#xD;
        &#xD;
        &lt;xsl:choose>&#xD;
            &lt;!-- If we've no key then we have no option but to generate an error -->&#xD;
            &lt;xsl:when test=&quot;not(exists($key))&quot;>&#xD;
				&lt;xsl:message>&lt;xsl:value-of select=&quot;cl:createMessage('error', 'No key found during loading of Java Map', concat('No matching key found in record at ', $inQueryToKey, '.  See additional details for the specific record.'), '', '', 'LoadMap_105', '10503', normalize-space(serialize(.)))&quot;/>&lt;/xsl:message>&#xD;
            &lt;/xsl:when>&#xD;
            &#xD;
            &lt;!-- If we've no value and we're configured to treat no value as an error then output that error, otherwise we'll put the empty value into the map -->&#xD;
            &lt;xsl:when test=&quot;not(exists($value)) and $inEmptyValueIsError&quot;>&#xD;
				&lt;xsl:message>&lt;xsl:value-of select=&quot;cl:createMessage('error', 'Key has no value while loading Java Map', concat('No matching value found in record at ', $inQueryToValue, '.  See additional details for the specific record.'), $key, '', 'LoadMap_105', '10504', normalize-space(serialize(.)))&quot;/>&lt;/xsl:message>&#xD;
            &lt;/xsl:when>&#xD;
            &#xD;
            &lt;!-- Store the value in the map -->&#xD;
            &lt;xsl:otherwise>&#xD;
                &lt;xsl:value-of select=&quot;$StoreDataInMap($key,$value)&quot;/>&#xD;
            &lt;/xsl:otherwise>&#xD;
        &lt;/xsl:choose>&#xD;
    &lt;/xsl:template>&#xD;
    &#xD;
    &lt;xsl:function name=&quot;this:StoreDataAsSimpleString&quot;>&#xD;
        &lt;xsl:param name=&quot;key&quot; as=&quot;xs:string&quot;/>&#xD;
        &lt;xsl:param name=&quot;value&quot; as=&quot;item()?&quot;/>&#xD;
        &lt;xsl:value-of select=&quot;jmap:put($Map, string($key), string($value))&quot;/>&#xD;
    &lt;/xsl:function>&#xD;
    &#xD;
    &lt;xsl:function name=&quot;this:StoreDataAsXMLString&quot;>&#xD;
        &lt;xsl:param name=&quot;key&quot; as=&quot;xs:string&quot;/>&#xD;
        &lt;xsl:param name=&quot;value&quot; as=&quot;item()?&quot;/>&#xD;
        &lt;xsl:value-of select=&quot;jmap:put($Map, string($key), serialize($value))&quot;/>&#xD;
    &lt;/xsl:function>&#xD;
    &#xD;
    &lt;!-- &#xD;
    	This function is provided for future expansion.  There is no native way to export DOM information through Saxon Java extension functions such that the DOM (or NodeInfo) information can be processed&#xD;
    	elsewhere in the assembly since the Saxon Processor which was used to produce this information is not available to us outside of the XsltPlus step.&#xD;
    	&#xD;
    	In future, access to parsed DOM of the data will be provided through a Java extension function and a DOM implementation optimized for Workday-like data and map configurations.&#xD;
     -->&#xD;
    &lt;xsl:function name=&quot;this:StoreDataAsDOM&quot; >&#xD;
        &lt;xsl:param name=&quot;key&quot; as=&quot;xs:string&quot;/>&#xD;
        &lt;xsl:param name=&quot;value&quot; as=&quot;item()?&quot;/>&#xD;
		&lt;xsl:value-of select=&quot;jmap:put($Map, string($key), $value)&quot;/>&#xD;
		&lt;xsl:message terminate=&quot;yes&quot; select=&quot;'Storage of DOM values in the map are not yet implemented'&quot;/>&#xD;
	&lt;/xsl:function>&#xD;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
            </cc:request-steps>
            <cc:response-steps>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-in id="PopulateJavaMap" routes-to="PrepareForLoadMap_105" access="public" icon="icons/PopulateJavaMap.png">
            <cc:parameter documentation="The Java Map which is to be populated with the current message" name="inMap" required="false"/>
            <cc:parameter default="'SimpleString'" documentation="Determines whether the map will be populated with simple string values or an XML String" name="inStoreDataAs" required="false" validation="['SimpleString','XMLString'].contains(props['inStoreDataAs'])"/>
            <cc:parameter documentation="The XPath expression selecting the records which contain the information to be put into the Map" name="inQueryToEntry" required="true" type="string" validation="props['inQueryToEntry'].trim().length() > 0"/>
            <cc:parameter documentation="XPath expression which can optionally be executed against the elements returned by QueryToEntry in order to determine if those entries should be stored in the map" name="inEntryFilter" required="false" type="string"/>
            <cc:parameter documentation="The XPath expression to select the Map key from each record.  This expression is executed against the element returned by the QueryToEntry expression" name="inQueryToKey" required="true" type="string" validation="props['inQueryToKey'].trim().length() > 0"/>
            <cc:parameter documentation="The XPath expression which returns the value to be stored in the map when executed against the element returned by the QueryToEntry expression" name="inQueryToValue" required="true" type="string" validation="props['inQueryToValue'].trim().length() > 0"/>
            <cc:parameter default="true" documentation="Controls whether empty map values are to be treated as errors" name="inEmptyValueIsError" required="false" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
         	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
            <cc:out-parameter documentation="The Java Map which will have been populated with the data in the current message" name="outMap"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_Results_Error_102" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the RaaS results from the message rootpart to variable globalRaaSResults.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="Results_102" routes-to="Call_Debug_Result_102" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_102"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_CallRaaS_Error_102" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="CallRaaS_Catch_102" routes-to="CallRaaS_102" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CallRaaS_Error_102"/>
        </cc:async-mediation>
        <cc:workday-out-rest id="CallRaaS_102" store-message="none" extra-path="@{props['localRestUrl']}" method="GET"/>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_102" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_102" routes-to="ChooseProtocol_102" continue-after-error="rewind" handle-downstream-errors="true" routes-response-to="Call_Finally_102">
            <cc:request-steps>
                <cc:eval execute-when="!props['inIsForceUseSoap']" id="EvaluateParameters">
                    <cc:expression>props['localIsPromptsProvided'] = props['inPropertyNameReportPromptMap'] != empty;</cc:expression>
                    <cc:expression>props['localIsPromptsMap'] = (props['localIsPromptsProvided']) ? (context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map) : false;&#xD;
props['localIsPromptsEmpty'] = (props['localIsPromptsProvided']) ? (context.getProperty(props['inPropertyNameReportPromptMap']).isEmpty()) : false;</cc:expression>
                    <cc:expression>props['localIsPromptsValid'] = (!props['localIsPromptsProvided']) || (props['localIsPromptsMap'] &amp;&amp; !props['localIsPromptsEmpty']);</cc:expression>
                </cc:eval>
                <cc:validate-exp execute-when="!props['inIsForceUseSoap']" id="ValidateParameters">
                    <cc:expression error-number="10200" failure-message="The map contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap was either empty, or it was not a map.">props['localIsPromptsValid']</cc:expression>
                </cc:validate-exp>
                <cc:eval execute-when="!props['inIsForceUseSoap']" id="BuildURL">
                    <cc:expression>props['localRestUrl'] = intsys.reportService.getExtrapath(props['inReportServiceAlias']);</cc:expression>
                    <cc:expression>if (props['localIsPromptsProvided']) {&#xD;
	props['localRestUrl'] = (com.workday.custom.int0025.ssk102.ParameterMapHelper.getUrlWithPrompts(context, props.localRestUrl));&#xD;
}</cc:expression>
                    <cc:expression>props['localIsValidUrlLength'] = props['localRestUrl'].getBytes().length &lt;= 16000;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_102"/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_102">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsPromptsProvided','localIsPromptsValid','localRestUrl','localIsPromptsMap','localIsPromptsEmpty','localFilename','localProgressedToAPI','localIsValidUrlLength']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localStoreResult_102']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_102" routes-to="Teardown_102"/>
        <cc:local-out id="Call_Finally_102" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102"/>
        <cc:local-in id="CallRaaS" routes-to="InitializeAndFinalize_102" access="public" icon="icons/CallRaaS.png">
            <cc:parameter documentation="The Report Service configuration from which to retrieve results." name="inReportServiceAlias" required="true" type="string"/>
            <cc:parameter default="false" documentation="Controls whether or not the RaaS results are saved to a file that is then attached to the Integration Event for support purposes." name="inSaveResultsToIntegrationEvent" required="true" type="boolean"/>
            <cc:parameter default="props['int0025DocumentRetentionPeriod']" documentation="The duration to keep the RaaS result stored to the event when the inSaveResultsToIntegrationEvent parameter is true.  Value is of the format &quot;P&quot; followed by a number followed by &quot;D&quot;.  This evaluates to a number of days." name="inDocumentRetentionPeriod" required="props['inSaveResultsToIntegrationEvent']" type="string"/><cc:parameter documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  If the report is not parameterized, then leave this input parameter empty.  If setting this input parameter though, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap." name="inPropertyNameReportPromptMap" required="false" type="string"/><cc:parameter default="false" documentation="Parameter decides how the prompt values are URLEncoded.  True = use java.net.URLEncoder, which encodes the most characters possible.  False = use implementation in ParameterMapHelper that encodes the minimum characters necessary." name="inIsUseJavaUrlEncoder" required="true" type="boolean"/><cc:parameter default="'message'" documentation="Where the results of the response are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/><cc:parameter default="false" documentation="When this parameter is set to true, the default preference of the component to use REST will be suppressed.  The REST URL will not be built and checked for length; execution will pass directly to SOAP." name="inIsForceUseSoap" required="true" type="boolean"/><cc:parameter default="'message'" documentation="If the inIsForceUseSoap is set to TRUE, then there is an assumption that you have already pre-built a SOAP request.  This parameter identifies where that request can be found." name="inForceSoapSourceOfRequest" required="props['inIsForceUseSoap']" type="string"/><cc:parameter default="false" documentation="If the inIsForceUseSoap is set to TRUE, then there may be additional processing (such as tapestry aggregation) and the SOAP unwrap can be handled at once with that processing and could be skipped here." name="inForceSoapIsSkipUnwrap" required="props['inIsForceUseSoap']" type="boolean" validation="!props['inIsForceUseSoap'] || !props['inForceSoapIsSkipUnwrap'] || (props['inIsForceUseSoap'] &amp;&amp; props['inForceSoapIsSkipUnwrap'])"/>
        </cc:local-in>
        <cc:local-in id="LoadFile" routes-to="LoadFile_111" access="public" icon="icons/LoadFile.png">
            
            <cc:parameter documentation="The name of the file as known in the results of GetEventDocuments and written into the /Documents/Document/Filename results element.  This is used from error reporting if necessary." name="inFilename" required="false" type="string"/><cc:parameter documentation="The Cloud Collection value returned by GetEventDocuments and available through the GetDocumentList (SSK110) component.  In conjunction with the inEntryID parameter, this is essential to retrieving the document contents from the blobitory." name="inCollection" required="true" type="string"/><cc:parameter documentation="The Document Entry ID value returned by GetEventDocuments and available through the GetDocumentList (SSK110) component.  In conjunction with the inCollection parameter, this is essential to retrieving the document contents from the blobitory." name="inEntryID" required="true" type="string"/>
			<cc:parameter default="'message'" documentation="How the file contents are returned to the caller, either on the message if the value is 'message', which is the default, or if the value is 'variable', then the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="PIM_Tag_106" store-message="none" endpoint="vm://wcc/PutIntegrationMessage">
            <cc:set name="is.event.wid" value="props['inTargetEventWID']"/><cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="'Saved file '# props['inOutputFilename'] #' to the Integration Event.'"/>
            <cc:set name="is.document.variable.name" value="'localStoreResult106'"/><cc:set name="is.document.file.name" value="props['inOutputFilename']"/>
            <cc:set name="is.document.deliverable" value="props['inOutputIsDeliverable'] ? 'true' : 'false'"/>
            <cc:set name="is.document.retrieved" value="props['inOutputIsRetrieved'] ? 'true' : 'false'"/><cc:set name="is.document.labels" value="props['inOutputDocumentTags'] != empty ? util.listToCommaDelimString(props['inOutputDocumentTags']) : null"/>
            
            
        <cc:set name="is.message.storage.enabled" value="false"/><cc:set name="is.message.secured.instance.refs" value="context.containsProperty('localSecuredRefs') ? props['localSecuredRefs'] : null"/><cc:set name="is.message.secured.instance.refs.type" value="context.containsProperty('localSecuredRefs') ? props['inSecuredInstanceRefTypes'] : null"/></cc:local-out>
        <cc:local-out id="Call_HandleError_StoreVariable_Error_106" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Storage Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while storing data to the Integration Event.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-in id="GenerateOutput" routes-to="InitializeAndFinalize_106" access="public" icon="icons/GenerateOutput.png">
            <cc:parameter default="'message'" documentation="Where to find the data to be output.  If the value is 'message', then the contents of the message root part will be written.  Otherwise, the value is interpreted as the name of a variable where the data will be found." name="inDataSource" required="true" type="string"/><cc:parameter default="context.containsProperty('int0025EventWID') ? props['int0025EventWID'] : lp.integrationEventWID" documentation="The WID of the Integration Event to which the document should be attached.  This need not be the current event, although it will default as such." name="inTargetEventWID" required="true" type="string"/>
            
            <cc:parameter default="context.containsProperty('int0025OutputFilename') ? props['int0025OutputFilename'] : null" documentation="The filename of the file to be produced.  This may be provided as an Integration Attribute, and is defaulted as such.  This may also be produced by a Sequence Generator and provided here.  The name should include an extension, which would also include the .pgp extension if encrypted." name="inOutputFilename" required="true" type="string"/>
            
            <cc:parameter default="props['int0025DocumentRetentionPeriod']" documentation="The duration to keep the output file.  Value is of the format &quot;P&quot; followed by a number followed by &quot;D&quot;.  This evaluates to a number of days." name="inDocumentRetentionPeriod" required="true" type="string"/>
            <cc:parameter default="context.containsProperty('int0025DeliveryDocTag') ? props['int0025DeliveryDocTag'] : null" documentation="An optional list of Document Tag(s) to be placed on the file to facilitate ease of identification on the Integration Event.  The parameter should be passed as a list data structure containing the Document_Tag_Name reference id of the Tag as a string.  For example, props['listOfTags'] = new java.util.ArrayList();  props['listOfTags'].add('INT_Document_TagName');" name="inOutputDocumentTags" required="false"/>
            <cc:parameter default="false" documentation="A boolean flag to specify if the file being produced should be considered deliverable.  This facilitates identification by a Document Delivery service." name="inOutputIsDeliverable" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="A boolean flag to specify if the file being produced should be considered retrieved.  This facilitates identification by post-processor integration systems for further processing and is especially useful when building a pre-processor to a connector dependent on that tag." name="inOutputIsRetrieved" required="false" type="boolean"/><cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/><cc:parameter documentation="A list of Reference IDs (by default, WIDs, but other types are supported in conjunction with the inSecuredInstanceRefTypes parameter) to which file access is restricted.  The list may either be given as an ArrayList of Strings, or as a String that is a comma-separated list of the IDs." name="inSecuredInstanceRefs" required="false" validation="(props['inSecuredInstanceRefs'] == empty) || (props['inSecuredInstanceRefs'] instanceof java.lang.String) || (props['inSecuredInstanceRefs'] instanceof java.util.List)"/><cc:parameter default="'WID'" name="inSecuredInstanceRefTypes" required="props['inSecuredInstanceRefs'] != empty" type="string"/><cc:parameter default="false" documentation="Boolean flag indicating that the data should be compressed prior to storing the output file.  The inOutputFilename parameter should reflect the appropriate file extension for the selected compression." name="inIsCompressOutput" required="false" type="boolean"/><cc:parameter default="'zip'" documentation="If inIsCompressOutput = TRUE, then indicate the compression format to be used." name="inCompressionFormat" required="context.containsProperty('inIsCompressOutput') &amp;&amp; props['inIsCompressOutput']" type="string" validation="(!context.containsProperty('inIsCompressOutput') || !props['inIsCompressOutput']) || &#xD;&#xA;(props['inIsCompressOutput'] &amp;&amp; (['tar','zip'] contains props['inCompressionFormat'].trim().toLowerCase()))"/><cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntry_SingleFileProceed_Info_110" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'A Document Retrieval Service file was found and loaded.'"/>
            <cc:set name="inLogMessageDetail" value="props['outFileCount110'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(SingleFileProceed)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['outFileCount110'])"/>
            
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_MultipleFilesProceed_Info_110" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Multiple retrieved files were found.'"/>
            <cc:set name="inLogMessageDetail" value="props['outFileCount110'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
            <cc:set name="inLogReferenceId" value="String.valueOf(props['outFileCount110'])"/>
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(MultipleFilesProceed)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['outFileCount110'])"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_MultipleFilesCountError_Error_110" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'The expected number of files was not found!'"/>
            <cc:set name="inLogMessageDetail" value="props['outFileCount110'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  However, '# props['inExactFileCountExpected'] #' files(s) were expected.'"/>
            
            <cc:set name="inLogLevel" value="props.inLogLevelMultipleCountException"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(MultipleFilesCountError)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['outFileCount110'])"/>
            
        	<cc:set name="inExtraErrorCode" value="'11002'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
	        <cc:set name="inTargetType" value="'properties'"/>
	        <cc:set name="inTargetName" value="'int0025DebugPropertyList'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_MultipleFilesError_Error_110" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Too many retrieved files were found!'"/>
            <cc:set name="inLogMessageDetail" value="props['outFileCount110'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  Only a single file is expected.  A multiple-data condition is an error and the output of the Document Retrieval Service should be investigated.'"/>
            
            <cc:set name="inLogLevel" value="props.inLogLevelMultipleFoundException"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(MultipleFilesError)'"/>
            <cc:set name="inExtraRecordNumber" value="String.valueOf(props['outFileCount110'])"/>
            
        	<cc:set name="inExtraErrorCode" value="'11001'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
	        <cc:set name="inTargetType" value="'properties'"/>
	        <cc:set name="inTargetName" value="'int0025DebugPropertyList'"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_NoFileProceed_Info_110" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'No retrieved file was found.'"/>
            <cc:set name="inLogMessageDetail" value="props['outFileCount110'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.'"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(NoFileProceed)'"/>
            <cc:set name="inExtraRecordNumber" value="'0'"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_NoFileError_Error_110" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'No retrieved file was found!'"/>
            <cc:set name="inLogMessageDetail" value="props['outFileCount110'] # ' file(s) were found as generated from the Document Retrieval Service on the BP.  Data is expected.  A no-data condition is an error and the output of the Document Retrieval Service should be investigated.'"/>
            
            <cc:set name="inLogLevel" value="props.inLogLevelNoneFoundException"/>
            <cc:set name="inExtraLocalIn" value="'RouteOnCount_110(NoFileError)'"/>
            <cc:set name="inExtraRecordNumber" value="'0'"/>
            
        	<cc:set name="inExtraErrorCode" value="'11000'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
	        <cc:set name="inTargetType" value="'properties'"/>
	        <cc:set name="inTargetName" value="'int0025DebugPropertyList'"/>
	    </cc:local-out>
        <cc:route id="RouteOnCount_110">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inNoFileThrowsException'] &amp;&amp; props['outFileCount110'] == 0" route="NoFileError"/>
                <cc:choose-route expression="(!props['inNoFileThrowsException']) &amp;&amp; props['outFileCount110'] == 0" route="NoFileProceed"/>
                <cc:choose-route expression="props['inMultipleFilesThrowsException'] &amp;&amp; props['outFileCount110'] > 1" route="MultipleFilesError"/>
                <cc:choose-route expression="(!props['inMultipleFilesThrowsException']) &amp;&amp; props['inExactFileCountExpected'] > 0 &amp;&amp; (props['outFileCount110'] != props['inExactFileCountExpected'])" route="MultipleFilesCountError"/>
                <cc:choose-route expression="(!props['inMultipleFilesThrowsException']) &amp;&amp; (props['inExactFileCountExpected'] == -1 || props['outFileCount110'] == props['inExactFileCountExpected']) &amp;&amp; props['outFileCount110'] > 1" route="MultipleFilesProceed"/>
                <cc:choose-route expression="true" route="SingleFileProceed"/>
            </cc:mvel-strategy>
            <cc:sub-route name="NoFileError" routes-to="Call_HandleError_NoFileError_Error_110"/>
            <cc:sub-route name="NoFileProceed" routes-to="Call_CreateLogEntry_NoFileProceed_Info_110"/>
            <cc:sub-route name="MultipleFilesError" routes-to="Call_HandleError_MultipleFilesError_Error_110"/>
            <cc:sub-route name="MultipleFilesCountError" routes-to="Call_HandleError_MultipleFilesCountError_Error_110"/>
            <cc:sub-route name="MultipleFilesProceed" routes-to="Call_CreateLogEntry_MultipleFilesProceed_Info_110"/>
            <cc:sub-route name="SingleFileProceed" routes-to="Call_CreateLogEntry_SingleFileProceed_Info_110"/>
        </cc:route>
        <cc:async-mediation id="DocumentAccessor_110" routes-to="Call_Debug_Filter_110" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('int0025DebugPropertyList')) {&#xD;
	props['int0025DebugPropertyList'].add('inNoFileThrowsException');&#xD;
	props['int0025DebugPropertyList'].add('inMultipleFilesThrowsException');&#xD;
	props['int0025DebugPropertyList'].add('inExactFileCountExpected');&#xD;
	props['int0025DebugPropertyList'].add('localTagFilter');&#xD;
	props['int0025DebugPropertyList'].add('outFileCount110');&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="InitValues">
                    <cc:expression>props['localTagFilter'] = '';</cc:expression>
                    <cc:expression>if ((props['inRetrievalDocTag'] != empty) &amp;&amp; (props['inRetrievalDocTagType'] == 'All')) {&#xD;
	props['localTagFilter'] = '';&#xD;
	foreach (tag : props['inRetrievalDocTag']) {&#xD;
		props['localTagFilter'] = props['localTagFilter'] # '[wd:Document_Tag_Reference/wd:ID[@wd:type=\'WID\'] = \'' # tag # '\']';&#xD;
	}&#xD;
}</cc:expression>
                    <cc:expression>if ((props['inRetrievalDocTag'] != empty) &amp;&amp; (props['inRetrievalDocTagType'] == 'Any')) {&#xD;
	numOfTags = props['inRetrievalDocTag'].size();&#xD;
	counter = 1;&#xD;
&#xD;
	props['localTagFilter'] = '[wd:Document_Tag_Reference/wd:ID[@wd:type=\'WID\'] = (';&#xD;
	foreach (tag : props['inRetrievalDocTag']) {&#xD;
		props['localTagFilter'] = props['localTagFilter'] # '\'' # tag # '\'' # ((counter &lt; numOfTags) ? ',' : '');&#xD;
		counter = counter + 1;&#xD;
	}&#xD;
	props['localTagFilter'] = props['localTagFilter'] # ')]';&#xD;
}</cc:expression>
                </cc:eval>
                <cc:write id="WriteXSLT" output="variable" output-variable="localXslt110">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;xsl:stylesheet &#xD;
	xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&#xD;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&#xD;
    xmlns:env=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&#xD;
	xmlns:wd=&quot;urn:com.workday/bsvc&quot;&#xD;
    exclude-result-prefixes=&quot;#all&quot;&#xD;
    version=&quot;3.0&quot;>&#xD;
    &#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;shallow-skip&quot;/>&#xD;
    &lt;xsl:mode name=&quot;in-memory&quot; streamable=&quot;no&quot;/>&#xD;
    &#xD;
    &lt;xsl:output indent=&quot;no&quot;/>&#xD;
    &#xD;
    &lt;xsl:template match=&quot;/&quot;>&#xD;
        &lt;Documents>&#xD;
            &lt;xsl:apply-templates select=&quot;env:Envelope/env:Body/wd:Get_Event_Documents_Response/wd:Response_Data/wd:Event_Documents/wd:Repository_Document/copy-of()&quot; mode=&quot;in-memory&quot;/>&#xD;
        &lt;/Documents>&#xD;
    &lt;/xsl:template>&#xD;
&#xD;
    &lt;xsl:template match=&quot;wd:Repository_Document&quot; mode=&quot;in-memory&quot;>&#xD;
        &lt;xsl:apply-templates select=&quot;wd:Repository_Document_Data/copy-of()@if{props['localTagFilter'] != empty}@{props['localTagFilter']}@end{}&quot; mode=&quot;in-memory&quot;>&#xD;
        	&lt;xsl:with-param name=&quot;wid&quot; select=&quot;wd:Repository_Document_Reference/wd:ID[@wd:type='WID']&quot;/>&#xD;
       	&lt;/xsl:apply-templates>&#xD;
    &lt;/xsl:template>&#xD;
&#xD;
    &lt;xsl:template match=&quot;wd:Repository_Document_Data&quot; mode=&quot;in-memory&quot;>&#xD;
    	&lt;xsl:param name=&quot;wid&quot;/>&#xD;
    	&#xD;
	    &lt;Document>&#xD;
	    	&lt;xsl:attribute name=&quot;id&quot; select=&quot;@wd:Document_ID&quot;/>&#xD;
	    	&lt;xsl:attribute name=&quot;wid&quot; select=&quot;$wid&quot;/>&#xD;
	    	&lt;Collection>&lt;xsl:value-of select=&quot;substring-before(@wd:Document_ID, '/')&quot;/>&lt;/Collection>&#xD;
	    	&lt;EntryID>&lt;xsl:value-of select=&quot;substring-after(@wd:Document_ID, '/')&quot;/>&lt;/EntryID>&#xD;
	    	&lt;Filename>&lt;xsl:value-of select=&quot;@wd:File_Name&quot;/>&lt;/Filename>&#xD;
	    	&lt;Filesize>&lt;xsl:value-of select=&quot;wd:File_Size&quot;/>&lt;/Filesize>&#xD;
	    	&lt;Mimetype>&lt;xsl:value-of select=&quot;wd:Content_Type_Reference/wd:ID[@wd:type = 'Content_Type_ID']&quot;/>&lt;/Mimetype>&#xD;
            &lt;xsl:for-each select=&quot;wd:Document_Tag_Reference/wd:ID[@wd:type = ('Document_Tag_Name','Workday_Document_Tag_Name')]&quot;>&#xD;
                &lt;Tag>&lt;xsl:value-of select=&quot;.&quot;/>&lt;/Tag>&#xD;
            &lt;/xsl:for-each>&#xD;
	    &lt;/Document>&#xD;
    &lt;/xsl:template>&#xD;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
                <cc:xslt-plus id="FilterEventDocuments" url="mctx:vars/localXslt110"/>
                <cc:xslt-plus id="CountRecords" output="variable" output-mimetype="text/xml" output-variable="localRecordCount110" url="xslt/ssk110/SSK110_CountRecords.xsl"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['outFileCount110'] = (int)vars['localRecordCount110'].xstream('/totalRecords');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DocumentAccessor_Error_110"/>
        </cc:async-mediation>
        <cc:local-out id="GetEventDocuments_110" store-message="none" routes-response-to="Call_Debug_GetEventDocuments_110" endpoint="vm://wcc/GetEventDocuments">
            <cc:set name="ie.event.wid" value="props['inEventWID']"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_110" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'GetEventDocuments Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while calling Get_Event_Documents.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_110" routes-to="GetEventDocuments_110" handle-downstream-errors="true" routes-response-to="Call_Finally_110">
            <cc:request-steps/>
            <cc:response-steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>if (props.inReturnResults != 'message') {&#xD;
	vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:response-steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_110"/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_110">
            <cc:steps>
                <cc:eval id="CleanUp">
						<cc:expression>foreach (propname : ['localTagFilter']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localXslt110','localRecordCount110']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
					</cc:eval>
                <cc:eval id="ReduceDebug">
                    <cc:expression>if (context.containsProperty('int0025DebugPropertyList')) {&#xD;
	props['int0025DebugPropertyList'].remove('outFileCount110');&#xD;
	props['int0025DebugPropertyList'].remove('inNoFileThrowsException');&#xD;
	props['int0025DebugPropertyList'].remove('inMultipleFilesThrowsException');&#xD;
	props['int0025DebugPropertyList'].remove('inExactFileCountExpected');&#xD;
	props['int0025DebugPropertyList'].remove('localTagFilter');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_110" routes-to="Teardown_110"/>
        <cc:local-out id="Call_Finally_110" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110">
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:local-in id="GetDocumentList" routes-to="InitializeAndFinalize_110" access="public" icon="icons/GetDocumentList.png">
            <cc:parameter default="context.containsProperty('int0025DebugWID') ? props['int0025DebugWID'] : props['int0025EventWID']" documentation="WID of the Integration Event from which the documents will be queried.  This is typically the current event, and as such, is defaulted to the current event WID.  However, changing this WID enables retrieving documents from another related event for processing." name="inEventWID" required="true" type="string"/>
            <cc:parameter default="true" documentation="Controls whether or not an exception is thrown when there are no input files to the Integration Event.  TRUE means an exception will be thrown.  FALSE means no exception will be thrown." name="inNoFileThrowsException" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not an exception is thrown when there are multiple input files to the Integration Event.  TRUE means an exception will be thrown.  FALSE means no exception will be thrown." name="inMultipleFilesThrowsException" required="true" type="boolean"/>
            <cc:parameter default="-1" documentation="Specifies an exact number of files to be expected on the Integration Event.  If a variable number of input files is supported, then this should be passed as -1." name="inExactFileCountExpected" required="false" type="integer" validation="props['inExactFileCountExpected'] == -1 || props['inExactFileCountExpected'] > 0"/>
            <cc:parameter default="context.containsProperty('int0025RetrievalDocTag') ? props['int0025RetrievalDocTag'] : null" documentation="Specifies a Document Tag for filtering the input files on the Integration Event.  If not specified, parameter will try to use the value of the Retrieval Document Tag Integration Attribute." name="inRetrievalDocTag" required="false"/>
            <cc:parameter default="context.containsProperty('int0025RetrievalDocTagType') ? props['int0025RetrievalDocTagType'] : null" documentation="Specifies a strategy for how to use the Document Tags given in the inRetrievalDocTag parameter for filtering the input files on the Integration Event.  If &quot;Any&quot; is given, then any file file that matches at least one of the given tags will be returned.  If &quot;All&quot; is specified, then only files that match every given tag will be returned." name="inRetrievalDocTagType" required="props['inRetrievalDocTag'] != empty" type="string"/><cc:parameter default="'message'" documentation="Where the results of the response are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/><cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the GetEventDocuments results are output on debug as well as context properties in error conditions." name="inDebugMode" required="true" type="boolean"/><cc:parameter default="'error'" documentation="The log level for the message when no file is found." name="inLogLevelNoneFoundException" required="true" type="string"/><cc:parameter default="'error'" documentation="The log level for the message when multiple files are found, but no more than one is expected." name="inLogLevelMultipleFoundException" required="true" type="string"/><cc:parameter default="'error'" documentation="The log level for the message when multiple files are found, but the exact number expected is not found." name="inLogLevelMultipleCountException" required="true" type="string"/>
        <cc:out-parameter documentation="The number of files identified and for which blobitory metadata is being returned." name="outFileCount110"/></cc:local-in>
        <cc:local-in id="Main" routes-to="InitializeAttributesAndLaunchParameters"/>
        <cc:local-out id="Call_HandleError_SoapError_Error_103" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] # ' application SOAP request error'"/>
            <cc:set name="inLogMessageDetail" value="parts[0].xstream('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault/faultstring')"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="parts[0].xstream('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault/faultcode')"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraErrorCode" value="'10307'"/><cc:set name="inExtraSupportData" value="org.apache.commons.lang3.StringUtils.normalizeSpace(parts[0].xstreamF('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault/detail'))"/>
        	
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inWebServiceApplication'] # '.xml'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inLogTarget" value="props['inLogTarget']"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:async-mediation id="RouteError_Soap_Handler_103" routes-to="Call_HandleError_SoapError_Error_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'soap';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_StoreLogPrimary_Error_109" store-message="none" routes-response-to="Call_StoreLogSecondary_Error_109" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLogPrimary">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-in id="Debug" routes-to="Debug_InitializeAndFinalize_144" access="public" icon="icons/Debug.png">
        	<cc:parameter default="'message'" documentation="The type of information to be output to the log." name="inTargetType" required="true" type="string" validation="props['int0025DebugTargetTypeValidation'].contains(props['inTargetType'])"/>
        	<cc:parameter documentation="The reference name to use for single-named output types selected on inTargetType.  Required when inTargetType is one of: property, variable, list, map, or set." name="inTargetName" required="false" type="string" validation="props['int0025DebugTargetNameValidation'].contains(props['inTargetType']) &amp;&amp;&#xD;&#xA;(props['inTargetName'] != empty || props['inEntityName'] != empty)"/>
        	<cc:parameter documentation="A specific filename to use when exporting the message or variable content to a file zipped in a consolidated archive.  This is optional and only used when inTargetType is &quot;message&quot; or &quot;variable&quot;." name="inEntityName" required="false" type="string"/>
            <cc:parameter default="''" documentation="This parameter is related to when the inTargetType is is either 'message' or 'variable'.  When the inEntityName is not specified in those cases, the component will auto-generate an entity name for the file being aggregated to the debug zip archive.  The targetName is used as the prefix of the filename for variables, and 'rootpart' is used for message.  If inEntitySuffix is provided instead of inEntityName, an underscore is appended to the target name, followed by this value.  The DebugBean will make the value safe for filename use.  If inEntityName is given, then this parameter will be ignored.  If this parameter is set with an inTargetType other than message or variable, it is also ignored." name="inEntitySuffix" required="false" type="string"/><cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        	<cc:out-parameter documentation="If a file has been written to the debug archive, the name of that file will be returned for further reference in logging messages." name="outEntityName"/>
        <cc:out-parameter documentation="A boolean that is set to true on exit of this SSK Component under specific input parameter conditions to signal in the completion of the event that the archive needs to finalized and attached." name="outDebugLogged144"/></cc:local-in>
        <cc:route id="RouteType_144">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inTargetType'] == 'message'" route="Message"/>
                <cc:choose-route expression="props['inTargetType'] == 'property'" route="Property"/>
                <cc:choose-route expression="props['inTargetType'] == 'properties'" route="Properties"/>
                <cc:choose-route expression="props['inTargetType'] == 'variable'" route="Variable"/>
                <cc:choose-route expression="props['inTargetType'] == 'map'" route="Map"/>
                <cc:choose-route expression="props['inTargetType'] == 'list'" route="List"/>
                <cc:choose-route expression="props['inTargetType'] == 'set'" route="Set"/>
                <cc:choose-route expression="props['inTargetType'] == 'finalize'" route="Finalize"/>
                <cc:choose-route expression="true" route="Undefined"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Message" routes-to="RouteThread_Message_144"/>
            <cc:sub-route name="Property" routes-to="MessageValues_Property_144"/>
            <cc:sub-route name="Properties" routes-to="RouteProperties_144"/>
            <cc:sub-route name="Variable" routes-to="RouteThread_Variable_144"/>
            <cc:sub-route name="Map" routes-to="GetMapKeys_144"/>
            <cc:sub-route name="List" routes-to="GetListKeys_144"/>
            <cc:sub-route name="Set" routes-to="GetSetKeys_144"/>
            <cc:sub-route name="Finalize" routes-to="Call_Aggregate_Finalize_144"/>
            <cc:sub-route name="Undefined" routes-to="Call_CreateLogEntry_Warn_Undefined_144"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntry_Warn_Undefined_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Warn_Undefined_144" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Undefined Debug Log'"/>
            <cc:set name="inLogMessageDetail" value="'RouteType_144 was not able to correctly process the inTargetType input parameter.'"/>
            
            <cc:set name="inLogLevel" value="'warn'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Variable_144" store-message="none" routes-response-to="Variable_Name_144" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Variable ' # props['inTargetName']"/>
            <cc:set name="inLogMessageDetail" value="'Variable '# props['inTargetName'] #' saved to debug file with name of ' # props['outEntityName']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Property_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Debug_Property_144" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Property ' # props['inTargetName']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Message_144" store-message="none" routes-response-to="Message_Name_144" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message RootPart'"/>
            <cc:set name="inLogMessageDetail" value="'Message root part saved to debug file with name of ' # props['outEntityName']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Map_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Debug_Map_144" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="props[props.inTargetName] # '/' # props['localKey144']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_List_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Debug_List_144" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="props.inTargetName # ' Element ' # String.valueOf(props.localCounter144)"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            
            <cc:set name="inLogLevel" value="'debug'"/>
            
            
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_SoapRequest_103" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallSoap_Catch_103" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            
            
            
            
            
            
            
        <cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication'] # '.xml'"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_Debug_RaaSRequest_102" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallRaaS_Catch_102" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
        <cc:set name="inTargetName" value="'localRestUrl'"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:route id="RouteError_103">
            <cc:mvel-strategy>
                <cc:choose-route expression="parts[0].isXml() &amp;&amp; (parts[0].xstreamB('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault'))" route="SoapError"/>
                <cc:choose-route expression="true" route="HttpError"/>
            </cc:mvel-strategy>
            <cc:sub-route name="SoapError" routes-to="RouteError_Soap_Handler_103"/>
            <cc:sub-route name="HttpError" routes-to="RouteError_Http_Handler_103"/>
        </cc:route>
        <cc:async-mediation id="HttpError_Handler_104" routes-to="Call_HandleError_HttpError_Error_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'http';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_HttpError_Error_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application HTTP request error'"/>
            <cc:set name="inLogMessageDetail" value="'A transport protocol error occurred and the request was not evaluated or processed by the tenant.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication'] # '.xml'"/>
            
	    <cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:async-mediation id="SoapError_Handler_104" routes-to="Call_HandleError_SoapError_Error_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'soap';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_SoapError_Error_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application SOAP request error'"/>
            <cc:set name="inLogMessageDetail" value="'The API call resulted in the following SOAP fault: '# String.valueOf(parts[0].xpath('/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault/faultstring'))"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
	        <cc:set name="inExtraErrorCode" value="'10407'"/>
	        <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104'"/>
	        <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
	        <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
	        <cc:set name="inTargetType" value="'property'"/>
	        <cc:set name="inTargetName" value="'message'"/>
	        <cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication'] # '.xml'"/>
	        
	    <cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:route id="RouteError_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="parts[0].isXml() &amp;&amp; (parts[0].xpath('count(/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault)') > 0)" route="SoapError"/>
                <cc:choose-route expression="true" route="HttpError"/>
            </cc:mvel-strategy>
            <cc:sub-route name="SoapError" routes-to="SoapError_Handler_104"/>
            <cc:sub-route name="HttpError" routes-to="HttpError_Handler_104"/>
        </cc:route>
        <cc:async-mediation id="CallSoap_Catch_104" routes-to="RouteConcurrency_104" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="RouteError_104"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_SoapRequest_104" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallSoap_Catch_104" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
        <cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication'] # '.xml'"/></cc:local-out>
        <cc:local-out id="Call_Debug_SoapXslt_104" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
        </cc:local-out>
        <cc:async-mediation id="Transform_Handler_104" routes-to="Call_HandleError_Transform_Error_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Transform_Error_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Transformation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a SOAP service call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inBuildRequestPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inBuildRequestPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inBuildRequestPathToXsltFile']"/>
            
        <cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:async-mediation id="Transform_104" routes-to="Call_Debug_SoapXslt_104">
            <cc:steps>
                <cc:xslt-plus id="WriteSoap" input="message" url="@{props['inBuildRequestPathToXsltFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Transform_Handler_104"/>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareVariableInput_104" routes-to="Transform_104">
            <cc:steps>
                <cc:eval id="PrimeMessage">
                    <cc:expression>message.setMessage(vars[props.inBuildRequestDataLocationId].source, vars[props.inBuildRequestDataLocationId].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PreparePropertyInput_104" routes-to="Transform_104">
            <cc:steps>
                <cc:write id="PrimeMessage">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;Root/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Validation_Handler_104" routes-to="Call_HandleError_Validation_Error_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Validation_Error_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Validation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating parameters for a SOAP service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_104" routes-to="Call_BuildRequest_104" routes-response-to="Call_ParallelPostProcess_104">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outIsSoapError'] = '';&#xD;
props['outErrorMessage'] = '';</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_104">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="wd-external-request-id"/>
                        <cc:remove-header name="wd-external-application-id"/>
                        <cc:remove-header name="wd-external-originator-id"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsQualifierTyped','localIsValueDefined','localIsValueTyped','localIsQueryCacheEffective','localIsQueryCacheEntryDate']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>if (vars.isVariable('c2pAggregatedResult104')) {&#xD;
	vars['c2pAggregatedResult104'] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_104" routes-to="Call_CreateLogEntry_FlushInfo_104"/>
        <cc:local-out id="Call_Finally_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104"/>
        <cc:local-in id="CallSoapPaged" routes-to="InitializeAndFinalize_104" access="public" icon="icons/CallSoapPaged.png">
            <cc:parameter default="props['globalApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;." name="inWebServiceApplication" required="true" type="string"/>
            
            <cc:parameter documentation="The location that holds the data to be used in the transform provided on the inPathToXsltFile parameter.  This value is dependent on the value of inDataLocationId.  The parameter can have one of three values: message, variable, or property.  When the value is 'message', then the message part identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  Similarly, if this parameter value is 'variable', then the variable identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  if this parameter value is 'property', then the property identified by inDataLocationId is interpreted as a java.util.Map instance whose key/value pairs match pre-defined keys in the inPathToXsltFile xslt for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="props['inBuildRequestPathToXsltFile'] != empty" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (['message','variable','property'] contains props['inBuildRequestDataLocation'].trim().toLowerCase())) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocation'] == empty))"/>
            <cc:parameter documentation="The name that, when used with inBuildReqeustDataLocation, uniquely identifies which variable or property is to be used as the source data to which the transform provided on the inBuildReqeustPathToXsltFile parameter will be applied.  When inBuildReqeustDataLocation is 'message', then this parameter is ignored and the message root part is assumed." name="inBuildRequestDataLocationId" required="(props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message')" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message') &amp;&amp; (props['inBuildRequestDataLocationId'] != empty)) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocationId'] == empty))"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot; using the data identified by the inDataLocation and inDataLocationId input parameters.  This SSK Component also supports pre-built, on-message requests as well as facilities to construct the request dynamically.  If this parameter is omitted or set to null / an empty string, then inDataLocation and inDataLocationId can also be omitted (they are ignored), and then the dynamic request construction will be bypassed and the message root part will be used as the request." name="inBuildRequestPathToXsltFile" required="(props['inBuildRequestDataLocation'] != empty) || (props['inBuildRequestDataLocationId'] != empty)" type="string"/>
            <cc:parameter default="'env:Envelope/env:Body/*/wd:Response_Data/*'" documentation="Xpath to the elements in the response that are to be aggregated into the final data set." name="inXpathToResultsToAggregate" required="!props['inParallelSuppressAggregation']" type="string"/>
            <cc:parameter default="'&lt;SoapResults xmlns:wd=&quot;urn:com.workday/bsvc&quot;>'" documentation="In order to aggregate multiple XML elements at the same level into a final, returned document, a new root node is required.  This parameter defines that node including the namespaces required in the results, e.g. &lt;SoapResults xmlns:wd=&quot;urn:com.workday/bsvc&quot;>" name="inAggregatedResultsHeader" required="!props['inParallelSuppressAggregation']" type="string" validation="props['inAggregatedResultsHeader'] != empty"/>
            <cc:parameter default="'&lt;/SoapResults>'" documentation="In order to aggregate multiple XML elements at the same level into a final, returned document, a new root node is required.  This parameter defines the matching, terminating element as was defined on the inAggregatedResults parameter." name="inAggregatedResultsFooter" required="!props['inParallelSuppressAggregation']" type="string" validation="props['inAggregatedResultsFooter'] != empty"/>
            <cc:parameter default="true" documentation="A boolean value that directs the SSK Component to run the PagedGet component in either serial or parallel mode.  Running in parallel mode exposes more capability of this SSK Component as you can inject custom code to be executed after a response is received on each child thread.  This is a suitable mechanism to achieve parallel processing in lieu of the wcc://ParallelSubRoutine component." name="inIsParallelPagedGet" required="true" type="boolean"/>
            <cc:parameter documentation="Only applies when inIsParallelPagedGet is set to true.  When in parallel mode, this parameter defines a dynamic endpoint to which the PagedGet responses will be routed for custom processing, e.g. follow-up RAAS reports (remember that SA-102 is not thread-safe though) or outbound vendor HTTP/API calls.  The format of this value is the same as other local-out endpoint attributes, e.g. 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/local-in'.  If any data from the child threads is to be returned to the main SSK Component caller, then the data to be aggregated should be left on the message root part to be picked up by the aggregator thread and ultimately returned to the main parent thread.  The aggregator will expect the data mime-type to be text/xml, and it will assume the root node is to be skipped and is not a part of the data." name="inParallelPageProcessorEndpoint" required="false" type="string"/>
            <cc:parameter default="false" documentation="Only applies when inIsParallelPagedGet is set to true.  When in parallel mode, and this parameter is true, then the results of each page retrieval and/or whatever additional processing is performed on each page response, will not be aggregated.  Effectively therefore, there will be no results returned from this SSK Component and the required attribute of the inReturnResults parameter will become false.  The results/effect of the pages retrieved will then be the actions of the custom code provided at the inParallelPageProcessorEndpoint endpoint parameter.  If that code produces results that are to be aggregated in lieu of the retrieved PagedGet responses, then this parameter should be set to false, and the data to be aggregated should be left on the message root part to be picked up by the aggregator.  The aggregator will expect the data mime-type to be text/xml, and it will assume the root node is to be skipped and is not a part of the data." name="inParallelSuppressAggregation" required="props['inIsParallelPagedGet']" type="boolean"/>
            <cc:parameter default="context.containsProperty('outRequestIdHeader119') ? props['outRequestIdHeader119'] : null" documentation="Optional value to be set to the wd-external-request-id HTTP header." name="inHeaderRequestId" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('outApplicationIdHeader119') ? props['outApplicationIdHeader119'] : null" documentation="Optional value to be set to the wd-external-application-id HTTP header." name="inHeaderApplicationId" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('outOriginatorIdHeader119') ? props['outOriginatorIdHeader119'] : null" documentation="Optional value to be set to the wd-external-originator-id HTTP header." name="inHeaderOriginatorId" required="false" type="string"/>
            <cc:parameter default="'message'" documentation="How the SOAP results are returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found.  " name="inReturnResults" required="(!props['inIsParallelPagedGet']) ||&#xD;&#xA;&#x9;(props['inIsParallelPagedGet'] &amp;&amp; (!props['inParallelSuppressAggregation']))" type="string"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="'primary'" documentation="Controls whether the error message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:out-parameter documentation="A string to indicate that the request resulted in an error and identify the type.  If the error was at the API level, then outIsSoapError == 'http'.  If the error was at the tenant/application level, then outIsSoapError == 'soap'.  If there was an error unrelated to the API call, then outIsSoapError == 'logic'.  If there is no error, , then outIsSoapError == empty.  Further individual errors determined by Get_Event_Details or Get_Import_Processes are not handled here." name="outIsSoapError"/>
        <cc:out-parameter documentation="The error message of the exception for possible higher-level logging needs." name="outErrorMessage"/></cc:local-in>
        <cc:local-out id="CallSoapParallel_104" store-message="none" endpoint="vm://wcc/PagedGet">
        	<cc:set name="is.paged.get.request.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Filter/wd:Page'"/>
        	<cc:set name="is.paged.get.response.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Page'"/>
        	<cc:set name="is.paged.get.response.total.pages.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Pages'"/>
        	<cc:set name="is.paged.get.response.total.results.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Results'"/>
        	<cc:set name="is.paged.get.process.endpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessPageParallel_104'"/>
        	<cc:set name="is.paged.get.application" value="props['inWebServiceApplication']"/>
        	<cc:set name="is.paged.get.version" value="props['inApiVersion']"/>
        	<cc:set name="is.paged.get.page.zero" value="true"/>
        	<cc:set name="is.paged.get.store.requests" value="true"/>
        	<cc:set name="is.paged.get.parallel" value="true"/>
        	<cc:set name="is.paged.get.parallel.aggregation.endpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/AggregateParallel_104'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_LoadMap_Error_105" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">            
            <cc:set name="inLogMessage" value="'XSLT3 Map Load Error'"/>
            <cc:set name="inLogMessageDetail" value="'The XML data failed to be converted into a Java Map'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
        	<cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_105'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localXslt105'"/>
            <cc:set name="inEntityName" value="'mctx_vars_localXslt105.xsl'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="Teardown_105">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>// Remove properties that are purely internal to the subassembly
foreach (propname : ['localMapPropertyName','localMessages105']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>// And remove local variables that are no longer required&#xD;
foreach (varname : ['localXslt105']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_105" routes-to="Teardown_105"/>
        <cc:local-out id="Call_Finally_105" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_105"/>
        <cc:local-in id="IntegrationEventProgress" routes-to="ErrorTrap_108" access="public" icon="icons/IntegrationEventProgress0.png">
            <cc:parameter documentation="The overall completion percentage of the studio execution." name="inProgressPercentage" required="true" type="string"/>
            <cc:parameter documentation="The optional message to output on the Integration Event to indicate at what stage of the processing the Studio is." name="inProgressMessage" required="false" type="string"/>
        </cc:local-in>
        <cc:local-out id="PIM_108" store-message="none" execute-when="props['inProgressMessage'] != empty" routes-response-to="PIE_108" endpoint="vm://wcc/PutIntegrationMessage" clone-request="true"><cc:set name="is.message.severity" value="'INFO'"/><cc:set name="is.message.summary" value="props['inProgressMessage']"/><cc:set name="is.message.storage.enabled" value="false"/></cc:local-out>
        <cc:local-out id="PIE_108" store-message="none" routes-response-to="Call_CreateLogEntry_Info_108" endpoint="vm://wcc/PutIntegrationEvent" clone-request="true"><cc:set name="is.percent.complete" value="props['inProgressPercentage']"/></cc:local-out>
        <cc:local-out id="Call_IEP_10" store-message="none" routes-response-to="MainFlowControl_109" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/IntegrationEventProgress" clone-request="true" propagate-abort="false"><cc:set name="inProgressPercentage" value="'10'"/><cc:set name="inProgressMessage" value="'Initialization Complete.  Cloud Log, integration attributes, and launch parameters have been loaded.'"/></cc:local-out>
        <cc:local-out id="Call_IEP_90" store-message="none" routes-response-to="Call_StaticCodeAnalysis_109" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/IntegrationEventProgress" clone-request="true" propagate-abort="false">
            <cc:set name="inProgressPercentage" value="'90'"/>
            <cc:set name="inProgressMessage" value="'Integration functional behavior complete.  Finalizing logs...'"/>
        </cc:local-out>
        <cc:local-out id="Call_IEP_99" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/IntegrationEventProgress" clone-request="true" propagate-abort="false">
            <cc:set name="inProgressPercentage" value="'99'"/>
            <cc:set name="inProgressMessage" value="'Logs Finalized.  Awaiting any background process to complete Integration Event...'"/>
        </cc:local-out>
        <cc:aggregator id="AggregateToArchive_144" routes-to="StoreArchive_144" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:zip-file-collater output="variable" output-mimetype="application/zip" output-variable="localDebugResult144" message-entity-name="@{props['outEntityName']}"/>
        </cc:aggregator>
        <cc:local-in id="Aggregate_144" routes-to="DedupeName_144">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/><cc:parameter default="(props['inEntityName'] != empty) ? props['inEntityName'] : props['inTargetName']" name="inEntityName" required="props['inCollate']" type="string"/>
        <cc:out-parameter name="outEntityName"/></cc:local-in>
        <cc:async-mediation id="DedupeName_144" routes-to="AggregateToArchive_144">
            <cc:steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="14400" failure-message="DebugFile Aggregator (Aggregator_144) parameter failure.  The inCollate and inBatch arguments cannot both be false.">(!props['inCollate'] &amp;&amp; props['inBatch']) ||&#xD;
	(props['inCollate'] &amp;&amp; !props['inBatch']) ||&#xD;
	(props['inCollate'] &amp;&amp; props['inBatch'])</cc:expression>
                </cc:validate-exp>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outEntityName'] = (props['inEntityName'] != empty) ? props['int0025StringDeduplicator'].dedupeString(props['inEntityName']) : '';</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_Finalize_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Warn_Finalize_144" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_144"><cc:set name="inCollate" value="false"/><cc:set name="inBatch" value="true"/></cc:local-out>
        <cc:local-out id="Call_Aggregate_Message_144" store-message="none" routes-response-to="Call_CreateLogEntry_Debug_Message_144" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_144">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        <cc:set name="inEntityName" value="(props['inEntityName'] != empty) ? props['inEntityName'] : com.workday.custom.int0025.ssk144.DebugBean.getEntityNameForMessage(context, props.inEntitySuffix)"/></cc:local-out>
        <cc:async-mediation id="Message_Name_144">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outEntityName'] = props['outEntityName'];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Variable_PrepareValue_144" routes-to="Call_Aggregate_Variable_144">
            <cc:steps>
                <cc:eval id="CopyVarToMsg">
                    <cc:expression>message.setMessage(vars[props.inTargetName].source, vars[props.inTargetName].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_Variable_144" store-message="none" routes-response-to="Call_CreateLogEntry_Debug_Variable_144" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_144">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
            <cc:set name="inEntityName" value="(props['inEntityName'] != empty) ? props['inEntityName'] : com.workday.custom.int0025.ssk144.DebugBean.getEntityNameForVariable(context, props.inTargetName, props.inEntitySuffix)"/>
        </cc:local-out>
        <cc:async-mediation id="Variable_Name_144">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outEntityName'] = props['outEntityName'];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="SetHeaders_103" routes-to="Call_Debug_SoapRequest_103">
            <cc:steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:set-headers execute-when="context.containsProperty('inHeaderOriginatorId') &amp;&amp; props['inHeaderOriginatorId'] != empty" id="SetOriginatorHeader">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="wd-external-originator-id" value="@{props['inHeaderOriginatorId']}"/>
                    </cc:add-headers>
                </cc:set-headers>
            
                <cc:set-headers execute-when="context.containsProperty('inHeaderApplicationId') &amp;&amp; props['inHeaderApplicationId'] != empty" id="SetApplicationHeader">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="wd-external-application-id" value="@{props['inHeaderApplicationId']}"/>
                    </cc:add-headers>
                </cc:set-headers>
            
                <cc:set-headers execute-when="context.containsProperty('inHeaderRequestId') &amp;&amp; props['inHeaderRequestId'] != empty" id="SetRequestHeader">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="wd-external-request-id" value="@{props['inHeaderRequestId']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:wrap-soap id="WrapSoap"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_BuildRequest_103" store-message="none" execute-when="props['inBuildRequestPathToXsltFile'] != empty" routes-response-to="SetHeaders_103" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/BuildRequest_103" propagate-abort="true"><cc:set name="inApiVersion" value="props['inApiVersion']"/><cc:set name="inPathToXsltFile" value="props['inPathToXsltFile']"/><cc:set name="inMapPropertyName" value="props['inMapPropertyName']"/><cc:set name="inMapVariableName" value="props['inMapVariableName']"/><cc:set name="inDebugMode" value="props['inDebugMode']"/><cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/></cc:local-out>
        <cc:async-mediation id="StoreArchive_144" execute-steps-when="props['inBatch']">
            <cc:steps>
                <cc:store id="StoreArchive" output="variable" output-variable="localDebugArchive" input="variable" input-variable="localDebugResult144" createDocumentReference="true" expiresIn="@{props['int0025PrimaryLogExpires']}" title="@{props['int0025DebugArchiveFilename']}"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="BuildRequest_104" routes-to="RouteInputSource_104">
            <cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestPathToXsltFile']" documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;." name="inBuildRequestPathToXsltFile" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestDataLocation']" documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('inBuildRequestDataLocationId') ? props['inBuildRequestDataLocationId'] : null" documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example." name="inBuildRequestDataLocationId" required="false" type="string"/>
            <cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/><cc:parameter default="props['inIsAbortOnError']" name="inIsAbortOnError" required="true" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="Validation_Message_104" routes-to="Transform_104">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsValueDefined'] = parts[0] != empty;&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (parts[0].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10400" failure-message="Message part[0] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10401" failure-message="Message part[0] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp></cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Message_104"/>
        </cc:async-mediation>
        <cc:async-mediation id="ValidateAndSetHeaders_104" routes-to="Call_Debug_SoapRequest_104">
            <cc:steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:set-headers execute-when="context.containsProperty('inHeaderRequestId') &amp;&amp; props['inHeaderRequestId'] != empty" id="SetRequestHeader">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="wd-external-request-id" value="@{props['inHeaderRequestId']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:set-headers execute-when="context.containsProperty('inHeaderApplicationId') &amp;&amp; props['inHeaderApplicationId'] != empty" id="SetApplicationHeader">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="wd-external-application-id" value="@{props['inHeaderApplicationId']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:set-headers execute-when="context.containsProperty('inHeaderOriginatorId') &amp;&amp; props['inHeaderOriginatorId'] != empty" id="SetOriginatorHeader">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="wd-external-originator-id" value="@{props['inHeaderOriginatorId']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="EvaluateQueryCache">
                    <cc:expression>okToEval = parts[0].isXml();&#xD;
props['localIsQueryCacheEffective'] = okToEval ? parts[0].xstreamB('/env:Envelope/env:Body/*/wd:Response_Filter/wd:As_Of_Effective_Date') : false;&#xD;
props['localIsQueryCacheEntryDate'] = okToEval ? parts[0].xstreamB('/env:Envelope/env:Body/*/wd:Response_Filter/wd:As_Of_Entry_DateTime') : false;</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateQueryCache">
                    <cc:expression error-number="10408" failure-message="Both the Response_Filter/As_Of_Effective_Date and the Response_Filter/As_Of_Entry_DateTime must be set to avoid the tenanted PagedGet query cache from being cleared and recalculated on each page query.  This does not affect functionality, but it does undermine performance and could affect other integrations making PagedGet calls as well.">props['localIsQueryCacheEffective']</cc:expression>
                    <cc:expression error-number="10409" failure-message="Both the Response_Filter/As_Of_Effective_Date and the Response_Filter/As_Of_Entry_DateTime must be set to avoid the tenanted PagedGet query cache from being cleared and recalculated on each page query.  This does not affect functionality, but it does undermine performance and could affect other integrations making PagedGet calls as well.">props['localIsQueryCacheEntryDate']</cc:expression>
                </cc:validate-exp>
                <cc:wrap-soap id="WrapSoap"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_QueryCache_Error_104"/>
        </cc:async-mediation>
        <cc:local-out id="Call_BuildRequest_104" store-message="none" execute-when="props['inBuildRequestPathToXsltFile'] != empty" routes-response-to="ValidateAndSetHeaders_104" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/BuildRequest_104" propagate-abort="true">
            <cc:set name="inApiVersion" value="props['inApiVersion']"/>
            <cc:set name="inBuildRequestPathToXsltFile" value="props['inBuildRequestPathToXsltFile']"/>
            <cc:set name="inBuildRequestDataLocation" value="props['inBuildRequestDataLocation']"/>
            <cc:set name="inBuildRequestDataLocationId" value="context.containsProperty('inBuildRequestDataLocationId') ? props['inBuildRequestDataLocationId'] : null"/>
            <cc:set name="inDebugMode" value="props['inDebugMode']"/><cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Finalize_109" store-message="none" execute-when="props['int0025IsDebugMode'] || (context.containsProperty('outDebugLogged144') &amp;&amp; props['outDebugLogged144'])" routes-response-to="Call_IEP_99" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'finalize'"/>
            
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_DocumentAccessor_Error_110" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'GetEventDocuments Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while parsing the Get_Event_Documents response.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_110'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Info_108" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Integration '# String.valueOf(props['inProgressPercentage']) #'% Complete'"/>
            <cc:set name="inLogMessageDetail" value="props['inProgressMessage']"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Finalize_GEH" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'finalize'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_SoapResponse_103" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Results_103" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inWebServiceApplication'] # '.xml'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_Debug_Initialize_Finalize_Error_109" store-message="none" execute-when="props['int0025IsDebugMode'] || (context.containsProperty('outDebugLogged144') &amp;&amp; props['outDebugLogged144'])" routes-response-to="Initialize_Handler_109" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'finalize'"/>
        </cc:local-out>
        <cc:async-mediation id="Teardown_107">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsBatch', 'localSourceCounter', 'localSourcesList', 'localCacheMessage']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>// And remove local variables that are no longer required&#xD;
foreach (varname : ['localPreTransformData107', 'localMessageCache107']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_107" routes-to="Teardown_107"/>
        <cc:sync-mediation id="Validation_107" routes-to="Call_AggregateSources_107" routes-response-to="Call_Finally_107">
            <cc:request-steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10700" failure-message="Input parameter inDataSourceLocationList was empty.  A comma-separated string of values is expected that defines the variables and/or message root locations and sequence for aggregation to apply your xslt.">props['inDataSourceLocationList'] != empty</cc:expression>
                    <cc:expression error-number="10701" failure-message="Input parameter inDataSourceLocationList did not contain any comma separators implying there is only a single data source value provided.  SSK107 is not appropriate for use with only one data source; transform your data directly instead.">org.apache.commons.lang3.StringUtils.countMatches(props.inDataSourceLocationList, ',') > 0</cc:expression>
                    <cc:expression error-number="10702" failure-message="Input parameter inPathToXsltFile was empty.  A path relative to ws/WSAR-INF is required to apply a transformation to the aggregated inputs.">props['inPathToXsltFile'] != empty</cc:expression>
                </cc:validate-exp>
                <cc:eval id="InitValues">
                    <cc:expression>props['outIsLoggedMessages107'] = false;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_107" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_107"/>
        <cc:local-in id="StreamDataMerge" routes-to="Validation_107" access="public" icon="icons/StreamDataMerge.png">
            <cc:parameter documentation="A comma separated string list of variable names and/or 'message' identifying the locations from which to pull data for aggregation and in what order." name="inDataSourceLocationList" required="true" type="string"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will transform the data from inPayloadDataLocation, enriching and decorating it with data from inEnrichmentDataLocation, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;.  Though this is intended to be a streaming implementation, the responsibility for streaming lies with the developer of the XSLT; this SSK Component is not streaming unless the XSLT correctly implements it." name="inPathToXsltFile" required="true" type="string"/>
            <cc:parameter default="'message'" documentation="Where the results of the transformation are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found.  " name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the aggregated, pre-transform data from variable localPreTransformData107 is output on debug as well as context properties in error conditions." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        	<cc:parameter default="'primary'" documentation="Controls where the xsl:message elements produced in the transformation are logged, whether to the primary or secondary logs.  Component processing and validation messages will still go to the primary log, but data-level messages from the xslt will be directed per this configuration.  Note that the Extra Column configuration of the default secondary log is still coded and therefore assumed." name="inLogTargetForXsltMessages" required="true" type="string" validation="['primary', 'secondary', 'flexlog'] contains props['inLogTargetForXsltMessages'].trim().toLowerCase()"/>
        	<cc:parameter default="props['int0025FlexLog']" name="inFlexLogBean" required="props['inLogTargetForXsltMessages'].trim().toLowerCase() == 'flexlog'" validation="props['inFlexLogBean'] instanceof com.workday.custom.int0025.ssk147.FlexLogBean"/>
        	<cc:out-parameter documentation="Indicates whether or not any message of any logging level was put to the Cloud Log from XSLT. Will return 'true' if logged and false otherwise." name="outIsLoggedMessages107"/>
        </cc:local-in>
        <cc:local-in id="Aggregate_107" routes-to="AggregateData_107"><cc:parameter default="true" name="inCollate" required="true" type="boolean"/><cc:parameter default="false" name="inBatch" required="true" type="boolean"/></cc:local-in>
        <cc:aggregator id="AggregateData_107" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-mimetype="text/xml" output-variable="localPreTransformData107">
        <cc:header-text>&lt;Results></cc:header-text>
        <cc:footer-text>&lt;/Results></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:async-mediation id="Transform_107" routes-to="FlexLogXsltMessages_107">
            <cc:steps>
                <cc:xslt-plus id="ExecuteTransform" input="variable" input-variable="localPreTransformData107" messages-property="localMessages107" url="@{props['inPathToXsltFile']}"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['outIsLoggedMessages107'] = (props['localMessages107'] != empty);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Transform_Error_107"/>
        </cc:async-mediation>
        <cc:async-mediation id="FinalizeResults_107" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Transform_Error_107" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred executing the payload transformation using enrichment data.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_107'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        	<cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
        </cc:local-out>
        <cc:sync-mediation id="MainFlowControl_109" routes-to="Call_Main_109" routes-response-to="Call_IEP_90">
            <cc:request-steps>
                <cc:eval id="LoopDetectBugWorkaround1">
                    <cc:expression>//This Loop-Detected workaround is necessary; otherwise, any exceptions raised in the close-down process and handled by SA-109 will produce a loop detected error and obscure the actual error that occurred within Main.&#xD;
props[&quot;globalProcessFlagLoopControl&quot;] = com.workday.custom.int0025.ssk109.LocalOutHelper.SnapshotLoopDetection(context);</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="ResetAbort">
                    <cc:expression>context.setAbort(false);</cc:expression>
                </cc:eval>
                <cc:eval id="LoopDetectBugWorkaround2">
                    <cc:expression>com.workday.custom.int0025.ssk109.LocalOutHelper.ClearLoopDetectionFlags(context, props[&quot;globalProcessFlagLoopControl&quot;]);</cc:expression>
                </cc:eval>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:sync-mediation id="Variable_InitializeAndFinalize_Parent_144" routes-to="Variable_PrepareValue_144" execute-steps-when="!message.isNullContentRootPart()">
            <cc:request-steps>
                <cc:copy id="SaveMsg" output="variable" output-variable="debugTemporaryStorage" stream-xpath="true"/></cc:request-steps>
            <cc:response-steps>
            
                <cc:eval id="CleanUp">
                    <cc:expression>vars['debugTemporaryStorage'] = null;</cc:expression>
                </cc:eval>
                <cc:copy id="RestoreMsg" output="message" input="variable" input-variable="debugTemporaryStorage" stream-xpath="true"/>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-out id="Call_HandleError_NormalizeResponse_Error_102" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'SOAP Unwrap Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while unwrapping the RaaS results from the SOAP envelope.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inReportServiceAlias'] # '.xml'"/>
            
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="NormalizeResponse_102" execute-steps-when="!props['inIsForceUseSoap'] || (props['inIsForceUseSoap'] &amp;&amp; !props['inForceSoapIsSkipUnwrap'])">
            <cc:steps>
                <cc:xslt-plus id="UnwrapSoap" output-mimetype="text/xml" url="xslt/ssk102/SSK102_UnwrapSoapTransform.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_NormalizeResponse_Error_102"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_HttpOut_Error_102" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="HttpOut_Catch_102" routes-to="HttpOut_102" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_HttpOut_Error_102"/>
        </cc:async-mediation>
        <cc:http-out id="HttpOut_102" store-message="none" routes-response-to="NormalizeResponse_102" endpoint="@{intsys.reportService.getEndpoint(props.inReportServiceAlias)}" http-method="POST"/>
        <cc:local-out id="Call_Debug_SoapRequest_102" store-message="none" execute-when="props['inDebugMode']" routes-response-to="HttpOut_Catch_102" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Request__' # props['inReportServiceAlias'] # '.xml'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_ComposeRequest_Error_102" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_102'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-in id="ExecuteWithRest_102" routes-to="Call_Debug_RaaSRequest_102"><cc:parameter default="props['localRestUrl']" documentation="The full rest query including all querystring parameters" name="inRestUrl" required="true" type="string"/><cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/></cc:local-in>
        <cc:local-in id="ExecuteWithSoap_102" routes-to="Call_CreateLogEntry_ExecuteWithSoap_Info_102"><cc:parameter default="props['inReportServiceAlias']" documentation="The Report Service configuration from which to retrieve results." name="inReportServiceAlias" required="true" type="string"/><cc:parameter default="props['inPropertyNameReportPromptMap']" documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  If the report is not parameterized, then leave this input parameter empty.  If setting this input parameter though, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap." name="inPropertyNameReportPromptMap" required="!props['inIsForceUseSoap']" type="string"/><cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/></cc:local-in>
        <cc:route id="ChooseProtocol_102">
            <cc:mvel-strategy>
                <cc:choose-route expression="!props['inIsForceUseSoap'] &amp;&amp; props['localIsValidUrlLength']" route="REST"/>
                <cc:choose-route expression="true" route="SOAP"/>
            </cc:mvel-strategy>
            <cc:sub-route name="REST" routes-to="Call_ExecuteWithRest_102"/>
            <cc:sub-route name="SOAP" routes-to="Call_ExecuteWithSoap_102"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntry_ExecuteWithSoap_Info_102" store-message="none" execute-when="!props['inIsChildThreadContext'] &amp;&amp; !props['inIsForceUseSoap']" routes-response-to="Call_CreateThreadLogEntry_Info_102" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias using SOAP.'"/>
            <cc:set name="inLogMessageDetail" value="'The URL constructed including querystring parameters exceed the maximum URL length for RESTful RaaS calls of 16000 Bytes.  Switching to use SOAP as protocol.'"/>
            
            <cc:set name="inLogLevel" value="'info'"/>
            
            
            
            
        </cc:local-out>
        <cc:local-out id="Call_ExecuteWithRest_102" store-message="none" routes-response-to="Results_102" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ExecuteWithRest_102"><cc:set name="inRestUrl" value="props['localRestUrl']"/></cc:local-out>
        <cc:local-out id="Call_ExecuteWithSoap_102" store-message="none" routes-response-to="Results_102" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ExecuteWithSoap_102"><cc:set name="inPropertyNameReportPromptMap" value="props['inPropertyNameReportPromptMap'] == empty ? '' : props['inPropertyNameReportPromptMap']"/><cc:set name="inReportServiceAlias" value="props['inReportServiceAlias']"/><cc:set name="inDebugMode" value="props['inDebugMode']"/></cc:local-out>
        <cc:async-mediation id="ComposeRequest_102" routes-to="Call_Debug_SoapRequest_102">
            <cc:steps>
                <cc:custom execute-when="!props['inIsForceUseSoap']" id="WriteSoapRequest" ref="SSK102SoapAuthorBean"/>
                <cc:eval execute-when="props['inIsForceUseSoap'] &amp;&amp; props['inForceSoapSourceOfRequest'].trim().toLowerCase() != 'message'" id="MoveVarToMsg">
                    <cc:expression>message.setMessage(vars[props.inForceSoapSourceOfRequest].source, vars[props.inForceSoapSourceOfRequest].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ComposeRequest_Error_102"/>
        </cc:async-mediation>
        <cc:local-in id="AddReportPromptFromProperty" routes-to="Call_CreateLogEntry_Info_101" access="public" icon="icons/AddReportPromptFromProperty.png">
			<cc:parameter documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  When setting this input parameter, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap.  This data structure can be easily created through the com.workday.custom.int0025.ssk102.ParameterMapHelper class and initializeParameterMap method and then subsequently managed with the SSK101 SSK Components." name="inPropertyNameReportPromptMap" required="true" type="string"/>
        	<cc:parameter documentation="The XML name of the report prompt as specified on the Prompts tab of the Custom Report." name="inReportPromptName" required="true" type="string"/>
        	<cc:parameter documentation="The Id type of the value being provided on the prompt if the value is an instance reference.  For example, if the report prompt accepted workers and you were sending employees, this value might be 'Employee_ID'.  If the report prompt is a non-instance value, this parameter may be left empty / omitted." name="inReferenceIdType" required="false" type="string"/>
        	<cc:parameter documentation="The value to be assigned to the report prompt.  This may be a numeric value, string value or instance reference id." name="inValue" required="true"/>
        </cc:local-in>
        <cc:local-in id="AddReportPromptFromXml" routes-to="InitializeAndFinalize_Xml_101" icon="icons/AddReportPromptFromXml.png">
			<cc:parameter documentation="The name of the MediationContext property holding a key/value pair map of Report Prompt names and the associated values to use on the RaaS call.  When setting this input parameter, the property name given MUST hold an instance of a java.util.Map, e.g. HashMap.  This data structure can be easily created through the com.workday.custom.int0025.ssk102.ParameterMapHelper class and initializeParameterMap method and then subsequently managed with the SSK101 SSK Components." name="inPropertyNameReportPromptMap" required="true" type="string"/>
            <cc:parameter documentation="The XML name of the report prompt as specified on the Prompts tab of the Custom Report." name="inReportPromptName" required="true" type="string"/>
            <cc:parameter documentation="The Id type of the value being provided on the prompt if the value is an instance reference.  For example, if the report prompt accepted workers and you were sending employees, this value might be 'Employee_ID'.  If the report prompt is a non-instance value, this parameter may be left empty / omitted." name="inReferenceIdType" required="false" type="string"/>
            <cc:parameter documentation="The location where the XML data containing the parameter values can be found.  This may be either on the Message root or in a variable.  In the former case, specify the value of this parameter as the literal 'message'.  Otherwise, if the value is found in a variable, please set this parameter to the name of that variable." name="inParameterDataLocation" required="true" type="string" validation="props['inParameterDataLocation'] == 'message' || vars.isVariable(props.inParameterDataLocation)"/>
            <cc:parameter documentation="Namespace definitions in excess of the standard namespaces used in XSLT.  For example, if the input document were the output of a custom report, then you would use 'wd urn:com.workday.report/Your_Report_Name' based on the namespace definition in your document 'xmlns:wd=&quot;urn:com.workday.report/Your_Report_Name&quot;'.  If there were multiple namespaces needed to successfully evaluate the inQueryToEntry, inEntryFilter and/or inQueryToValue XPaths, then they would be space separated, e.g. 'wd urn:com.workday.report/Your_Report_Name env http://schemas.xmlsoap.org/soap/envelope/'" name="inXsltCustomNamespaces" required="false" type="string"/><cc:parameter documentation="The XPath query that will select the elements from the XML data that contain the values to be used as report parameters.  The values may be further refined to descendents of the results of this query using the inQueryToValue parameter.  The XPath must be streamable, e.g. selection predicates are not supported." name="inQueryToEntry" required="true" type="string"/>
            <cc:parameter documentation="XPath expression which can optionally be executed against the elements returned by inQueryToEntry in order to determine if those entries should be stored in the map.  This would come in the form of a selection predicate, e.g. '[@wd:type = &quot;WID&quot;]' or '[exists(wd:Attachment_Data/wd:Resume_Data)]'" name="inEntryFilter" required="false" type="string"/>
            <cc:parameter documentation="The XPath expression which returns the value to be stored in the map when executed against the element returned by the inQueryToEntry expression.  This XPath is relative to the results of the inQueryToEntry XPath.  Note also that, since this query is not subject to streaming constraints, it may contain selection predicates." name="inQueryToValue" required="false" type="string"/><cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the dynamic XSLT is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Xml_Error_101" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Parameter Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_Xml_101" routes-to="NormalizeMapValues_Xml_101" continue-after-error="rewind" handle-downstream-errors="false" routes-response-to="Call_Finally_Multiple_101">
            <cc:request-steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>if (!context.containsProperty(props.inPropertyNameReportPromptMap)) {&#xD;
	com.workday.custom.int0025.ssk102.ParameterMapHelper.initializeParameterMap(context, props.inPropertyNameReportPromptMap);&#xD;
}</cc:expression>
                    <cc:expression>props['localIsPromptsMap'] = context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map;</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10101" failure-message="The value contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap is not a map.">props['localIsPromptsMap']</cc:expression>
                </cc:validate-exp>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Xml_Error_101"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Property_Error_101" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Parameter Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a reports-as-a-service call.'"/>
            
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_Property_101" routes-to="NormalizeMapValues_Property_101" continue-after-error="rewind" handle-downstream-errors="false" routes-response-to="Call_Finally_Single_101">
            <cc:request-steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>if (!context.containsProperty(props.inPropertyNameReportPromptMap)) {&#xD;
	com.workday.custom.int0025.ssk102.ParameterMapHelper.initializeParameterMap(context, props.inPropertyNameReportPromptMap);&#xD;
}</cc:expression>
                    <cc:expression>props['localIsPromptsMap'] = context.getProperty(props['inPropertyNameReportPromptMap']) instanceof java.util.Map;</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10100" failure-message="The value contained in the property @{props['inPropertyNameReportPromptMap']} as specified on the input parameter inPropertyNameReportPromptMap is not a map.">props['localIsPromptsMap']</cc:expression>
                </cc:validate-exp>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Property_Error_101"/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_101">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsPromptsMap','localKey','localValue','localValueQuery','localNamespaces']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localXslt101']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_101" routes-to="Teardown_101"/>
        <cc:local-out id="Call_Finally_Single_101" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101"/>
        <cc:local-out id="Call_Finally_Multiple_101" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101"/>
        <cc:async-mediation id="NormalizeMapValues_Property_101" routes-to="Validate_Property_101">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localKey'] = (props['inReferenceIdType'] == empty) ? props['inReportPromptName'] : props['inReportPromptName'] # '!' # props['inReferenceIdType'];</cc:expression>
                    <cc:expression>if (props['inValue'] instanceof java.lang.Object) {&#xD;
	props['localValue'] = props['inValue'];&#xD;
} else {&#xD;
	props['localValue'] = String.valueOf(props['inValue']);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_NormalizeMapValues_Property_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_NormalizeMapValues_Property_Error_101" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Prompt Key/Value Pair Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while composing the key and value data for map storage on the ' # props['inReportPromptName'] # ' report prompt.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:local-out id="Call_HandleError_Validate_Property_Error_101" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Duplicate Map Key'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating a reports-as-a-service prompt key/value pair.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="Validate_Property_101" routes-to="UpdateMap_Property_101">
            <cc:steps>
                <cc:validate-exp id="ValidateKey">
                    <cc:expression error-number="10102" failure-message="The map already contains a key named @{props['localKey']}.">!(((java.util.Map)props[props.inPropertyNameReportPromptMap]).containsKey(props.localKey))</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Validate_Property_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_UpdateMap_Property_Error_101" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Map Update Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while writing the value data under the ' # props['localKey'] # ' report prompt in the ' # props['inPropertyNameReportPromptMap'] # ' map.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/></cc:local-out>
        <cc:async-mediation id="UpdateMap_Property_101">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>((java.util.Map)props[props.inPropertyNameReportPromptMap]).put(props['localKey'], props['localValue']);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_UpdateMap_Property_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_UpdateMap_Xml_Error_101" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Map Update Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while writing the value data under the ' # props['localKey'] # ' report prompt in the ' # props['inPropertyNameReportPromptMap'] # ' map.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="UpdateMap_Xml_101">
            <cc:steps>
                <cc:xslt-plus id="BuildList" url="mctx:vars/localXslt101"/>
                <cc:eval id="UpdateValues">
                    <cc:expression>((java.util.Map)props[props.inPropertyNameReportPromptMap]).put(props['localKey'], props['localValue']);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_UpdateMap_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Validate_Xml_Error_101" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Duplicate Map Key'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating a reports-as-a-service prompt key/value pair.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="Validate_Xml_101" routes-to="UpdateMap_Xml_101">
            <cc:steps>
                <cc:validate-exp id="Validations">
                    <cc:expression error-number="10104" failure-message="The map already contains a key named @{props['localKey']}.">!(((java.util.Map)props[props.inPropertyNameReportPromptMap]).containsKey(props.localKey))</cc:expression>
                    <cc:expression error-number="10105" failure-message="The referenced data for transformation into Report Prompt data indicated at @{props['inParameterDataLocation']} is not in XML format.">parts[0].isXml()</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Validate_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_NormalizeMapValues_Xml_Error_101" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'RaaS Prompt Key/Value Pair Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while composing the key and value data for map storage on the ' # props['inReportPromptName'] # ' report prompt.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="NormalizeMapValues_Xml_101" routes-to="Call_Debug_Xslt_101">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localKey'] = (props['inReferenceIdType'] == empty) ? props['inReportPromptName'] : props['inReportPromptName'] # '!' # props['inReferenceIdType'];</cc:expression>
                    <cc:expression>props['localValue'] = new java.util.ArrayList();</cc:expression>
                    <cc:expression>props['localValueQuery'] = (context.containsProperty('inQueryToValue') &amp;&amp; props['inQueryToValue'] != empty) ? ((props['inQueryToValue'].startsWith('/')) ? props['inQueryToValue'] : ('/' # props['inQueryToValue'])) : '';</cc:expression>
                    <cc:expression>props['localNamespaces'] = (context.containsProperty('inXsltCustomNamespaces') &amp;&amp; props['inXsltCustomNamespaces'] != empty) ? (com.workday.custom.int0025.SSKUtils.convertNamespaceArgumentToDefinitions(props['inXsltCustomNamespaces'])) : '';</cc:expression>
                </cc:eval>
                <cc:write id="WriteXslt" output="variable" output-variable="localXslt101">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;xsl:stylesheet version=&quot;3.0&quot; &#xD;
    xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&#xD;
    xmlns:tube=&quot;java:com.capeclear.mediation.impl.cc.MediationTube&quot;&#xD;
    xmlns:ctx=&quot;java:com.capeclear.mediation.MediationContext&quot;&#xD;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&#xD;
    xmlns:jlist=&quot;java:java.util.List&quot;&#xD;
    xmlns:jt=&quot;http://saxon.sf.net/java-type&quot;&#xD;
    @{props['localNamespaces']}&#xD;
    xmlns:this=&quot;urn:this&quot;>&#xD;
    &#xD;
    &lt;xsl:param name=&quot;inQueryToValue&quot; as=&quot;xs:string&quot;/>&#xD;
    &#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;shallow-skip&quot;/>&#xD;
    &lt;xsl:mode streamable=&quot;no&quot; on-no-match=&quot;shallow-skip&quot; name=&quot;in-memory&quot;/>&#xD;
    &#xD;
    &lt;!-- Obtain the current MediationContext in use in the assembly -->&#xD;
    &lt;xsl:variable name=&quot;ctx&quot; select=&quot;tube:getCurrentMediationContext()&quot;/>&#xD;
    &#xD;
    &lt;!-- Retrieve the Java List stored in the context property localValue -->&#xD;
    &lt;xsl:variable name=&quot;list&quot; select=&quot;ctx:getProperty($ctx, 'localValue')&quot; as=&quot;jt:java.util.List&quot;/>&#xD;
    &#xD;
    &lt;xsl:template match=&quot;/&quot;>&#xD;
        &lt;ListHelper>&#xD;
            &lt;!-- Now process the input file.  The EntryFilter variable can then be optionally used to only select those entries matching that value.  The filter can only navigate the descendant axis since only the node and and descendants returned by the QueryToEntry expression are brought into memory -->&#xD;
            &lt;xsl:apply-templates select=&quot;@{props['inQueryToEntry']}/copy-of()@if{props['inEntryFilter'] != empty}@{props['inEntryFilter']}@end{}@if{props['localValueQuery'] != empty}@{props['localValueQuery']}@end{}&quot; mode=&quot;in-memory&quot;/>    		&#xD;
        &lt;/ListHelper>&#xD;
    &lt;/xsl:template>&#xD;
    &#xD;
    &lt;!-- Process each entry -->&#xD;
    &lt;xsl:template match=&quot;*&quot; mode=&quot;in-memory&quot;>&#xD;
        &lt;xsl:variable name=&quot;value&quot;	 select=&quot;./text()&quot; as=&quot;xs:string&quot;/>&#xD;
        &lt;templateMatched/>&#xD;
		&lt;xsl:value-of select=&quot;jlist:add($list, $value)&quot;/>&#xD;
    &lt;/xsl:template>&#xD;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_NormalizeMapValues_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_PrepareInputData_Xml_Error_101" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Map Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'A problem was encountered while moving the value data from the ' # props['inParameterDataLocation'] # ' variable to the message root for extraction.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_101'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        <cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="PrepareInputData_Xml_101" routes-to="Validate_Xml_101" execute-steps-when="props['inParameterDataLocation'] != 'message'">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>message.setMessage(vars[props.inParameterDataLocation].source, vars[props.inParameterDataLocation].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_PrepareInputData_Xml_Error_101"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Xslt_101" store-message="none" execute-when="props['inDebugMode']" routes-response-to="PrepareInputData_Xml_101" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug" clone-request="true">
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localXslt101'"/>
            
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-in id="HandleError" routes-to="Threading_141" access="public" icon="icons/HandleError.png">
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogMessage parameter." name="inLogMessage" required="true" type="string"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogMessageDetail parameter." name="inLogMessageDetail" required="false" type="string"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogReferenceId parameter." name="inLogReferenceId" required="false" type="string"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inLogLevel parameter.  Validation is performed by CreateLogEntry." name="inLogLevel" required="true" type="string"/>
            <cc:parameter default="context.errorComponentId" documentation="Value passed to CreateLogEntry's inExtraLocalIn parameter." name="inExtraLocalIn" required="false"/>
            <cc:parameter documentation="Value passed to CreateLogEntry's inExtraRecordNumber parameter." name="inExtraRecordNumber" required="false"/>
            <cc:parameter default="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')" documentation="Value passed to CreateLogEntry's inExtraSupportData parameter." name="inExtraSupportData" required="false"/><cc:parameter default="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''" documentation="Value passed to CreateLogEntry's inExtraErrorCode parameter." name="inExtraErrorCode" required="false"/><cc:parameter documentation="The SSK Component endpoint to call for clean-up of properties and/or variables." name="inFinallyEndpoint" required="false" type="string"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler.  In order for this parameter to have an effect of aborting the SSK Component from which it was called, the Propagate Abort setting on the Advanced tab of the calling Local-Out component must be set to true." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="When set to true, clears the residual error details by setting a null exception." name="inIsResetError" required="false" type="boolean"/><cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the dynamic XSLT is output on debug." name="inIncludeDebugOutput" required="true" type="boolean"/>
        	<cc:parameter default="'message'" documentation="The type of information to be output to the log." name="inTargetType" required="props['inIncludeDebugOutput']" type="string" validation="props['int0025DebugTargetTypeValidation'].contains(props['inTargetType'])"/>
        	<cc:parameter documentation="The reference name to use for single-named output types selected on inTargetType.  Required when inTargetType is one of: property, variable, list, map, or set." name="inTargetName" required="props['inIncludeDebugOutput'] &amp;&amp; (['property','properties','variable','map','list','set'] contains props['inTargetType'].trim().toLowerCase())" type="string" validation="props['int0025DebugTargetNameValidation'].contains(props['inTargetType']) &amp;&amp;&#xD;&#xA;(props['inTargetName'] != empty || props['inEntityName'] != empty)"/>
        	<cc:parameter documentation="A specific filename to use when exporting the message or variable content to a file zipped in a consolidated archive.  This is optional and only used when inTargetType is &quot;message&quot; or &quot;variable&quot;." name="inEntityName" required="props['inIncludeDebugOutput'] &amp;&amp; (['message','variable'] contains props['inTargetType'].trim().toLowerCase()) &amp;&amp; (props['inEntitySuffix'] == empty)" type="string"/><cc:parameter default="''" documentation="This parameter is related to when the inTargetType is is either 'message' or 'variable'.  When the inEntityName is not specified in those cases, the component will auto-generate an entity name for the file being aggregated to the debug zip archive.  The targetName is used as the prefix of the filename for variables, and 'rootpart' is used for message.  If inEntitySuffix is provided instead of inEntityName, an underscore is appended to the target name, followed by this value.  The DebugBean will make the value safe for filename use.  If inEntityName is given, then this parameter will be ignored.  If this parameter is set with an inTargetType other than message or variable, it is also ignored." name="inEntitySuffix" required="false" type="string"/><cc:parameter default="'primary'" documentation="Controls whether the error message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/><cc:parameter default="context.containsProperty('outCloudLogFieldOverrideMap145') ? props['outCloudLogFieldOverrideMap145'] : null" documentation="This parameter provides the opportunity to specify a Java HashMap from a context property to replace the error values being reported internally by the component.  The map is keyed by the attribute name of the SSK141 HandleError input parameter, and the value is a string to be used in place of the SSK103 default.  If the map is not provided, or if a map is given but does not contain a key for the logged parameter, then the SSK103 default behavior applies.  If only a single value is desired to be changed from the out-of-the-box behavior, then a map with a single entry could be provided.  In some cases, the logged value is not available to be override, e.g. inLocalIn or inLogLevel when there are hard errors." name="inErrorLogOverrideMap" required="false"/>
        	<cc:out-parameter documentation="If a file has been written to the debug archive, the name of that file will be returned for further reference in logging messages." name="outEntityName"/>
        </cc:local-in>
        <cc:local-out id="Call_Finally_141" store-message="none" execute-when="props['inFinallyEndpoint'] != empty" routes-response-to="Handler_141" endpoint="@{props['inFinallyEndpoint']}"/>
        <cc:async-mediation id="Handler_141" routes-to="AbortOnError_141">
            <cc:steps>
                <cc:eval id="HandleError">
                    <cc:expression>if (props.containsKey('inIsResetError') &amp;&amp; props.inIsResetError) { context.setException(null); }</cc:expression>
                    <cc:expression>context.setErrorHandled(true);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="AbortOnError_141" execute-steps-when="props['inIsAbortOnError']">
            <cc:steps>
                <cc:eval id="SetAbort">
                    <cc:expression>context.setAbort(true);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_141" store-message="none" execute-when="props['inLogTarget'] == 'primary'" routes-response-to="Call_CreateSecondaryLogEntry_141" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;props['inLogMessage']"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;((props['inLogMessageDetail'] != empty) ? props['inLogMessageDetail'] : '')"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;((props['inLogReferenceId'] != empty) ? props['inLogReferenceId'] : '')"/>
            <cc:set name="inLogLevel" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogLevel')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogLevel')) :&#xD;&#xA;&#x9;&#x9;props['inLogLevel']"/>
            <cc:set name="inExtraLocalIn" value="if (context.containsProperty('inExtraLocalIn')) {&#xD;&#xA;&#x9;props['inExtraLocalIn']&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;((props['inExtraRecordNumber'] != empty) ? props['inExtraRecordNumber'] : '')"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((props['inExtraSupportData'] != empty) ? props['inExtraSupportData'] : '')"/>
            <cc:set name="inExtraErrorCode" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraErrorCode')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraErrorCode')) : &#xD;&#xA;&#x9;&#x9;props['inExtraErrorCode']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Parent_141" store-message="none" execute-when="props['inIncludeDebugOutput'] &amp;&amp; props['inTargetType'] != empty" routes-response-to="Call_Finally_141" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="props['inTargetType']"/>
            <cc:set name="inTargetName" value="props['inTargetName']"/>
            <cc:set name="inEntityName" value="props['inEntityName']"/>
        <cc:set name="inEntitySuffix" value="props['inEntitySuffix']"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-out id="Call_Debug_Result_102" store-message="none" execute-when="props['inDebugMode']" routes-response-to="ThreadedResultOutput_102" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="props['inReturnResults'] != 'message' ? 'variable' : 'message'"/>
            <cc:set name="inTargetName" value="props['inReturnResults'] == 'message' ? null : props.inReturnResults"/><cc:set name="inEntityName" value="'RAAS-Results__' # props['inReportServiceAlias'] # '.xml'"/>
            
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-in id="InitializeFrameworkThenRunMain" routes-to="Initialize_109" access="public" icon="icons/InitializeFrameworkThenRunMain.png"><cc:parameter default="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Main'" documentation="This parameter value will define the main flow and logic processing of the integration.  This is where all of the requirements-specific work will happen in between the StarterKit framework initialization and finalization." name="inMainEndpoint" required="true" type="string"/></cc:local-in>
        <cc:local-out id="Call_InitializeFrameworkThenRunMain" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/InitializeFrameworkThenRunMain" unset-properties="false"><cc:set name="inMainEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Main'"/></cc:local-out>
        <cc:async-mediation id="RetrieveMessage_112" routes-to="Call_WriteLog_112">
            <cc:steps>
                <cc:eval id="UpdateValues"><cc:expression>props['localLogMessage'] = props['localLogIterator'].next()</cc:expression></cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="LoopOverMessages_112">
            <cc:loop-strategy condition="props['localLogIterator'].hasNext()" repeat-limit="200000"/>
            <cc:sub-route name="Loop" routes-to="RetrieveMessage_112"/>
        </cc:route>
        <cc:sync-mediation id="InitializeAndFinalize_112" routes-to="LoopOverMessages_112" handle-downstream-errors="true">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props.localLogIterator = new com.workday.custom.int0025.ssk112.ObjectIterator(props.inLogIterator)</cc:expression>
                    <cc:expression>props.localHasMessages = props.localLogIterator.hasNext()</cc:expression>
                    <cc:expression>if (props['inIsChildThreadContext']) {&#xD;
	props.dynamicEndpoint112 = 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread';&#xD;
} else {&#xD;
	whichLog = ((props['inLogTarget'] == 'secondary') ? 'WriteSecondaryLog_' : 'WritePrimaryLog_');&#xD;
	whichFormat = ((props['inLogTarget'] == 'secondary') ? props['int0025SecondaryLogFileFormat'] : props['int0025PrimaryLogFileFormat']);&#xD;
	props.dynamicEndpoint112 = 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/' # whichLog # whichFormat # '_142';&#xD;
}</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp"><cc:expression>foreach (name: {'localHasMessages', 'localLogMessage', 'localLogIterator', 'dynamicEndpoint112'}) { context.removeProperty(name) } </cc:expression></cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-in id="CloudLogMessages_112" routes-to="InitializeAndFinalize_112" access="private">
            <cc:parameter documentation="An instance of Iterator&lt;CloudLogAdapter> which will be used to iterate over all the messages to be placed in the cloud-log" name="inLogIterator" required="true"/><cc:parameter documentation="Passed-through value of which log to write to" name="inLogTarget" required="true" type="string" validation="props['inLogTarget']"/>
        </cc:local-in>
        <cc:local-in id="CloudLogETVXTTMessages" routes-to="InitializeAndFinalize_ETVXTT_112" access="public" icon="icons/CloudLogETVXTTMessages.png">
            <cc:parameter default="props['etv.messages']" documentation="An instance of ETVInfoCollection" name="inMessages" required="false" validation="props['inMessages'] instanceof com.workday.mediation.impl.mediators.etv.ETVInfoCollection"/>
            <cc:parameter default="true" documentation="Specifies whether the collection should be cleared after it is output to the log.  The default is to be cleared." name="inIsClearMessages" required="false" type="boolean"/>
            <cc:parameter default="'INFO'" documentation="Minimum severity level to be reported.  Defaults to INFO" name="inMinLogLevel" required="false" validation="['INFO','WARNING','ERROR','CRITICAL'] contains props['inMinLogLevel'].trim().toUpperCase()"/>
         	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/><cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-in id="CloudLogXSLTMessages" routes-to="InitializeAndFinalize_XSLT_112" access="public" icon="icons/CloudLogXSLTMessages.png">
            <cc:parameter default="props['xsltstep.messages']" documentation="An instance of java.util.List which contains the messages" name="inMessages" required="true" validation="props['inMessages'] instanceof java.util.List"/>
            <cc:parameter default="true" documentation="Specifies whether the inXSLTMessages list should be cleared after it is output to the log.  The default is to be cleared." name="inIsClearMessages" required="false" type="boolean"/>
            <cc:parameter default="'debug'" documentation="The minimum level for which messages will be output.  If no value is given a default of debug will be used" name="inMinLogLevel" required="false" validation="['debug','info','warn','error','critical'] contains props['inMinLogLevel'].trim().toLowerCase()"/>
        	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/><cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_CloudLogMessages_XSLT_112" store-message="none" execute-when="props['inMessages'] != empty" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CloudLogMessages_112"><cc:set name="inLogIterator" value="com.workday.custom.int0025.ssk112.CloudLogXsltStepIterator.getIterator(props['inMessages'], props['inMinLogLevel'])"/><cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_XSLT_112" routes-to="Call_CloudLogMessages_XSLT_112">
            <cc:request-steps>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>if (props['inIsClearMessages']) { props['inMessages'].clear() }</cc:expression><cc:expression>foreach (name: {'inMessages', 'inIsClearMessages', 'inMinLogLevel'}) { context.removeProperty(name) } </cc:expression></cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-out id="Call_CloudLogMessages_ETVXTT_112" store-message="none" execute-when="(props['inMessages'] != null) &amp;&amp; (props['inMessages'].currentSize() > 0)" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CloudLogMessages_112">
            <cc:set name="inLogIterator" value="com.workday.custom.int0025.ssk112.CloudLogETVIterator.getIterator(props['inMessages'], props['inMinLogLevel'].trim().toUpperCase())"/>
        <cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_ETVXTT_112" routes-to="Call_CloudLogMessages_ETVXTT_112">
            <cc:request-steps/>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>if (props['inIsClearMessages']) { props['inMessages'].clear() }</cc:expression><cc:expression>foreach (name: {'inMessages', 'inIsClearMessages', 'inMinLogLevel'}) { context.removeProperty(name) } </cc:expression></cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:aggregator id="AggregateFile_115" routes-to="SendResultsBackToMainThread_115" collate-when="props['aggregator.destination.force.collate']" force-batch-on-last-message="false" force-batch-when="props['aggregator.destination.force.batch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="message" output-mimetype="text/xml" xpath="*/*">
        <cc:header-text>&lt;DISRoot xmlns:tdf=&quot;urn:com.workday/tdf&quot;></cc:header-text>
        <cc:footer-text>&lt;/DISRoot></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-in id="Aggregate_115" routes-to="PrepareFile_115">
            
            
        </cc:local-in>
        <cc:async-mediation id="Teardown_115">
            <cc:steps>
                <cc:eval id="CleanUp">
						<cc:expression>foreach (propname : ['localXPathPredicateDefault', 'localXPathPredicateService', 'localLabels', 'localFileCount']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localXslt115','c2pAggregatedResult']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
					</cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_115" routes-to="Teardown_115"/>
        <cc:local-out id="Call_Debug_Message_115" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Results_115" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'DIS_Aggregated_File.xml'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_Results_Error_115" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the DIS results from the message rootpart to variable globalDISResults.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_115'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'DISResults.xml'"/>
        </cc:local-out>
        <cc:async-mediation id="Results_115" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_115"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Finally_115" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_115">
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:local-out id="GetEventDocuments_115" store-message="none" routes-response-to="Call_Debug_DocumentResults_115" endpoint="vm://wcc/GetEventDocuments">
            <cc:set name="ie.event.wid" value="props['inEventWID']"/>
        </cc:local-out>
        <cc:local-in id="GetDISResults" routes-to="InitializeAndFinalize_115" access="public" icon="icons/GetDISResults.png">
            <cc:parameter default="props['int0025EventWID']" documentation="WID of the Integration Event from which the documents will be queried.  This is typically the current event, and as such, is defaulted to the current event WID.  However, changing this WID enables retrieving documents from another related event for processing." name="inEventWID" required="true" type="string"/>
            <cc:parameter documentation="Specifies a Document Tag for filtering the input files on the Integration Event in addition to the default &quot;Data - Partial&quot; used by DIS.  &quot;Data - Partial&quot; is assumed and should not be provided.  If no additional tag is specified, then only the &quot;Data - Partial&quot; tag will be used.  This should be a single value that matches to the DIS service name and is useful when you have multiple DIS services configured on your integration and you need to aggregate those values separately." name="inRetrievalDocTag" required="false" type="string"/>
            <cc:parameter default="'message'" documentation="Where the results of the response are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the DIS results are output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/><cc:parameter default="false" documentation="When this parameter is set to true, the component will use a single-threaded, serialized approach to aggregate the partial data files in ascending order to preserve sorting done in the DIS itself." name="inIsUseOrderedAggregation" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_ParallelSubroutine_115" store-message="none" routes-response-to="CopyResultFromThreads_115" endpoint="vm://wcc/ParallelSubroutine"><cc:set name="parallel.processing.aggregation.endpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_115'"/><cc:set name="parallel.processing.worker.endpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessFile_115'"/><cc:set name="parallel.processing.worker.count" value="4"/><cc:set name="parallel.processing.worker.timeout" value="60"/><cc:set name="parallel.processing.timeout" value="1200"/><cc:set name="parallel.processing.splitter" value="spring.getBean('SSK115FileSplitter')"/></cc:local-out>
        <cc:local-in id="ProcessFile_115" routes-to="ReadFile_115"/>
        <cc:async-mediation id="ReadFile_115">
            <cc:steps>
                <cc:retrieve id="Retrieve" output="variable" output-mimetype="text/xml" output-variable="c2pDocument" collection="@{parts[0].xstream('/Documents/Document/Collection')}" entry="@{parts[0].xstream('/Documents/Document/EntryID')}"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareFile_115" routes-to="AggregateFile_115" execute-steps-when="props['aggregator.destination.force.collate']">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" input="variable" input-variable="c2pDocument"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="SendResultsBackToMainThread_115">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="c2pAggregatedResult"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteFileCount_Parallel_115">
            <cc:mvel-strategy>
                <cc:choose-route expression="!parts[0].xstreamB('/*/*')" route="NoFiles"/>
                <cc:choose-route expression="true" route="Files"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Files" routes-to="Call_ParallelSubroutine_115"/>
            <cc:sub-route name="NoFiles" routes-to="Call_CreateLogEntry_NoFiles_Info_115"/>
        </cc:route>
        <cc:async-mediation id="PrepareFileResults_Parallel_115" routes-to="RouteFileCount_Parallel_115">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localXPathPredicateDefault'] = 'wd:Document_Tag_Reference/wd:ID[@wd:type=\'Workday_Document_Tag_Name\'] = \'Data - Partial\'';&#xD;
props['localXPathPredicateService'] = (props['inRetrievalDocTag'] == empty ? '' : 'wd:Document_Tag_Reference/wd:ID[@wd:type=\'Integration_Service_Name\'] = \''# props['inRetrievalDocTag'] #'\'');</cc:expression>
                </cc:eval>
                <cc:write id="LoadXslt" output="variable" output-variable="localXslt115">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;xsl:stylesheet &#xD;
	xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&#xD;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&#xD;
    xmlns:wd=&quot;urn:com.workday/bsvc&quot;&#xD;
    exclude-result-prefixes=&quot;#all&quot;&#xD;
    version=&quot;3.0&quot;>&#xD;
    &#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;shallow-skip&quot;/>&#xD;
    &lt;xsl:mode name=&quot;in-memory&quot; streamable=&quot;no&quot;/>&#xD;
    &#xD;
    &lt;xsl:output indent=&quot;no&quot;/>&#xD;
    &#xD;
    &lt;xsl:template match=&quot;/&quot;>&#xD;
        &lt;Documents>&#xD;
            &lt;xsl:apply-templates/>&#xD;
        &lt;/Documents>&#xD;
    &lt;/xsl:template>&#xD;
&#xD;
    &lt;xsl:template match=&quot;wd:Repository_Document&quot;>&#xD;
        &lt;xsl:apply-templates select=&quot;wd:Repository_Document_Data/copy-of()[@{props['localXPathPredicateDefault']}@if{props['localXPathPredicateService'] != empty} and @{props['localXPathPredicateService']}@end{}]&quot; mode=&quot;in-memory&quot;/>&#xD;
    &lt;/xsl:template>&#xD;
&#xD;
    &lt;xsl:template match=&quot;wd:Repository_Document_Data&quot; mode=&quot;in-memory&quot;>&#xD;
	    &lt;Document>&#xD;
	    	&lt;Collection>&lt;xsl:value-of select=&quot;substring-before(@wd:Document_ID, '/')&quot;/>&lt;/Collection>&#xD;
	    	&lt;EntryID>&lt;xsl:value-of select=&quot;substring-after(@wd:Document_ID, '/')&quot;/>&lt;/EntryID>&#xD;
	    &lt;/Document>&#xD;
    &lt;/xsl:template>&#xD;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
                <cc:xslt-plus id="GetDISFileList" url="mctx:vars/localXslt115"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_PrepareFileResults_Error_115"/>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_NoFiles_Info_115" store-message="none" routes-response-to="HandleNoResults_115" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"><cc:set name="inLogMessage" value="'No Files Found!'"/><cc:set name="inLogMessageDetail" value="'No files were found produced by the Data Initialization Service using Document Tag' #&#xD;&#xA;(props['inRetrievalDocTag'] == empty ? ' \'Data - Partial\'.' : 's \'Data - Partial\' and \'' # props['inRetrievalDocTag'] # '\'.')"/><cc:set name="inLogLevel" value="'info'"/></cc:local-out>
        <cc:local-out id="Call_Finally_NoFiles_115" store-message="none" routes-response-to="Call_Debug_Message_115" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_115">
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:route id="RouteSource_106">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inDataSource'] != 'message'" route="Variable"/>
                <cc:choose-route expression="true" route="Message"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Message" routes-to="StoreMessage_106"/>
            <cc:sub-route name="Variable" routes-to="StoreVariable_106"/>
        </cc:route>
        <cc:local-out id="Call_HandleError_StoreMessage_Error_106" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Storage Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while storing data to the Integration Event.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_106" routes-to="RouteSource_106">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>if (props['inSecuredInstanceRefs'] != empty) {&#xD;
	if (props['inSecuredInstanceRefs'] instanceof java.lang.String) {&#xD;
		props['localSecuredRefs'] = props['inSecuredInstanceRefs'];&#xD;
	} else {&#xD;
		props['localSecuredRefs'] = util.listToCommaDelimString(props['inSecuredInstanceRefs']);&#xD;
	}&#xD;
}</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localSecuredRefs']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localStoreResult106']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:async-mediation id="StoreMessage_106" routes-to="PIM_Tag_106">
            <cc:steps>
                <cc:zip execute-when="props['inIsCompressOutput']" id="Zip" format="@{props['inCompressionFormat']}"/>
                <cc:store id="StoreContent" output="variable" output-mimetype="text/xml" output-variable="localStoreResult106" input="message" createDocumentReference="false" expiresIn="@{props['inDocumentRetentionPeriod']}" title="@{props['inOutputFilename']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_StoreMessage_Error_106"/>
        </cc:async-mediation>
        <cc:async-mediation id="StoreVariable_106" routes-to="StoreMessage_106">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>message.setMessage(vars[props.inDataSource].source, vars[props.inDataSource].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_StoreVariable_Error_106"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_SoapResponse_Message_104" store-message="none" execute-when="props['inDebugMode']" routes-response-to="MoveResultsToVariable_104" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inWebServiceApplication'] # '.xml'"/>
        </cc:local-out>
        <cc:aggregator id="AggregateMessage_104" routes-to="Call_Debug_SoapResponse_Message_104" force-batch-on-last-message="false" force-batch-when="props['is.paged.get.last.page']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="message" output-mimetype="text/xml" xpath="@{props['inXpathToResultsToAggregate']}">
        <cc:header-text>@{props['inAggregatedResultsHeader']}</cc:header-text>
        <cc:footer-text>@{props['inAggregatedResultsFooter']}</cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-out id="Call_HandleError_ProcessResult_Warn_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while extracing the results from the SOAP response using xpath['# props['inXpathToResultsToAggregate'] #'].  Processing of the remaining results will continue...'"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inLogTarget" value="props.inLogTarget"/></cc:local-out>
        <cc:async-mediation id="ProcessResult_Handler_104" routes-to="Call_HandleError_ProcessResult_Warn_104">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="ProcessResult_104" routes-to="AggregateMessage_104" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="ProcessResult_Handler_104"/>
        </cc:async-mediation>
        <cc:local-in id="ProcessPage_104" routes-to="ProcessResult_104">
            <cc:parameter default="props['inWebServiceApplication']" documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;." name="inWebServiceApplication" required="true" type="string"/><cc:parameter default="props['inAggregatedResultsHeader']" name="inAggregatedResultsHeader" required="true" type="string" validation="props['inAggregatedResultsHeader'] != empty"/>
            <cc:parameter default="props['inAggregatedResultsFooter']" name="inAggregatedResultsFooter" required="true" type="string" validation="props['inAggregatedResultsFooter'] != empty"/>
            <cc:parameter default="props['inXpathToResultsToAggregate']" documentation="Xpath to the elements in the response that are to be aggregated into the globalSoapResults variable." name="inXpathToResultsToAggregate" required="true" type="string"/>
            <cc:parameter default="props['inReturnResults']" documentation="How the SOAP results are returned to the caller, either on the message if the value is 'message', or in the 'globalSoapResults' variable if the value is 'variable', which is the default." name="inReturnResults" required="true" type="string"/>
            
            <cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="Foundation_152" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetConstantValues">
                    <cc:expression>props['globalApiVersion'] = props['inApiVersion'];</cc:expression>
                    <cc:expression>if (props['inServiceNameGeneral'] != empty) {&#xD;
	props['int0025ServiceNameGeneral'] = props['inServiceNameGeneral'];&#xD;
}</cc:expression>
                    <cc:expression>if (props['inServiceNameLogPrimary'] != empty) {&#xD;
	props['int0025ServiceNameLogPrimary'] = props['inServiceNameLogPrimary'];&#xD;
}</cc:expression>
                    <cc:expression>if (props['inServiceNameLogSecondary'] != empty) {&#xD;
	props['int0025ServiceNameLogSecondary'] = props['inServiceNameLogSecondary'];&#xD;
}</cc:expression>
                    <cc:expression>if (props['inServiceNameFunctional'] != empty) {&#xD;
	props['int0025ServiceNameFunctional'] = props['inServiceNameFunctional'];&#xD;
}</cc:expression>
                    <cc:expression>if (props['inServiceNameMessageQueue'] != empty) {&#xD;
	props['int0025ServiceNameMessageQueue'] = props['inServiceNameMessageQueue'];&#xD;
}</cc:expression>
                    <cc:expression>if (props['inServiceNameExtend'] != empty) {&#xD;
	props['int0025ServiceNameExtend'] = props['inServiceNameExtend'];&#xD;
}</cc:expression>
                    <cc:expression>if (props['inServiceNameRest'] != empty) {&#xD;
	props['int0025ServiceNameRest'] = props['inServiceNameRest'];&#xD;
}</cc:expression>
                    <cc:expression>if (props['inServiceNameListener'] != empty) {&#xD;
	props['int0025ServiceNameListener'] = props['inServiceNameListener'];&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="ForceLaunchParameters">
                    <cc:expression>props['int0025IsDebugMode'] = false</cc:expression>
                    <cc:expression>props['int0025IsValidationMode'] = false</cc:expression>
                    <cc:expression>vars['int0025DebugWID'] = null</cc:expression>
                    <cc:expression>vars['int0025EventWID'] = lp.integrationEventWID</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="PIM_ConfigurationError_152"/>
        </cc:async-mediation>
        <cc:local-out id="Call_StaticCodeAnalysis_109" store-message="none" execute-when="props['int0025IsDebugMode']" routes-response-to="Call_StoreAllFlexLogs" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StaticCodeAnalysis" clone-request="true" propagate-abort="false">
            <cc:set name="inStaticCodeAnalysisExemptionList" value="props['int0025StaticCodeAnalysisExemptionList']"/>
            <cc:set name="inDebugMode" value="props['int0025IsDebugMode']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
        </cc:local-out>
        <cc:async-mediation id="SetupThreadedLogging_143">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>if (!context.containsProperty('localParallelLog143') || (props['inIsResetIfStarted'] &amp;&amp; context.containsProperty('localParallelLog143'))) {&#xD;
	props['localParallelLog143'] = new java.util.concurrent.ConcurrentLinkedQueue();&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_StartThreadLog_Info_143" store-message="none" execute-when="!context.containsProperty('localParallelLog143') || (props['inIsResetIfStarted'] &amp;&amp; context.containsProperty('localParallelLog143'))" routes-response-to="SetupThreadedLogging_143" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Initialized Logging for Parallel Execution'"/>
            <cc:set name="inLogMessageDetail" value="'A data structure capable of capturing messages for cloud logging is being setup to support logging while executing parallel threads.  This is typically used when running parallel processing endpoints with either PagedGet where the is.paged.get.parallel parameter is true, or with use of the ParallelSubroutine component.'"/>
            <cc:set name="inLogLevel" value="'info'"/>
        </cc:local-out>
        <cc:local-in id="StartThreadLog" routes-to="Call_CreateLogEntry_StartThreadLog_Info_143" access="public" icon="icons/StartThreadLog.png"><cc:parameter default="false" documentation="When using this component, and the Thread Log is already started, this parameter will determine if it will be reset, thereby deleting messages already on that log prior to being Cloud Logged, or if no action will be taken.  If the Thread Log has not already been started, then this parameter has no action." name="inIsResetIfStarted" required="false" type="boolean"/></cc:local-in>
        <cc:async-mediation id="LogMessage_143">
            <cc:steps>
                <cc:eval id="CreateMessage">
                    <cc:expression>m = new com.workday.custom.int0025.ssk142.CloudLogMessage();</cc:expression>
                    <cc:expression>if (context.containsProperty('inLogMessage')) {m.setSummary(props.inLogMessage)};&#xD;
if (context.containsProperty('inLogMessageDetail')) {m.setDetail(props.inLogMessageDetail)};&#xD;
if (context.containsProperty('inLogReferenceId')) {m.setReferenceId(props.inLogReferenceId)};&#xD;
if (context.containsProperty('inLogLevel')) {m.setLevel(props.inLogLevel)};&#xD;
if (context.containsProperty('inExtraLocalIn')) {m.setLocalIn(props.inExtraLocalIn)};&#xD;
if (context.containsProperty('inExtraRecordNumber')) {m.setRecordNumber(props.inExtraRecordNumber)};&#xD;
if (context.containsProperty('inExtraSupportData')) {m.setSupportData(props.inExtraSupportData)};&#xD;
if (context.containsProperty('inExtraErrorCode')) {m.setErrorCode(props.inExtraErrorCode)};</cc:expression>
                    <cc:expression>props['localParallelLog143'].add(m);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="CreateLogEntryOnThread" routes-to="LogMessage_143" access="public" icon="icons/CreateLogEntryOnThread.png">
            <cc:parameter documentation="Value that will be written to the Message attribute of the Cloud Logger." name="inLogMessage" required="true" type="string"/>
            <cc:parameter documentation="Value that will be written to the Message Details attribute of the Cloud Logger." name="inLogMessageDetail" required="false" type="string"/>
            <cc:parameter documentation="Value that will be written to the Reference Id attribute of the Cloud Logger.  This is most commonly used to record the WID of the record to which this message pertains and can save the MVEL code of concatenating it into the Message Detail." name="inLogReferenceId" required="false" type="string"/>
            <cc:parameter documentation="Value that determines the Level attribute of the Cloud Logger.  Must be one of: debug, info, warn, error, critical." name="inLogLevel" required="true" type="string" validation="['debug','info','warn','error','critical'] contains props['inLogLevel'].trim().toLowerCase()"/>
            <cc:parameter documentation="Value written to the LocalIn Extra Column on the log.  This field is a convention of SSK and used to record the name of a Mediation related to the message, e.g. the errorComponentId causing an error to be raised." name="inExtraLocalIn" required="false"/>
            <cc:parameter documentation="Value written to the RecordNumber Extra Column on the log.  This field is a convention of SSK and used to record the position/count of a data record in a set to which this message pertains." name="inExtraRecordNumber" required="false"/>
            <cc:parameter documentation="Value written to the SupportData Extra Column on the log.  This field is a convention of SSK and used to provide open-ended advice for support.  This may constitute additional data values, or it may mean remediation advice for a particular error." name="inExtraSupportData" required="false"/>
            <cc:parameter documentation="Value written to the ErrorCode Extra Column on the log.  This field is a convention of SSK and used to provide the value of the error code when the message is logging error information.  This code may be given by the ESB, or it may be a custom code defined by the developer.  Note that this field is a String whereas Studio/ESB codes are integers, so type conversion is required." name="inExtraErrorCode" required="false"/>
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntry_LogThreadMessages_143" store-message="none" execute-when="props['inLogTarget'] == 'primary'" routes-response-to="Call_CreateSecondaryLogEntry_LogThreadMessages_143" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="props['localParallelLogMessage143'].getSummary()"/>
            <cc:set name="inLogMessageDetail" value="props['localParallelLogMessage143'].getDetail()"/>
            <cc:set name="inLogReferenceId" value="props['localParallelLogMessage143'].getReferenceId()"/>
            <cc:set name="inLogLevel" value="props['localParallelLogMessage143'].getLevel()"/>
            <cc:set name="inExtraLocalIn" value="props['localParallelLogMessage143'].getLocalIn()"/>
            <cc:set name="inExtraRecordNumber" value="props['localParallelLogMessage143'].getRecordNumber()"/>
            <cc:set name="inExtraSupportData" value="props['localParallelLogMessage143'].getSupportData()"/>
            <cc:set name="inExtraErrorCode" value="props['localParallelLogMessage143'].getErrorCode()"/>
        </cc:local-out>
        <cc:async-mediation id="RetrieveNextMessage_143" routes-to="Call_CreateLogEntry_LogThreadMessages_143">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['localParallelLogMessage143'] = props['localParallelLogIterator143'].next();</cc:expression>
                    <cc:expression>props['outIsErrorsOnThreads'] = props['outIsErrorsOnThreads'] || (['error','critical'] contains props['localParallelLogMessage143'].getLevel().trim().toLowerCase());</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteEachMessage_143">
            <cc:loop-strategy condition="props['localParallelLogIterator143'].hasNext()" repeat-limit="200000"/>
            <cc:sub-route name="ProcessMessage" routes-to="RetrieveNextMessage_143"/>
        </cc:route>
        <cc:sync-mediation id="InitializeAndFinalize_143" routes-to="RouteEachMessage_143">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props.localParallelLogIterator143 = new com.workday.custom.int0025.ssk142.ObjectIterator(props.localParallelLog143);</cc:expression>
                    <cc:expression>props['outIsErrorsOnThreads'] = false;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localParallelLogIterator143','localParallelLogMessage143']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>props['localParallelLog143'].clear();</cc:expression>
                </cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-in id="WriteThreadLogsToCloudLog" routes-to="InitializeAndFinalize_143" access="public" icon="icons/WriteThreadLogsToCloudLog.png">
	        <cc:parameter default="'primary'" documentation="Controls whether the error message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:out-parameter documentation="A boolean value that indicates whether or not an error or critical severity was encountered on one or more of the parallel threads.  This allows the employer of these logging SSK Components to be aware of an error/critical entry, but not abort immediately upon first encounter and lose the rest of the logging information." name="outIsErrorsOnThreads"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_121">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localAssemblyXml','localSubAssemblyDetailMap','localSubAssemblyList','localCoreList','localExemptionList']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="ReduceDebug">
                    <cc:expression>if (context.containsProperty('int0025DebugPropertyList')) {&#xD;
	props['int0025DebugPropertyList'].remove('localAssemblyXml');&#xD;
	props['int0025DebugPropertyList'].remove('localSubAssemblyList');&#xD;
	props['int0025DebugPropertyList'].remove('localExemptionList');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_121" routes-to="Teardown_121"/>
        <cc:aggregator id="AggregateData_121" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="message" output-mimetype="text/xml">
        <cc:header-text>&lt;Root></cc:header-text>
        <cc:footer-text>&lt;/Root></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-in id="Aggregate_121" routes-to="AggregateData_121">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntry_MissingCode_Warn_121" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'SSK Core Component Missing'"/>
            <cc:set name="inLogMessageDetail" value="'Static code analysis was unable to locate the SSK Core Component ' # &#xD;&#xA;(parts[0].xpath('.')) # '.  This may have been deleted from the integration.  See Support Data for more details.'"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraSupportData" value="'SSK Core Components should not be removed, even if identified as potential dead code in static analysis.  All other SSK components assume the Core Components as dependencies, and you may inadvertently break another SSK component in-use by removing a Core Component.  ' #&#xD;&#xA;'If a Core Component is being flagged in static analysis, then add the local-in id to the int0025StaticCodeAnalysisExemptionList property in StaticAnalysisExemptions@Initialize_109, which can be found in the InitializeFrameworkThenRunMain SSK Component.  ' #&#xD;&#xA;'Otherwise, restore the deleted code for ' # (parts[0].xpath('.')) # ' in the ' # (props['localSubAssemblyDetailMap'].get(parts[0].xpath('.'))) # ' swimlane from a clean copy of SSK.'"/>
            <cc:set name="inExtraErrorCode" value="'12101'"/>
        </cc:local-out>
        <cc:splitter id="Splitter_MissingCode_121" no-split-message-error="false">
            <cc:sub-route name="ReportMissingCode" routes-to="Call_CreateLogEntry_MissingCode_Warn_121"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:local-out id="Call_Debug_Message_MissingCode_121" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Splitter_MissingCode_121" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'StaticAnalysis_MissingCode'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_MissingCode_Error_121" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Missing Code Analysis Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while performing the missing code portion of the static analysis.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_121'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['int0025IsDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'StaticAnalysis_Assembly'"/>
        </cc:local-out>
        <cc:async-mediation id="MissingCode_121" routes-to="Call_Debug_Message_MissingCode_121">
            <cc:steps>
                <cc:xslt-plus id="FindDeletedCommonComponents" output-mimetype="text/xml" url="xslt/ssk121/SSK121_MissingCodeDetection.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_MissingCode_Error_121"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_Metadata_121" store-message="none" routes-response-to="MissingCode_121" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_121">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareMissingCode_Metadata_121" routes-to="Call_Aggregate_Metadata_121">
            <cc:steps>
                <cc:write id="WriteMessage" output-mimetype="text/xml">
                    <cc:message>
                        <cc:text>&lt;SubAssemblies>&#xD;
	@foreach{props.localCoreList}&#xD;
	&lt;SubAssembly>@{item}&lt;/SubAssembly>&#xD;
	@end{}&#xD;
&lt;/SubAssemblies></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_Assembly_121" store-message="none" routes-response-to="PrepareMissingCode_Metadata_121" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_121">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareMissingCode_Assembly_121" routes-to="Call_Aggregate_Assembly_121">
            <cc:steps>
                <cc:write id="WriteAssemblyToMsg" output-mimetype="text/xml">
                    <cc:message>
                        <cc:static-file input-file="@{props['localAssemblyXml']}"/>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_DeadCode_Warn_121" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Potential Dead Code Detected'"/>
            <cc:set name="inLogMessageDetail" value="'Static code analysis suggests that the SSK Component defined by local-in with id=' # &#xD;&#xA;(parts[0].xstream('/*')) # ' may not be used in the integration.  See Support Data for more details.'"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraSupportData" value="'Static code analysis does not read dynamic endpoints, so if you have referenced this SSK Component dynamically, this may be a false-positive and you should make no code changes.  ' #&#xD;&#xA;'In this case, add your local-in id to the int0025StaticCodeAnalysisExemptionList property in StaticAnalysisExemptions@Initialize_109, which can be found in the InitializeFrameworkThenRunMain SSK Component.  ' #&#xD;&#xA;'Otherwise, consider removing the SSK Component by deleting the ' # (props['localSubAssemblyDetailMap'].get(parts[0].xpath('.'))) # ' swimlane, or removing the entire parent swimlane if no other SSK Components in that group are being used.'"/>
            <cc:set name="inExtraErrorCode" value="'12100'"/>
        </cc:local-out>
        <cc:splitter id="Splitter_DeadCode_121" no-split-message-error="false">
            <cc:sub-route name="ReportDeadCode" routes-to="Call_CreateLogEntry_DeadCode_Warn_121"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:local-out id="Call_Debug_Message_DeadCode_121" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Splitter_DeadCode_121" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'StaticAnalysis_DeadCode'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_DeadCode_Error_121" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Dead Code Analysis Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while performing the dead code portion of the static analysis.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_121'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['int0025IsDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'StaticAnalysis_Assembly'"/>
        </cc:local-out>
        <cc:async-mediation id="DeadCode_121" routes-to="Call_Debug_Message_DeadCode_121">
            <cc:steps>
                <cc:write id="WriteAssemblyToMsg" output-mimetype="text/xml">
                    <cc:message>
                        <cc:static-file input-file="@{props['localAssemblyXml']}"/>
                    </cc:message>
                </cc:write>
                <cc:xslt-plus id="FindUnusedLocalIns" output-mimetype="text/xml" url="xslt/ssk121/SSK121_DeadCodeDetection.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DeadCode_Error_121"/>
        </cc:async-mediation>
        <cc:route id="Route_121">
            <cc:all-strategy/>
            <cc:sub-route name="DeadCode" routes-to="DeadCode_121"/>
            <cc:sub-route name="MissingCode" routes-to="PrepareMissingCode_Assembly_121"/>
            <cc:sub-route name="MissingVersion" routes-to="Call_CreateLogEntry_MissingVersion_Warn_121"/>
        </cc:route>
        <cc:local-out id="Call_Debug_PropertyList_121" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Route_121" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'properties'"/>
            <cc:set name="inTargetName" value="'int0025DebugPropertyList'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_121" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Static Code Analysis Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing the control values to perform static analysis.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_121'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['int0025IsDebugMode']"/>
            <cc:set name="inTargetType" value="'properties'"/>
            <cc:set name="inTargetName" value="'int0025DebugPropertyList'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_121" routes-to="Call_Debug_PropertyList_121" handle-downstream-errors="true" routes-response-to="Call_Finally_121">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localAssemblyXml'] = 'assembly.xml';</cc:expression>
                    <cc:expression>props['localSubAssemblyDetailMap'] = new java.util.HashMap();</cc:expression>
                    <cc:expression>props['localSubAssemblyDetailMap'].put('Main','INT0025 CheckWorkRights VisaCheck Inbound > Integration Code > Begin Integration Work');&#xD;
props['localSubAssemblyDetailMap'].put('InitializeFrameworkThenRunMain','Studio StarterKit Library > CORE COMPONENTS > 109 - Initialization');&#xD;
props['localSubAssemblyDetailMap'].put('ConfigurationSetup','Studio StarterKit Library > CORE COMPONENTS > 152 - Foundation');&#xD;
props['localSubAssemblyDetailMap'].put('HandleError','Studio StarterKit Library > CORE COMPONENTS > 141 - Error Handling');&#xD;
props['localSubAssemblyDetailMap'].put('CreateLogEntry','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('CreateSecondaryLogEntry','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('StoreLogPrimary','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('StoreLogSecondary','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('LogStatsPrimary','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('LogStatsSecondary','Studio StarterKit Library > CORE COMPONENTS > 142 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('StartThreadLog','Studio StarterKit Library > CORE COMPONENTS > 143 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('CreateLogEntryOnThread','Studio StarterKit Library > CORE COMPONENTS > 143 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('WriteThreadLogsToCloudLog','Studio StarterKit Library > CORE COMPONENTS > 143 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('Debug','Studio StarterKit Library > CORE COMPONENTS > 144 - General Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('CloudLogXSLTMessages','Studio StarterKit Library > CORE COMPONENTS > 112 - XSLT / ETV / XTT Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('CloudLogETVXTTMessages','Studio StarterKit Library > CORE COMPONENTS > 112 - XSLT / ETV / XTT Cloud Logging');&#xD;
props['localSubAssemblyDetailMap'].put('IntegrationEventProgress','Studio StarterKit Library > CORE COMPONENTS > 108 - Integration Event Progress Update');&#xD;
props['localSubAssemblyDetailMap'].put('StaticCodeAnalysis','Studio StarterKit Library > CORE COMPONENTS > 121 - Static Code Analysis');&#xD;
props['localSubAssemblyDetailMap'].put('OverrideCloudLogFields','Studio StarterKit Library > CORE COMPONENTS > 145 - Cloud Log Field Overrides');&#xD;
props['localSubAssemblyDetailMap'].put('CreateFlexLogEntry','Studio StarterKit Library > CORE COMPONENTS > 147 - Flex Log');&#xD;
props['localSubAssemblyDetailMap'].put('StoreAllFlexLogs','Studio StarterKit Library > CORE COMPONENTS > 147 - Flex Log');</cc:expression>
                    <cc:expression>props['localSubAssemblyDetailMap'].put('AddReportPromptFromProperty','Studio StarterKit Library > REPORTS AS A SERVICE > 101 - Build Reports-as-a-Service Report Prompts');&#xD;
props['localSubAssemblyDetailMap'].put('AddReportPromptFromXml','Studio StarterKit Library > REPORTS AS A SERVICE > 101 - Build Reports-as-a-Service Report Prompts');&#xD;
props['localSubAssemblyDetailMap'].put('CallRaaS','Studio StarterKit Library > REPORTS AS A SERVICE > 102 - Reports-as-a-Service Execution');&#xD;
props['localSubAssemblyDetailMap'].put('InitializeObjectDiff','Studio StarterKit Library > REPORTS AS A SERVICE > 146 - Reports-as-a-Service Comparison - ObjectDiff');&#xD;
props['localSubAssemblyDetailMap'].put('HistoricDataMapBuilder','Studio StarterKit Library > REPORTS AS A SERVICE > 146 - Reports-as-a-Service Comparison - ObjectDiff');&#xD;
props['localSubAssemblyDetailMap'].put('ObjectDiff','Studio StarterKit Library > REPORTS AS A SERVICE > 146 - Reports-as-a-Service Comparison - ObjectDiff');&#xD;
props['localSubAssemblyDetailMap'].put('InitializeReportDiff','Studio StarterKit Library > REPORTS AS A SERVICE > 149 - Reports-as-a-Service Comparison - ReportDiff');&#xD;
props['localSubAssemblyDetailMap'].put('BuildUniqueIdList','Studio StarterKit Library > REPORTS AS A SERVICE > 149 - Reports-as-a-Service Comparison - ReportDiff');&#xD;
props['localSubAssemblyDetailMap'].put('ReportDiff','Studio StarterKit Library > REPORTS AS A SERVICE > 149 - Reports-as-a-Service Comparison - ReportDiff');</cc:expression>
                    <cc:expression>props['localSubAssemblyDetailMap'].put('CallSoap','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 103 - Workday Web Service (SOAP) Execution');&#xD;
props['localSubAssemblyDetailMap'].put('CallSoapPaged','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 104 - Workday Web Service (SOAP) Paged Execution');&#xD;
props['localSubAssemblyDetailMap'].put('CallSoapImport','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 113 - Workday Web Service (SOAP) Import APIs (Process)');&#xD;
props['localSubAssemblyDetailMap'].put('FinalizeCallSoapImport','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 113 - Workday Web Service (SOAP) Import APIs (Process)');&#xD;
props['localSubAssemblyDetailMap'].put('ReportResultsOfCallSoapImport','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 118 - Workday Web Service (SOAP) Import APIs (Post-Process)');&#xD;
props['localSubAssemblyDetailMap'].put('CreateQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 122 - Workday Message Queue - Create Queue');&#xD;
props['localSubAssemblyDetailMap'].put('GetQueues','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 123 - Workday Message Queue - Get Queues');&#xD;
props['localSubAssemblyDetailMap'].put('PollQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 124 - Workday Message Queue - Poll Queue');&#xD;
props['localSubAssemblyDetailMap'].put('ReadMessageFromQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 125 - Workday Message Queue - Read Message');&#xD;
props['localSubAssemblyDetailMap'].put('AddMessageToQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 126 - Workday Message Queue - Write Message');&#xD;
props['localSubAssemblyDetailMap'].put('DeleteMessageFromQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 127 - Workday Message Queue - Delete Message');&#xD;
props['localSubAssemblyDetailMap'].put('PurgeQueue','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 128 - Workday Message Queue - Purge Queue');&#xD;
props['localSubAssemblyDetailMap'].put('GetAccessToken','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 160 - Get Access Token');&#xD;
props['localSubAssemblyDetailMap'].put('CallRestApi','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 161 - Call REST API');&#xD;
props['localSubAssemblyDetailMap'].put('WQL','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 162 - WQL');&#xD;
props['localSubAssemblyDetailMap'].put('StoreExtendAttachment','Studio StarterKit Library > WORKDAY WEB SERVICES (WWS) API > 163 - Write Attachment Object');</cc:expression>
                    <cc:expression>props['localSubAssemblyDetailMap'].put('GenerateOutput','Studio StarterKit Library > FILE UTILITIES > 106 - Output Generation');&#xD;
props['localSubAssemblyDetailMap'].put('GetDocumentList','Studio StarterKit Library > FILE UTILITIES > 110 - Get Document List');&#xD;
props['localSubAssemblyDetailMap'].put('LoadFile','Studio StarterKit Library > FILE UTILITIES > 111 - Load File');&#xD;
props['localSubAssemblyDetailMap'].put('GetDISResults','Studio StarterKit Library > FILE UTILITIES > 115 - Data Initialization Service');&#xD;
props['localSubAssemblyDetailMap'].put('ExtendLogAggregationChain','Studio StarterKit Library > FILE UTILITIES > 134 - Extend Log Aggregation Chain');&#xD;
props['localSubAssemblyDetailMap'].put('GetLogAggregationChain','Studio StarterKit Library > FILE UTILITIES > 136 - Get Log Aggregation Chain');&#xD;
props['localSubAssemblyDetailMap'].put('HandleByteOrderMark','Studio StarterKit Library > FILE UTILITIES > 148 - Byte Order Mark Utilities');</cc:expression>
                    <cc:expression>props['localSubAssemblyDetailMap'].put('PopulateJavaMap','Studio StarterKit Library > XSLT 3.0 > 105 - Populate Java Map');&#xD;
props['localSubAssemblyDetailMap'].put('StreamDataMerge','Studio StarterKit Library > XSLT 3.0 > 107 - Streaming Data Merge');&#xD;
props['localSubAssemblyDetailMap'].put('BlockSplitter','Studio StarterKit Library > XSLT 3.0 > 116 - XML Block Splitting');&#xD;
props['localSubAssemblyDetailMap'].put('Text2ParallelSplitter','Studio StarterKit Library > XSLT 3.0 > 117 - Text to Parallel Splitter');&#xD;
props['localSubAssemblyDetailMap'].put('GetXmlTransformer','Studio StarterKit Library > XSLT 3.0 > 117 - Text to Parallel Splitter');&#xD;
props['localSubAssemblyDetailMap'].put('GetJsonTransformer','Studio StarterKit Library > XSLT 3.0 > 117 - Text to Parallel Splitter');&#xD;
props['localSubAssemblyDetailMap'].put('GetContextPropertyTransformer','Studio StarterKit Library > XSLT 3.0 > 117 - Text to Parallel Splitter');&#xD;
props['localSubAssemblyDetailMap'].put('XsltPlus','Studio StarterKit Library > XSLT 3.0 > 129 - XSLT Transform');&#xD;
props['localSubAssemblyDetailMap'].put('MultiItemFlowControl','Studio StarterKit Library > XSLT 3.0 > 130 - Multi-Item Flow Control');&#xD;
props['localSubAssemblyDetailMap'].put('GetRootOpenTag','Studio StarterKit Library > XSLT 3.0 > 135 - Get Root Open Tag');&#xD;
props['localSubAssemblyDetailMap'].put('GetRootCloseTag','Studio StarterKit Library > XSLT 3.0 > 138 - Get Root Close Tag');&#xD;
props['localSubAssemblyDetailMap'].put('StreamSourceMerge','Studio StarterKit Library > XSLT 3.0 > 153 - Streaming Source Merge');&#xD;
props['localSubAssemblyDetailMap'].put('PrepareMergeSource','Studio StarterKit Library > XSLT 3.0 > 153 - Streaming Source Merge');</cc:expression>
                    <cc:expression>props['localSubAssemblyList'] = new java.util.ArrayList();&#xD;
props['localCoreList'] = new java.util.ArrayList();</cc:expression>
                    <cc:expression>foreach (key : props['localSubAssemblyDetailMap'].keySet()) {&#xD;
	if (org.apache.commons.lang3.StringUtils.contains(props['localSubAssemblyDetailMap'].get(key), 'CORE COMPONENTS')) {&#xD;
		props['localCoreList'].add(key);&#xD;
	}&#xD;
	props['localSubAssemblyList'].add(key);&#xD;
}&#xD;
props['localSubAssemblyList'] = util.listToCommaDelimString(props['localSubAssemblyList']);</cc:expression>
                    <cc:expression>if (props['inStaticCodeAnalysisExemptionList'] == empty) {&#xD;
	props['inStaticCodeAnalysisExemptionList'] = new java.util.ArrayList();&#xD;
}</cc:expression>
                    <cc:expression>if (props['inStaticCodeAnalysisExemptionList'] == empty) {&#xD;
	props['localExemptionList'] = '';&#xD;
} else {&#xD;
	props['localExemptionList'] = util.listToCommaDelimString(props['inStaticCodeAnalysisExemptionList']);&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('int0025DebugPropertyList')) {&#xD;
	props['int0025DebugPropertyList'].add('localAssemblyXml');&#xD;
	props['int0025DebugPropertyList'].add('localSubAssemblyList');&#xD;
	props['int0025DebugPropertyList'].add('localExemptionList');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_121"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_121" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_121"/>
        <cc:local-in id="StaticCodeAnalysis" routes-to="InitializeAndFinalize_121" icon="icons/DeadCodeDetection.png">
            <cc:parameter default="props['int0025StaticCodeAnalysisExemptionList']" documentation="A list of SSK Components to exclude from warning generation in the static code analysis because of use by dynamic endpoints not read by the validation code." name="inStaticCodeAnalysisExemptionList" required="false"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_118">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsImportRequests','localIsDoNotMatch','localProcessWID','localNodeName','localIsC2PData','localEffectiveAsOf','localEntryAsOf','localXsltMessages118']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['c2pAggregatedResult118','localOriginalRequests118','localPreTransformData118']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="ReduceDebug">
                    <cc:expression>if (context.containsProperty('int0025DebugPropertyList')) {&#xD;
	props['int0025DebugPropertyList'].remove('localIsImportRequests');&#xD;
	props['int0025DebugPropertyList'].remove('localIsDoNotMatch');&#xD;
	props['int0025DebugPropertyList'].remove('localProcessWID');&#xD;
	props['int0025DebugPropertyList'].remove('localNodeName');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_118" routes-to="Teardown_118"/>
        <cc:aggregator id="AggregateData_118" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-mimetype="text/xml" output-variable="localPreTransformData118">
        <cc:header-text>&lt;Results></cc:header-text>
        <cc:footer-text>&lt;/Results></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-in id="Aggregate_118" routes-to="AggregateData_118">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_Debug_Variable_MergedData_118" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localPreTransformData118'"/>
        </cc:local-out>
        <cc:local-out id="Call_Aggregate_PayloadData_118" store-message="none" routes-response-to="Call_Debug_Variable_MergedData_118" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_118">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareImportRequests_118" routes-to="Call_Aggregate_PayloadData_118">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="localOriginalRequests118"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_EnrichmentData_118" store-message="none" routes-response-to="PrepareImportRequests_118" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_118">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareImportProcessMessages_118" routes-to="Call_Aggregate_EnrichmentData_118">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="c2pAggregatedResult118"/>
                <cc:eval id="ReleaseResource">
                    <cc:expression>vars['c2pAggregatedResult118'] = null;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="MergeRequestsWithResponses_118" routes-to="PrepareImportProcessMessages_118">
            
            
        </cc:local-in>
        <cc:local-out id="Call_HandleError_AbortOnChildThreadError_118" store-message="none" execute-when="props['outIsErrorsOnThreads']" routes-response-to="MakeVariableNullSafe_118" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Errors Encountered During Parallel Processing'"/>
            <cc:set name="inLogMessageDetail" value="'Errors were encountered on child threads.  Therefore, a complete data set cannot be guaranteed and continued processing cannot be trusted to be accurate.  The integration will be terminated due to issues encountered processing and aggregating the PagedGet results.'"/>
            <cc:set name="inLogReferenceId" value="''"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="'Call_HandleError_AbortOnChildThreadError_118'"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="''"/>
            <cc:set name="inExtraErrorCode" value="'11808'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_WriteThreadLogsToCloudLog_118" store-message="none" routes-response-to="Call_HandleError_AbortOnChildThreadError_118" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/WriteThreadLogsToCloudLog"/>
        <cc:local-in id="FinalizeReturnFromThread_118" routes-to="Call_WriteThreadLogsToCloudLog_118"/>
        <cc:aggregator id="AggregateParallelData_118" collate-when="props['aggregator.destination.force.collate'] &amp;&amp; props['localIsC2PData']" force-batch-on-last-message="false" force-batch-when="props['aggregator.destination.force.batch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-mimetype="text/xml" output-variable="c2pAggregatedResult118" xpath="/SoapResults/*">
        <cc:header-text>&lt;wd:Import_Process_Messages xmlns:wd=&quot;urn:com.workday/bsvc&quot;></cc:header-text>
        <cc:footer-text>&lt;/wd:Import_Process_Messages></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-out id="Call_CreateLogEntryOnThread_CrossThreadTransfer_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while extracing the results from the SOAP response using xpath[/env:Envelope/env:Body/wd:Get_Import_Process_Messages_Response/wd:Response_Data/wd:Import_Process_Message].  Processing of the remaining results will continue...'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
        </cc:local-out>
        <cc:async-mediation id="CrossThreadChildToChild_118" routes-to="AggregateParallelData_118" continue-after-error="rewind" execute-steps-when="props['aggregator.destination.force.collate'] &amp;&amp; props['localIsC2PData']" handle-downstream-errors="true">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="c2pPageToAggregate118"/>
                <cc:eval id="ReleaseResource">
                    <cc:expression>vars['c2pPageToAggregate118'] = null /* Remove the variable now that we've finished with it */</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntryOnThread_CrossThreadTransfer_118"/>
        </cc:async-mediation>
        <cc:async-mediation id="ValidateChildReturnData_118" routes-to="CrossThreadChildToChild_118">
            <cc:steps>
                <cc:eval id="TestForData">
                    <cc:expression>props['localIsC2PData'] = ((vars['c2pPageToAggregate118'] != null) &amp;&amp; (vars['c2pPageToAggregate118'].xstreamB('/SoapResults/*')));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="AggregateParallel_118" routes-to="ValidateChildReturnData_118">
            
            
            
            
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_118" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processed'"/>
            <cc:set name="inLogMessageDetail" value="'A page of SOAP results was processed'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="''"/>
            <cc:set name="inExtraRecordNumber" value="parts[0].xstream('/env:Envelope/env:Body/*/wd:Response_Results/wd:Page')"/>
            <cc:set name="inExtraSupportData" value="util.cleanString(com.workday.custom.int0025.ssk144.DebugBean.getDataFragmentOfDefaultSize(context, 'c2pPageToAggregate118'));"/>
            <cc:set name="inExtraErrorCode" value="''"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Warn_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while extracing the results from the SOAP response using xpath[/env:Envelope/env:Body/wd:Get_Import_Process_Messages_Response/wd:Response_Data/wd:Import_Process_Message].  Processing of the remaining results will continue...'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
        </cc:local-out>
        <cc:async-mediation id="CrossThreadParentToChild_118" routes-to="Call_CreateLogEntryOnThread_Debug_118" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="XsltPlus" output="variable" output-mimetype="text/xml" output-variable="c2pPageToAggregate118" url="xslt/ssk118/Get_Import_Process_Messages_Response.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntryOnThread_Warn_118"/>
        </cc:async-mediation>
        <cc:local-in id="ProcessPageParallel_118" routes-to="CrossThreadParentToChild_118">
            
        </cc:local-in>
        <cc:local-out id="CallSoapPagedGet_118" store-message="none" endpoint="vm://wcc/PagedGet">
            <cc:set name="is.paged.get.request.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Filter/wd:Page'"/>
            <cc:set name="is.paged.get.response.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Page'"/>
            <cc:set name="is.paged.get.response.total.pages.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Pages'"/>
            <cc:set name="is.paged.get.response.total.results.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Results'"/>
            <cc:set name="is.paged.get.process.endpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessPageParallel_118'"/>
            <cc:set name="is.paged.get.application" value="'Integrations'"/>
            <cc:set name="is.paged.get.version" value="props['inApiVersion']"/>
            <cc:set name="is.paged.get.page.zero" value="false"/>
            <cc:set name="is.paged.get.store.requests" value="true"/>
            <cc:set name="is.paged.get.parallel" value="true"/>
            <cc:set name="is.paged.get.parallel.aggregation.endpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/AggregateParallel_118'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_GetImportProcessMessagesRequest_118" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallSoapPagedGet_118" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Request__Get_Import_Process_Messages.xml'"/>
        </cc:local-out>
        <cc:local-out id="Call_InitializeThreadedLogging_118" store-message="none" routes-response-to="Call_Debug_GetImportProcessMessagesRequest_118" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StartThreadLog"/>
        <cc:local-out id="Call_HandleError_SoapPagedGet_Error_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'SOAP Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error was encountered initiating the PagedGet call for Import Process Messages.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="true"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP_Request__Get_Import_Process_Messages.xml'"/>
        </cc:local-out>
        <cc:sync-mediation id="GetImportProcessMessages_InitializeAndFinalize_118" routes-to="Call_InitializeThreadedLogging_118" routes-response-to="Call_FinalizeReturnFromThread_118">
            <cc:request-steps>
                <cc:eval id="PagedGetWebQueryCacheParams">
                    <cc:expression>currentTimestamp = com.workday.custom.int0025.DateUtils.now();&#xD;
&#xD;
props['localEffectiveAsOf'] = com.workday.custom.int0025.DateUtils.convertDateToXmlString(currentTimestamp);&#xD;
props['localEntryAsOf'] = com.workday.custom.int0025.DateUtils.convertDateTimeToXmlString(currentTimestamp);</cc:expression>
                </cc:eval>
                <cc:write id="WriteSoapRequest">
                    <cc:message>
                        <cc:text>&lt;soapenv:Envelope xmlns:wd=&quot;urn:com.workday/bsvc&quot; xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;>&#xD;
    &lt;soapenv:Header>&#xD;
        &lt;wd:Workday_Common_Header>&lt;wd:Include_Reference_Descriptors_In_Response>true&lt;/wd:Include_Reference_Descriptors_In_Response>&lt;/wd:Workday_Common_Header>&#xD;
    &lt;/soapenv:Header>&#xD;
    &lt;soapenv:Body>&#xD;
        &lt;wd:Get_Import_Process_Messages_Request wd:version=&quot;@{props['inApiVersion']}&quot;>&#xD;
            &lt;wd:Request_Criteria>&#xD;
                &lt;wd:Import_Process_Reference>&#xD;
                    &lt;wd:ID wd:type=&quot;WID&quot;>@{props['inProcessWID']}&lt;/wd:ID>&#xD;
                &lt;/wd:Import_Process_Reference>&#xD;
            &lt;/wd:Request_Criteria>&#xD;
            &lt;wd:Response_Filter>&#xD;
            	&lt;wd:As_Of_Effective_Date>@{props['localEffectiveAsOf']}&lt;/wd:As_Of_Effective_Date>&#xD;
            	&lt;wd:As_Of_Entry_DateTime>@{props['localEntryAsOf']}&lt;/wd:As_Of_Entry_DateTime>&#xD;
                &lt;wd:Page>1&lt;/wd:Page>&#xD;
                &lt;wd:Count>999&lt;/wd:Count>&#xD;
            &lt;/wd:Response_Filter>&#xD;
        &lt;/wd:Get_Import_Process_Messages_Request>&#xD;
    &lt;/soapenv:Body>&#xD;
&lt;/soapenv:Envelope></cc:text>
                    </cc:message>
                </cc:write>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_SoapPagedGet_Error_118"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_FinalizeReturnFromThread_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/FinalizeReturnFromThread_118"/>
        <cc:local-in id="GetImportProcessMessages_118" routes-to="GetImportProcessMessages_InitializeAndFinalize_118">
            <cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['inProcessWID']" documentation="The WID of the background process for which messages are being requested." name="inProcessWID" required="true" type="string"/>
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntry_ResponseMessage_Dynamic_118" store-message="none" endpoint="@{(props.inLogTarget == 'secondary') ? 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateSecondaryLogEntry' : 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry'}">
            <cc:set name="inLogMessage" value="'Issue with Import WWS Data'"/>
            <cc:set name="inLogMessageDetail" value="parts[0].xstream('/*/*/wd:Message_Summary')"/>
            <cc:set name="inLogReferenceId" value="props['inProcessWID']"/>
            <cc:set name="inLogLevel" value="parts[0].xstream('/*/*/wd:Severity')"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_ResponseMessage_Dynamic_118'"/>
            <cc:set name="inExtraRecordNumber" value="parts[0].xstream('/*/*/wd:Line_Number')"/>
            <cc:set name="inExtraSupportData" value="'The Reference Id contains the WID of the background process executing the import.  The timestamp of the error reported by the tenant is ' # (parts[0].xstream('/*/*/wd:Timestamp')) # '.'"/>
            <cc:set name="inExtraErrorCode" value="'11803'"/>
        </cc:local-out>
        <cc:splitter id="ResponseMessageSplitter_118" no-split-message-error="false">
            <cc:sub-route name="ProcessMessage" routes-to="Call_CreateLogEntry_ResponseMessage_Dynamic_118"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:local-out id="Call_HandleError_SimpleTransform_Error_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred executing the transformation of message data.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareResponseMessages_118" routes-to="ResponseMessageSplitter_118" handle-downstream-errors="true">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="c2pAggregatedResult118"/>
                <cc:eval id="ReleaseResource">
                    <cc:expression>vars['c2pAggregatedResult118'] = null;</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_SimpleTransform_Error_118"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_DetailedTransform_Error_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred executing the payload transformation using enrichment data.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareDetailedMessages_118" routes-to="RouteMessages_118" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="TranformToMessages" output-mimetype="text/xml" input="variable" input-variable="localPreTransformData118" messages-property="localXsltMessages118" url="@{'xslt/ssk118/' # props.localNodeName # '.xsl'}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DetailedTransform_Error_118"/>
        </cc:async-mediation>
        <cc:local-out id="Call_MergeRequestsWithResponses_118" store-message="none" routes-response-to="PrepareDetailedMessages_118" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/MergeRequestsWithResponses_118">
            
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_PrepareDynamicXPath_Error_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT Transform Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred executing the payload transformation using enrichment data.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="PrepareDynamicXPath_118" routes-to="Call_MergeRequestsWithResponses_118" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="GetRootElement" output-mimetype="text/plain" input="variable" input-variable="localOriginalRequests118" url="xslt/ssk118/Get_Root_Element_Name.xsl"/>
                <cc:eval id="InitValues">
                    <cc:expression>props['localNodeName'] = parts[0].text;&#xD;
&#xD;
//Note: The use of message.rootPartAsText is generally and categorically discouraged if not forbidden in production-grade code and use in MVEL.  &#xD;
//The reasoning supporting such restriction is that the message or variable content cannot be absolutely assured to be of manageable size, and when circumstances result in a larger-than-expected payload, the getText() methods result in excessively large strings resulting in very poor memory utilization and garbage collection performance with very adverse effects on the integration performance.&#xD;
&#xD;
//In this use case scenario, rootPartAsText may be used with complete confidence as we know definitively that the message will only contain a single string of nominal length based on the operation performed in the preceding step.&#xD;
//It is only with this absolute clarity and guarantee that we are using rootPartAsText.  Use of message.rootPartAsText, parts[0].text, or vars['variableName'].text is still STRONGLY discouraged in production code.&#xD;
</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('int0025DebugPropertyList')) {&#xD;
	props['int0025DebugPropertyList'].add('localNodeName');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_PrepareDynamicXPath_Error_118"/>
        </cc:async-mediation>
        <cc:route id="RouteLogChoice_118">
            <cc:mvel-strategy>
                <cc:choose-route expression="!props['inIsDoNotMatch']" route="LinkToRequest"/>
                <cc:choose-route expression="true" route="MessageOnly"/>
            </cc:mvel-strategy>
            <cc:sub-route name="LinkToRequest" routes-to="PrepareDynamicXPath_118"/>
            <cc:sub-route name="MessageOnly" routes-to="PrepareResponseMessages_118"/>
        </cc:route>
        <cc:local-out id="Call_GetImportProcessMessages_118" store-message="none" routes-response-to="RouteLogChoice_118" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/GetImportProcessMessages_118">
            <cc:set name="inApiVersion" value="props['inApiVersion']"/>
            <cc:set name="inProcessWID" value="props['inProcessWID']"/>
        </cc:local-out>
        <cc:local-in id="ProcessRequest_118" routes-to="Call_GetImportProcessMessages_118">
            <cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['localProcessWID']" documentation="The WID of the background process for which messages are being requested." name="inProcessWID" required="true" type="string"/>
            <cc:parameter default="props['localIsDoNotMatch']" documentation="Indicates if the request file from the Studio pre-processor expresses suppression of data/message matching for logging." name="inIsDoNotMatch" type="boolean"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_ProcessRequest_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessRequest_118" propagate-abort="false">
            <cc:set name="inApiVersion" value="props['inApiVersion']"/>
            <cc:set name="inProcessWID" value="props['localProcessWID']"/>
            <cc:set name="inIsDoNotMatch" value="props['localIsDoNotMatch']"/>
            <cc:set name="inDebugMode" value="props['inDebugMode']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Properties_118" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_ProcessRequest_118" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'properties'"/>
            <cc:set name="inTargetName" value="'int0025DebugPropertyList'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_LoggingDetail_Error_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Error Parsing Archive File'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while parsing the file from the archive to determine how to log Import Process Messages.'"/>
            <cc:set name="inLogReferenceId" value="props['inImportIntegrationEventWID']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="LoggingDetail_118" routes-to="Call_Debug_Properties_118" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localIsDoNotMatch'] = Boolean.valueOf(parts[0].xstreamB('/DoNotMessageMatch'));</cc:expression>
                    <cc:expression>props['localProcessWID'] = org.apache.commons.lang3.StringUtils.removeEnd(util.currentFilename, '.xml');</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('int0025DebugPropertyList')) {&#xD;
	props['int0025DebugPropertyList'].add('localIsDoNotMatch');&#xD;
	props['int0025DebugPropertyList'].add('localProcessWID');&#xD;
}</cc:expression>
                </cc:eval>
                <cc:validate-exp id="Validate">
                    <cc:expression error-number="11804" failure-message="The background process WID could not determined from the filename within the ImportRequests.zip archive.  The value is empty, and therefore, retrieving process messages is not possible.">props['localProcessWID'] != empty</cc:expression>
                </cc:validate-exp>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="localOriginalRequests118"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_LoggingDetail_Error_118"/>
        </cc:async-mediation>
        <cc:splitter id="ImportRequestsSplitter_118">
            <cc:sub-route name="ProcessRequest" routes-to="LoggingDetail_118"/>
            <cc:unzip-splitter format="zip"/>
        </cc:splitter>
        <cc:local-out id="Call_CreateLogEntry_EmptyFile_Warn_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'No Import Processes Found Within File'"/>
            <cc:set name="inLogMessageDetail" value="'The ImportRequests.zip file was found; however, it did not contain any files identifying the background process WIDs.'"/>
            <cc:set name="inLogReferenceId" value="props['inImportIntegrationEventWID']"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraLocalIn" value="'ImportRequestsSplitter_118'"/>
            <cc:set name="inExtraSupportData" value="'ImportRequests.zip was found on the Integration Event, but was empty.  See the Reference Id for the WID of that event.'"/>
            <cc:set name="inExtraErrorCode" value="'11801'"/>
        </cc:local-out>
        <cc:async-mediation id="ImportRequestsSplitter_Catch_118" routes-to="ImportRequestsSplitter_118" handle-downstream-errors="true">
            <cc:steps>
                <cc:retrieve id="RetrieveZip" output-mimetype="application/zip" collection="@{parts[0].xpath('/Document/Collection')}" entry="@{parts[0].xpath('/Document/EntryID')}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntry_EmptyFile_Warn_118"/>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_NoImports_Warn_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'No Import Process File Found'"/>
            <cc:set name="inLogMessageDetail" value="'The ImportRequests.zip file was not found; therefore, the background process WIDs are unknown and status cannot be queried.'"/>
            <cc:set name="inLogReferenceId" value="props['inImportIntegrationEventWID']"/>
            <cc:set name="inLogLevel" value="props['inLogLevelForNoImportProcessesFound']"/>
            <cc:set name="inExtraLocalIn" value="'DocumentAccessor_118'"/>
            <cc:set name="inExtraSupportData" value="'ImportRequests.zip was not found on Integration Event.  See the Reference Id for the WID of that event.'"/>
            <cc:set name="inExtraErrorCode" value="'11800'"/>
        </cc:local-out>
        <cc:route id="RouteResults_118">
            <cc:mvel-strategy>
                <cc:choose-route expression="!props['localIsImportRequests']" route="NoImports"/>
                <cc:choose-route expression="true" route="HasImports"/>
            </cc:mvel-strategy>
            <cc:sub-route name="NoImports" routes-to="Call_CreateLogEntry_NoImports_Warn_118"/>
            <cc:sub-route name="HasImports" routes-to="ImportRequestArchivesSplitter_118"/>
        </cc:route>
        <cc:local-out id="Call_HandleError_DocumentAccessor_Error_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'GetEventDocuments Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while parsing the Get_Event_Documents response.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="DocumentAccessor_118" routes-to="RouteResults_118" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="FilterArchives" output-mimetype="text/xml" url="xslt/ssk118/Get_Document_Repository_List.xsl"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['localIsImportRequests'] = parts[0].xstreamB('/*/*');</cc:expression>
                </cc:eval>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('int0025DebugPropertyList')) {&#xD;
	props['int0025DebugPropertyList'].add('localIsImportRequests');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DocumentAccessor_Error_118"/>
        </cc:async-mediation>
        <cc:local-out id="GetEventDocuments_118" store-message="none" routes-response-to="DocumentAccessor_118" endpoint="vm://wcc/GetEventDocuments">
            <cc:set name="ie.event.wid" value="props['inImportIntegrationEventWID']"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_GetEventDocs_Error_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'GetEventDocuments Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while calling Get_Event_Documents.'"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_118" routes-to="GetEventDocuments_118" handle-downstream-errors="true" routes-response-to="Call_Finally_Report_118">
            <cc:request-steps/>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_GetEventDocs_Error_118"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_Report_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_118"/>
        <cc:local-in id="ReportResultsOfCallSoapImport" routes-to="InitializeAndFinalize_118" access="public" icon="icons/ReportResultsOfCallSoapImport.png">
            <cc:parameter default="props['globalApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="context.containsProperty('int0025DebugWID') ? props['int0025DebugWID'] : props['int0025EventWID']" documentation="The WID of the Integration Event that initiated the Import WWS call and from which we need to retrieve information to know what background processes to query for status.  If not provided, the post processor is assumed to be linked to the Import WWS initiating system by way of the Integration BP and the current WID is defaulted." name="inImportIntegrationEventWID" required="true" type="string"/>
            <cc:parameter default="'ImportRequests.zip'" documentation="The filename of the zip archive produced by the pre-processor that initiated the requests.  Presumably, if initiated with SSK and SA-113, then this should be ImportRequests.zip, which is the default." name="inRequestFilename" required="true" type="string"/>
        	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs.  Sub-assembly processing and validation messages will still go to the primary log, but data-level messages will be directed per this configuration.  Note that the Extra Column configuration of the default secondary log is still coded and therefore assumed." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
        	<cc:parameter default="'warn'" documentation="The Cloud Log entry level for the message that indicates there were no import requests identified by the previous integration event for this component to follow-up on.  Depending on customer requirements, this may be expected and OK, or may be considered an error condition.  Set the log level appropriately to influence the integration event status." name="inLogLevelForNoImportProcessesFound" required="true" type="string" validation="['info', 'warn', 'error'] contains props['inLogLevelForNoImportProcessesFound'].trim().toLowerCase()"/>
			<cc:parameter default="'primary'" documentation="Controls where the xsl:message elements produced in the transformation are logged, whether to the primary, secondary or flex logs.  Component processing and validation messages will still go to the destination defined by inLogTarget, but data-level messages from the xslt will be directed per this configuration." name="inLogTargetForXsltMessages" required="true" type="string" validation="['primary', 'secondary', 'flexlog'] contains props['inLogTargetForXsltMessages'].trim().toLowerCase()"/>
		</cc:local-in>
        <cc:async-mediation id="Teardown_113">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="wd-external-request-id"/>
                        <cc:remove-header name="wd-external-application-id"/>
                        <cc:remove-header name="wd-external-originator-id"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsValuedProperty','localIsDefinedProperty','localIsCorrectTypeProperty','localIsNonEmptyMapProperty','localIsValuedVariable','localIsDefinedVariable','localIsCorrectTypeVariable','localIsNonEmptyMapVariable']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localRequestCache113','localImportRequestArchive113']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_113" routes-to="Teardown_113"/>
        <cc:async-mediation id="StoreArchive_113" execute-steps-when="props['inBatch']">
            <cc:steps>
                <cc:store id="StoreArchive" output="variable" output-variable="localImportRequestArchive113" createDocumentReference="true" expiresIn="@{props['inDocumentRetentionPeriod']}" title="ImportRequests.zip"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:aggregator id="AggregateToArchive_113" routes-to="StoreArchive_113" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:zip-file-collater output-mimetype="application/zip" message-entity-name="@{props['inEntityName']}"/>
        </cc:aggregator>
        <cc:async-mediation id="NonRequest_113" routes-to="AggregateToArchive_113" execute-steps-when="props['inCollate'] &amp;&amp; !props['inSupportDetailedResultReporting']">
            <cc:steps>
                <cc:write id="WriteMessage">
                    <cc:message>
                        <cc:text>&lt;DoNotMessageMatch/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="RestoreRequest_113" routes-to="NonRequest_113" execute-steps-when="props['inCollate'] &amp;&amp; props['inSupportDetailedResultReporting']">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output="message" output-mimetype="text/xml" input="variable" input-variable="localRequestCache113"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="ValidateArchive_113" routes-to="RestoreRequest_113">
            <cc:steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="11300" failure-message="WWS Import Request Aggregator (Aggregate_113) parameter failure.  The inCollate and inBatch arguments cannot both be false.">(!props['inCollate'] &amp;&amp; props['inBatch']) ||&#xD;
	(props['inCollate'] &amp;&amp; !props['inBatch']) ||&#xD;
	(props['inCollate'] &amp;&amp; props['inBatch'])</cc:expression>
                </cc:validate-exp>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Aggregate_113" routes-to="ValidateArchive_113">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
            <cc:parameter documentation="When collating to the aggregator, this will be the name of the file for the content within the zip archive." name="inEntityName" required="props['inCollate']" type="string"/>
            <cc:parameter documentation="This boolean flag will cause the SSK Component to output the request message to an archive of a fixed-name that will be accessed by the post-processor and determine if detailed data block to message level result reporting will be given." name="inSupportDetailedResultReporting" required="props['inCollate']" type="boolean"/>
            <cc:out-parameter name="outEntityName"/>
        </cc:local-in>
        <cc:local-out id="Call_Finally_Finalized_113" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113"/>
        <cc:local-out id="Call_Aggregate_Finalize_113" store-message="none" routes-response-to="Call_Finally_Finalized_113" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_113">
            <cc:set name="inCollate" value="false"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:local-in id="FinalizeCallSoapImport" routes-to="Call_Aggregate_Finalize_113" access="public" icon="icons/FinalizeCallSoapImport.png"><cc:parameter default="props['int0025DocumentRetentionPeriod']" documentation="The length of time to retain the ImportRequest.zip transfer artifact for the post-processor." name="inDocumentRetentionPeriod" required="true" type="string"/></cc:local-in>
        <cc:local-out id="Call_HandleError_Results_Error_113" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the SOAP results from the message rootpart to variable globalSoapResults.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inPathToXsltFile']"/>
        </cc:local-out>
        <cc:async-mediation id="Results_Handler_113" routes-to="Call_HandleError_Results_Error_113">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Results_113" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Results_Handler_113"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_113" store-message="none" routes-response-to="Results_113" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_113" clone-request="true">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="props['inIsFinalImportCall']"/>
            <cc:set name="inEntityName" value="props['outImportProcessReference'] # '.xml'"/>
        <cc:set name="inSupportDetailedResultReporting" value="props['inSupportDetailedResultReporting']"/></cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Response_Info_113" routes-response-to="Call_Aggregate_113" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Import Web Service Started'"/>
            <cc:set name="inLogMessageDetail" value="'Launched an import process on the ' # props['inWebServiceApplication'] # ' application.  See the Reference ID for the associated WID of the Import Process Reference.'"/>
            <cc:set name="inLogReferenceId" value="props['outImportProcessReference']"/>
            <cc:set name="inLogLevel" value="'info'"/>
        </cc:local-out>
        <cc:async-mediation id="RetrieveProcessReference_113" routes-to="PIM_ImportProcessTarget_113">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['outImportProcessReference'] = parts[0].xpath('/env:Envelope/env:Body/wd:Put_Import_Process_Response/wd:Import_Process_Reference/wd:ID[@wd:type=&quot;WID&quot;]');</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_SoapResponse_113" store-message="none" execute-when="props['inDebugMode']" routes-response-to="RetrieveProcessReference_113" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Response__' # props['inWebServiceApplication'] # '.xml'"/>
        </cc:local-out>
        <cc:workday-out-soap id="CallSoap_113" store-message="none" routes-response-to="Call_Debug_SoapResponse_113" application="@{props['inWebServiceApplication']}" version="@{props['inApiVersion']}"/>
        <cc:local-out id="Call_HandleError_HttpError_Error_113" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application HTTP request error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing a SOAP request for the '# props['inWebServiceApplication'] #' application.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inPathToXsltFile']"/>
        </cc:local-out>
        <cc:async-mediation id="RouteError_Http_Handler_113" routes-to="Call_HandleError_HttpError_Error_113">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'http';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_SoapError_Error_113" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="props['inWebServiceApplication'] #' application SOAP request error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while executing a SOAP request for the '# props['inWebServiceApplication'] #' application.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="'11301'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inPathToXsltFile']"/>
        </cc:local-out>
        <cc:async-mediation id="RouteError_Soap_Handler_113" routes-to="Call_HandleError_SoapError_Error_113">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'soap';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteError_113">
            <cc:mvel-strategy>
                <cc:choose-route expression="parts[0].isXml() &amp;&amp; (Integer.valueOf(parts[0].xpath('count(/SOAP-ENV:Envelope/SOAP-ENV:Body/SOAP-ENV:Fault)')) > 0)" route="SoapError"/>
                <cc:choose-route expression="true" route="HttpError"/>
            </cc:mvel-strategy>
            <cc:sub-route name="SoapError" routes-to="RouteError_Soap_Handler_113"/>
            <cc:sub-route name="HttpError" routes-to="RouteError_Http_Handler_113"/>
        </cc:route>
        <cc:async-mediation id="CallSoap_Catch_113" routes-to="CallSoap_113" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="RouteError_113"/>
        </cc:async-mediation>
        <cc:async-mediation id="CacheRequest_113" routes-to="CallSoap_Catch_113" execute-steps-when="props['inSupportDetailedResultReporting']">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="localRequestCache113" input-xpath="/env:Envelope/env:Body/*" stream-xpath="true"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_SoapRequest_113" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CacheRequest_113" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication'] # '.xml'"/>
        </cc:local-out>
        <cc:async-mediation id="SetHeaders_113" routes-to="Call_Debug_SoapRequest_113">
            <cc:steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                        <cc:add-header name="wd-external-request-id" value="@{props['inHeaderRequestId']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:set-headers execute-when="context.containsProperty('inHeaderOriginatorId') &amp;&amp; props['inHeaderOriginatorId'] != empty" id="SetOriginatorHeader">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="wd-external-originator-id" value="@{props['inHeaderOriginatorId']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:set-headers execute-when="context.containsProperty('inHeaderApplicationId') &amp;&amp; props['inHeaderApplicationId'] != empty" id="SetApplicationHeader">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="wd-external-application-id" value="@{props['inHeaderApplicationId']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:set-headers execute-when="context.containsProperty('inHeaderRequestId') &amp;&amp; props['inHeaderRequestId'] != empty" id="SetRequestHeader">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="wd-external-request-id" value="@{props['inHeaderRequestId']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:wrap-soap id="WrapSoap"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_BuildRequest_113" store-message="none" execute-when="props['inBuildRequestPathToXsltFile'] != empty" routes-response-to="SetHeaders_113" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/BuildRequest_113" propagate-abort="true">
            <cc:set name="inApiVersion" value="props['inApiVersion']"/>
            <cc:set name="inPathToXsltFile" value="props['inPathToXsltFile']"/>
            <cc:set name="inDebugMode" value="props['inDebugMode']"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_113" routes-to="Call_BuildRequest_113" routes-response-to="Call_Finally_Initiate_113">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outIsSoapError'] = '';</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_Initiate_113" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113"/>
        <cc:local-in id="CallSoapImport" routes-to="InitializeAndFinalize_113" access="public" icon="icons/CallSoapImport.png">
            <cc:parameter default="props['globalApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter documentation="The WWS application where the operation may be found, e.g. &quot;Human_Resources&quot;." name="inWebServiceApplication" required="true" type="string"/>
            <cc:parameter documentation="The location that holds the data to be used in the transform provided on the inPathToXsltFile parameter.  This value is dependent on the value of inDataLocationId.  The parameter can have one of three values: message, variable, or property.  When the value is 'message', then the message part identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  Similarly, if this parameter value is 'variable', then the variable identified by inDataLocationId is interpreted as XML data to which the inPathToXsltFile xslt will be applied.  if this parameter value is 'property', then the property identified by inDataLocationId is interpreted as a java.util.Map instance whose key/value pairs match pre-defined keys in the inPathToXsltFile xslt for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="props['inBuildRequestPathToXsltFile'] != empty" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (['message','variable','property'] contains props['inBuildRequestDataLocation'].trim().toLowerCase())) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocation'] == empty))"/>
            <cc:parameter documentation="The name that, when used with inBuildReqeustDataLocation, uniquely identifies which variable or property is to be used as the source data to which the transform provided on the inBuildReqeustPathToXsltFile parameter will be applied.  When inBuildReqeustDataLocation is 'message', then this parameter is ignored and the message root part is assumed." name="inBuildRequestDataLocationId" required="(props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message')" type="string" validation="((props['inBuildRequestPathToXsltFile'] != empty) &amp;&amp; (props['inBuildRequestDataLocation'].trim().toLowerCase() != 'message') &amp;&amp; (props['inBuildRequestDataLocationId'] != empty)) ||&#xD;&#xA;&#x9;((props['inBuildRequestPathToXsltFile'] == empty) &amp;&amp; (props['inBuildRequestDataLocationId'] == empty))"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot; using the data identified by the inDataLocation and inDataLocationId input parameters.  This SSK Component also supports pre-built, on-message requests as well as facilities to construct the request dynamically.  If this parameter is omitted or set to null / an empty string, then inDataLocation and inDataLocationId can also be omitted (they are ignored), and then the dynamic request construction will be bypassed and the message root part will be used as the request." name="inBuildRequestPathToXsltFile" required="(props['inBuildRequestDataLocation'] != empty) || (props['inBuildRequestDataLocationId'] != empty)" type="string"/>
            <cc:parameter default="true" documentation="This boolean flag will cause the SSK Component to output the request message to an archive of a fixed-name that will be accessed by the post-processor and determine if detailed data block to message level result reporting will be given." name="inSupportDetailedResultReporting" required="true" type="boolean"/>
            <cc:parameter default="context.containsProperty('outRequestIdHeader119') ? props['outRequestIdHeader119'] : null" documentation="Optional value to be set to the wd-external-request-id HTTP header." name="inHeaderRequestId" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('outApplicationIdHeader119') ? props['outApplicationIdHeader119'] : null" documentation="Optional value to be set to the wd-external-application-id HTTP header." name="inHeaderApplicationId" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('outOriginatorIdHeader119') ? props['outOriginatorIdHeader119'] : null" documentation="Optional value to be set to the wd-external-originator-id HTTP header." name="inHeaderOriginatorId" required="false" type="string"/>
            <cc:parameter default="'message'" documentation="Where the results of the response are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the SOAP request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="true" documentation="If this is the last Import WWS call that will be made by the integration, then set this parameter to true.  Otherwise, if additional Import WWS calls will be made, set this to false until the final call.  When this value is true, the ImportRequests.zip archive is produced for use in logging import results in the post-processor." name="inIsFinalImportCall" required="true" type="boolean"/>
            <cc:parameter default="props['int0025DocumentRetentionPeriod']" documentation="The length of time to retain the ImportRequest.zip transfer artifact for the post-processor.  Required only if inIsFinalImportCall is true and this is the last import request being started." name="inDocumentRetentionPeriod" required="props['inIsFinalImportCall']" type="string"/>
            <cc:out-parameter documentation="A string to indicate that the request resulted in an error and identify the type.  If the error was at the API level, then outIsSoapError == 'http'.  If the error was at the tenant/application level, then outIsSoapError == 'soap'.  If there was an error unrelated to the API call, then outIsSoapError == 'logic'.  If there is no error, , then outIsSoapError == empty.  Further individual errors determined by Get_Event_Details or Get_Import_Processes are not handled here." name="outIsSoapError"/>
            <cc:out-parameter documentation="The error message of the exception for possible higher-level logging needs." name="outErrorMessage"/>
            <cc:out-parameter documentation="The WID of the Import Process returned on the SOAP response from invoking the import web service.  This WID is later used to retrieve the outcome of the import process as well as any individual data failures." name="outImportProcessReference"/>
        </cc:local-in>
        <cc:local-out id="Call_Debug_GetEventDocuments_110" store-message="none" execute-when="props['inDebugMode']" routes-response-to="DocumentAccessor_110" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'Get_Event_Documents_Response.xml'"/>
        </cc:local-out>
        <cc:async-mediation id="LoadFile_Variable_111" execute-steps-when="props['inReturnResults'].toString().toLowerCase() != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_LoadFile_Error_111" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'File Read Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while reading file ' # ((props['inFilename'] != empty) ? (props['inFilename'] # ' ') : '') # 'into the message root with Collection = ' # props['inCollection'] # ' and Entry = ' # props['inEntryID']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="LoadFile_111" routes-to="LoadFile_Variable_111" handle-downstream-errors="true">
            <cc:steps>
                <cc:retrieve id="Retrieve" collection="@{props['inCollection']}" entry="@{props['inEntryID']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_LoadFile_Error_111"/>
        </cc:async-mediation>
        <cc:local-out id="ProcessSplitMessage_116" store-message="none" endpoint="@{props['inProcessEndpoint']}"/>
        <cc:splitter id="Split_116" no-split-message-error="false">
            <cc:sub-route name="SubRoute" routes-to="ProcessSplitMessage_116"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:async-mediation id="StoreOutput_116" routes-to="Call_ProcessEndpoint_116" execute-steps-when="props['inProcessEndpoint'] == empty &amp;&amp; props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_BuildBlockMessage_Error_116" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT3 Block Splitter Error'"/>
            <cc:set name="inLogMessageDetail" value="'The XML data was unable to be split using the XSLT Block Splitter'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'XsltBlockSplitter-SplitXml.xml'"/>
        <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_116'"/><cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:async-mediation id="BuildBlockMessage_116" routes-to="Call_Debug_BlockSplitResults_116" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="SplitXML" url="xslt/ssk116/SSK116_XsltBlockSplit.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_BuildBlockMessage_Error_116"/>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareData_116" routes-to="BuildBlockMessage_116" execute-steps-when="props['inDataLocation'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>message.setMessage(vars[props.inDataLocation].source, vars[props.inDataLocation].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="BlockSplitter" routes-to="InitializeAndFinalize_116" access="public" icon="icons/XsltBlockSplitter.png">
            <cc:parameter default="'message'" documentation="Where the XML data being split can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inDataLocation" required="true" type="string"/>
            <cc:parameter documentation="The numer of records that should be included in each output message.  Value must be a positive non-zero integer.  If inIsUseParallel is true, then this parameter will determine how many records are processed on each worker thread.  If additional splitting would be required on the worker thread to process the block, then this value should be set to 1." name="inBlockSize" required="true" type="integer" validation="props['inBlockSize'] > 0"/>
            <cc:parameter default="'/*/*'" documentation="XPath expression selecting the element(s) which will be included in each block of records.  This must be a streamable query" name="inItemXPath" required="false" type="string"/>
            <cc:parameter default="false" documentation="Boolean flag indicates that an error should be raised if there are no results from the attempt to block-split." name="inIsNoBlockSplitAnError" required="true" type="boolean"/><cc:parameter default="false" documentation="Determines if this component will route the result of the XSLT block split to a wcc/ParallelSubroutine to be processed.  If this value is true, then the inProcessEndpoint, inAggregationEndpoint, inParallelThreadCount, inParallelThreadTimeout, inParallelSplitterTimeout must also be provided.  If this value is false, then inProcessEndpoint is optional and the others should be omitted." name="inIsUseParallel" required="true" type="boolean"/><cc:parameter documentation="Specifies the endpoint (i.e., vm://INT0025_CheckWorkRights_VisaCheck_Inbound/&lt;Sample_Local-In>) that should be invoked to process each block of output message.  If not specified, the blocked-and-unsplit output will be returned to the caller (i.e., the original data surrounded by &lt;Blocks> and &lt;Block> tags).  If inUseParallel is true, then this must point to a thread-safe sub-assembly." name="inProcessEndpoint" required="props['inIsUseParallel']" type="string"/>
            <cc:parameter documentation="Specifies the endpoint (i.e., vm://INT0025_CheckWorkRights_VisaCheck_Inbound/&lt;Sample_Local-In>) that should be invoked to serve aggregation from each worker thread when inIsUseParallel is true.  This must point to a thread-safe sub-assembly." name="inAggregationEndpoint" required="props['inIsUseParallel']" type="string"/><cc:parameter default="4" documentation="This parameter sets the number of child threads that will be run.  Workday parallelism is not unbounded, and the target system must be considered as well for the amount of concurrency that can be supported.  The value must be at least 2 threads and not more than 7." name="inParallelThreadCount" required="props['inIsUseParallel']" type="integer" validation="props['inParallelThreadCount'] > 1 &amp;&amp; props['inParallelThreadCount'] &lt;= 8"/><cc:parameter default="60" documentation="This parameter specifies the number of seconds in which the child thread is to complete before being interrupted and terminated." name="inParallelThreadTimeout" required="props['inIsUseParallel']" type="integer" validation="props['inParallelThreadTimeout'] > 0 &amp;&amp; props['inParallelThreadTimeout'] &lt;= 7200"/><cc:parameter default="3600" documentation="This parameter specifies the number of seconds in which the ParallelSubroutine is to complete before being interrupted and terminated." name="inParallelSplitterTimeout" required="props['inIsUseParallel']" type="integer" validation="props['inParallelThreadTimeout'] > 0 &amp;&amp; props['inParallelThreadTimeout'] &lt;= 7200"/><cc:parameter default="'message'" documentation="If supplied, then this is where the results of the XSLT Block Split are returned.  The result return also depends on the inProcessEndpoint value.  If the inReturnResults value is &quot;message&quot; and inProcessEndpoint is not specified, then the message root will contain all blocks when the SSK Component ends.  If the inReturnResults value is a variable name and inProcessEndpoint is not specified, then the named variable will contain all blocks when the SSK Component ends.  If inProcessEndpoint is defined, then the inReturnResults value is ignored, and it is up to the behavior of the dynamic endpoint as to what the final data state is.  The dynamic endpoint can expect to receive the block-split data on the message root part.  If inIsUseParallel is true, then inReturnResults is also ignored." name="inReturnResults" required="(!props['inIsUseParallel']) || (props['inProcessEndpoint'] == empty)" type="string"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not in-progress snapshots of data are output." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
			<cc:parameter default="'primary'" documentation="Controls message logging to either the primary or secondary logs.  This affects both error messages as well as messages logged with SSK143 CreateLogEntryOnThread when inIsUseParallel is true and inProcessEndpoint references a sub-assembly to run on a child thread." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>            
        </cc:local-in>
        <cc:sync-mediation id="Debug_InitializeAndFinalize_144" routes-to="RouteType_144">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outEntityName'] = '';</cc:expression>
                </cc:eval></cc:request-steps>
            <cc:response-steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['int0025FileBackedManagedDataDebugFragment','localCounter144','localKeys144','localValue144','localCollection144']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['debugTemporaryStorage','','','']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="SetValues">
                    <cc:expression>if (['message','variable'] contains props['inTargetType'].trim().toLowerCase()) {&#xD;
	props.outDebugLogged144 = true;&#xD;
} else if (!context.containsProperty('outDebugLogged144')) {&#xD;
	props.outDebugLogged144 = false;&#xD;
} else {&#xD;
	props.outDebugLogged144 = props.outDebugLogged144 || false;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:response-steps>
        </cc:sync-mediation>
        <cc:local-in id="ProcessEndpoint_116" routes-to="Split_116"/>
        <cc:local-out id="Call_ProcessEndpoint_116" store-message="none" execute-when="props['inProcessEndpoint'] != empty" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessEndpoint_116"/>
        <cc:async-mediation id="ValidateBlockSplitResults_116" routes-to="RouteSplit_116">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localIsBlocks'] = parts[0].xstreamB('/Blocks/Block')</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateExp">
                    <cc:expression error-number="11602" failure-message="The source data failed to be block split.  No blocks were produced.">!props['inIsNoBlockSplitAnError'] || &#xD;
	(props['inIsNoBlockSplitAnError'] &amp;&amp; props['localIsBlocks'])</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="Call_HandleError_ValidateBlockSplitResults_Error_116"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_ValidateBlockSplitResults_Error_116" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT3 Block Splitter Results Error'"/>
            <cc:set name="inLogMessageDetail" value="'The XSLT Block Splitter produced no results based on XPath to splitter of ['# props.inItemXPath #']'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="'11602'"/>
            
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'XsltBlockSplitter-ResultXml.xml'"/>
        <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_116'"/><cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:async-mediation id="Teardown_116">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localIsBlocks']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_116" routes-to="Call_CreateLogEntry_FlushInfo_116"/>
        <cc:local-out id="Call_Finally_116" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_116"/>
        <cc:sync-mediation id="InitializeAndFinalize_116" routes-to="PrepareData_116" routes-response-to="Call_Finally_116">
            <cc:request-steps>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="11600" failure-message="Input parameter inDataLocation was not &quot;message&quot; and was not located as a variable.  The value must either be &quot;message&quot; or refer to a valid, bound variable.">props['inDataLocation'] == 'message' || context.variables.isVariable(props.inDataLocation)</cc:expression>
                    <cc:expression error-number="11601" failure-message="Input parameter inReturnResults was not &quot;message&quot; or a value for use as a variable name.  The value must either be &quot;message&quot; or a valid variable name.">props['inIsUseParallel'] || props['inReturnResults'] != empty</cc:expression>
                </cc:validate-exp>
            </cc:request-steps>
            <cc:response-steps/>
        </cc:sync-mediation>
        <cc:sync-mediation id="InitializeAndFinalize_115" routes-to="GetEventDocuments_115" routes-response-to="Call_Finally_115">
            <cc:request-steps>
            </cc:request-steps>
            <cc:response-steps/>
        </cc:sync-mediation>
        <cc:async-mediation id="CopyResultFromThreads_115" routes-to="Call_Debug_Message_115">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" input="variable" input-variable="c2pAggregatedResult"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_PrepareFileResults_Error_115" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the DIS results from the message rootpart to variable globalDISResults.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_115'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localXslt115'"/><cc:set name="inEntityName" value="'mctx_vars_localXslt115.xsl'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_DocumentResults_115" store-message="none" execute-when="props['inDebugMode']" routes-response-to="RouteParallelism_115" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug" clone-request="true"><cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'Get_Event_Documents_Response.xml'"/></cc:local-out>
        <cc:local-out id="PIM_Debug_Stats_Secondary_142" store-message="none" execute-when="props['int0025SecondaryLogCountDebug'] > 0" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'DEBUG'"/>
            <cc:set name="is.message.summary" value="props['int0025SecondaryLogCountDebug'] + ' debug message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Info_Stats_Secondary_142" store-message="none" execute-when="props['int0025SecondaryLogCountInfo'] > 0" routes-response-to="PIM_Debug_Stats_Secondary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="props['int0025SecondaryLogCountInfo'] + ' informational message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Warning_Stats_Secondary_142" store-message="none" execute-when="props['int0025SecondaryLogCountWarn'] > 0" routes-response-to="PIM_Info_Stats_Secondary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'WARNING'"/>
            <cc:set name="is.message.summary" value="props['int0025SecondaryLogCountWarn'] + ' warning(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Error_Stats_Secondary_142" store-message="none" execute-when="props['int0025SecondaryLogCountError'] > 0" routes-response-to="PIM_Warning_Stats_Secondary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'ERROR'"/>
            <cc:set name="is.message.summary" value="props['int0025SecondaryLogCountError'] + ' error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Critical_Stats_Secondary_142" store-message="none" execute-when="props['int0025SecondaryLogCountCritical'] > 0" routes-response-to="PIM_Error_Stats_Secondary_142" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'CRITICAL'"/>
            <cc:set name="is.message.summary" value="props['int0025SecondaryLogCountCritical'] + ' critical error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-in id="LogStatsSecondary" routes-to="PIM_Critical_Stats_Secondary_142" access="private"/>
        <cc:local-out id="Call_LogStatsSecondary_142" execute-when="props['inLogFinalize']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/LogStatsSecondary"/>
        <cc:async-mediation id="OutputSecondaryLog_142" routes-to="PIM_SecondaryTag_142" execute-steps-when="props['localIsLogReady142']">
            <cc:steps>
                <cc:eval id="Setup">
                    <cc:expression>props['int0025SecondaryLogFilesStored'] = props['int0025SecondaryLogFilesStored'] + 1</cc:expression>
                    <cc:expression>if (props['int0025SecondaryLogFileFormat'] == 'HTML') {&#xD;
	props['localSecondaryLogFileExtension'] = '.html';&#xD;
} else if (props['int0025SecondaryLogFileFormat'] == 'CSV') {&#xD;
	props['localSecondaryLogFileExtension'] = '.csv';&#xD;
} else {&#xD;
	props['localSecondaryLogFileExtension'] = '.xlsx';&#xD;
}</cc:expression>
                    <cc:expression>props['localSecondaryLogFilenameForStorage'] = (props['int0025SecondaryLogMaxCountPerFile'] == 0) ? props['int0025SecondaryLogFilename'] # props['localSecondaryLogFileExtension'] : props['int0025SecondaryLogFilename'] # &quot;_&quot; # props['int0025SecondaryLogFilesStored'] # props['localSecondaryLogFileExtension']</cc:expression>
                </cc:eval>
                <cc:store id="StoreCloudLog" output="variable" output-variable="logStoreResult" input="variable" input-variable="cloud-log-secondary" createDocumentReference="false" expiresIn="@{props['int0025SecondaryLogExpires']}" title="@{props['localSecondaryLogFilenameForStorage']}"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="StoreLogSecondary" routes-to="SecondaryDetermineOutput_142" access="public">
            <cc:parameter default="false" name="inLogFinalize" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_StoreLogSecondary" store-message="none" execute-when="props['int0025IsSecondaryLogEnabled']" routes-response-to="Call_Debug_Finalize_109" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLogSecondary">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="Call_StoreLogSecondary_Error_109" store-message="none" execute-when="props['int0025IsSecondaryLogEnabled']" routes-response-to="Call_Debug_Initialize_Finalize_Error_109" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLogSecondary">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="Call_StoreLogSecondary_GEH" store-message="none" execute-when="props['int0025IsSecondaryLogEnabled']" routes-response-to="Call_Debug_Finalize_GEH" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLogSecondary">
            <cc:set name="inLogFinalize" value="true"/>
        </cc:local-out>
        <cc:local-out id="Call_StoreLogSecondary_142" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreLogSecondary">
            <cc:set name="inLogFinalize" value="false"/>
        </cc:local-out>
        <cc:local-in id="CreateSecondaryLogEntry" routes-to="RouteSecondaryLogType_142" access="public" icon="icons/CreateSecondaryLogEntry.png">
            <cc:parameter documentation="Value that will be written to the Message attribute of the Cloud Logger." name="inLogMessage" required="true" type="string"/>
            <cc:parameter documentation="Value that will be written to the Message Details attribute of the Cloud Logger." name="inLogMessageDetail" required="false" type="string"/>
            <cc:parameter documentation="Value that will be written to the Reference Id attribute of the Cloud Logger.  This is most commonly used to record the WID of the record to which this message pertains and can save the MVEL code of concatenating it into the Message Detail." name="inLogReferenceId" required="false" type="string"/>
            <cc:parameter documentation="Value that determines the Level attribute of the Cloud Logger.  Must be one of: debug, info, warn, error, critical." name="inLogLevel" required="true" type="string" validation="['debug','info','warn','error','critical'] contains props['inLogLevel'].trim().toLowerCase()"/>
            <cc:parameter documentation="Value written to the LocalIn Extra Column on the log.  This field is a convention of SSK and used to record the name of a Mediation related to the message, e.g. the errorComponentId causing an error to be raised." name="inExtraLocalIn" required="false"/>
            <cc:parameter documentation="Value written to the RecordNumber Extra Column on the log.  This field is a convention of SSK and used to record the position/count of a data record in a set to which this message pertains." name="inExtraRecordNumber" required="false"/>
            <cc:parameter documentation="Value written to the SupportData Extra Column on the log.  This field is a convention of SSK and used to provide open-ended advice for support.  This may constitute additional data values, or it may mean remediation advice for a particular error." name="inExtraSupportData" required="false"/>
            <cc:parameter documentation="Value written to the ErrorCode Extra Column on the log.  This field is a convention of SSK and used to provide the value of the error code when the message is logging error information.  This code may be given by the ESB, or it may be a custom code defined by the developer.  Note that this field is a String whereas Studio/ESB codes are integers, so type conversion is required." name="inExtraErrorCode" required="false"/>
        </cc:local-in>
        <cc:local-out id="Call_CreateSecondaryLogEntry_141" store-message="none" execute-when="props['inLogTarget'] == 'secondary'" routes-response-to="Call_Debug_Parent_141" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateSecondaryLogEntry">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;props['inLogMessage']"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;((props['inLogMessageDetail'] != empty) ? props['inLogMessageDetail'] : '')"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;((props['inLogReferenceId'] != empty) ? props['inLogReferenceId'] : '')"/>
            <cc:set name="inLogLevel" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogLevel')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogLevel')) :&#xD;&#xA;&#x9;&#x9;props['inLogLevel']"/>
            <cc:set name="inExtraLocalIn" value="if (context.containsProperty('inExtraLocalIn')) {&#xD;&#xA;&#x9;props['inExtraLocalIn']&#xD;&#xA;} else {&#xD;&#xA;&#x9;''&#xD;&#xA;}"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;((props['inExtraRecordNumber'] != empty) ? props['inExtraRecordNumber'] : '')"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((props['inExtraSupportData'] != empty) ? props['inExtraSupportData'] : '')"/>
            <cc:set name="inExtraErrorCode" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraErrorCode')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraErrorCode')) : &#xD;&#xA;&#x9;&#x9;props['inExtraErrorCode']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateSecondaryLogEntry_LogThreadMessages_143" store-message="none" execute-when="props['inLogTarget'] == 'secondary'" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateSecondaryLogEntry">
            <cc:set name="inLogMessage" value="props['localParallelLogMessage143'].getSummary()"/>
            <cc:set name="inLogMessageDetail" value="props['localParallelLogMessage143'].getDetail()"/>
            <cc:set name="inLogReferenceId" value="props['localParallelLogMessage143'].getReferenceId()"/>
            <cc:set name="inLogLevel" value="props['localParallelLogMessage143'].getLevel()"/>
            <cc:set name="inExtraLocalIn" value="props['localParallelLogMessage143'].getLocalIn()"/>
            <cc:set name="inExtraRecordNumber" value="props['localParallelLogMessage143'].getRecordNumber()"/>
            <cc:set name="inExtraSupportData" value="props['localParallelLogMessage143'].getSupportData()"/>
            <cc:set name="inExtraErrorCode" value="props['localParallelLogMessage143'].getErrorCode()"/>
        </cc:local-out>
        <cc:local-in id="AggregateSources_107" routes-to="PrepareDataSources_107"/>
        <cc:async-mediation id="CacheMessage_107" routes-to="ForEachDataSource_107" execute-steps-when="props['localCacheMessage']">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="localMessageCache107"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="ForEachDataSource_107">
            <cc:loop-strategy condition="props['localSourceCounter'] &lt; props['localSourcesList'].length" increment="props['localSourceCounter'] = props['localSourceCounter'] + 1" init="props['localSourceCounter'] = 0"/>
            <cc:sub-route name="ForEach" routes-to="PrepareDataSource_107"/>
        </cc:route>
        <cc:async-mediation id="PrepareDataSource_107" routes-to="Call_Aggregate_SourceData_107">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>sourceName = props.localSourcesList[props.localSourceCounter];&#xD;
if (sourceName.toLowerCase() == 'message' &amp;&amp; props.localCacheMessage) {&#xD;
	message.setMessage(vars['localMessageCache107'].source, vars['localMessageCache107'].mimeType);&#xD;
} else if (sourceName.toLowerCase() != 'message') {&#xD;
	message.setMessage(vars[sourceName].source, vars[sourceName].mimeType);&#xD;
} else {&#xD;
	//no-op - sourceName == message and cache wasn't required, which means the content is already on-message&#xD;
}</cc:expression>
                    <cc:expression>props['localIsBatch'] = (props['localSourceCounter'] == (props['localSourcesList'].length - 1));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_SourceData_107" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Aggregate_107">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="props['localIsBatch']"/>
        </cc:local-out>
        <cc:local-out id="Call_AggregateSources_107" store-message="none" routes-response-to="Call_Debug_AggregatedData_107" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/AggregateSources_107"/>
        <cc:async-mediation id="PrepareDataSources_107" routes-to="CacheMessage_107">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>testString = org.apache.commons.lang3.StringUtils.replace(props.inDataSourceLocationList, ' ', '');&#xD;
props['localSourcesList'] = org.apache.commons.lang3.StringUtils.split(testString, ',');&#xD;
localMatches = 0;&#xD;
foreach (dataLoc : props['localSourcesList']) {&#xD;
	if (dataLoc.toLowerCase() == 'message') {&#xD;
		localMatches = localMatches + 1;&#xD;
	}&#xD;
}&#xD;
props['localCacheMessage'] = ((localMatches > 0) &amp;&amp; (!org.apache.commons.lang3.StringUtils.startsWith(testString.toLowerCase(), org.apache.commons.lang3.StringUtils.repeat('message', ',', Math.max(1, localMatches)))));&#xD;
</cc:expression>
                </cc:eval></cc:steps>
        </cc:async-mediation>
        <cc:route id="RoutePrimaryLogType_142">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['int0025PrimaryLogFileFormat'] == 'HTML'" route="HTML"/>
                <cc:choose-route expression="props['int0025PrimaryLogFileFormat'] == 'CSV'" route="CSV"/>
                <cc:choose-route expression="true" route="XLSX"/>
            </cc:mvel-strategy>
            <cc:sub-route name="HTML" routes-to="Call_WritePrimaryLog_HTML_142"/>
            <cc:sub-route name="CSV" routes-to="Call_WritePrimaryLog_CSV_142"/>
            <cc:sub-route name="XLSX" routes-to="Call_WritePrimaryLog_XLSX_142"/>
        </cc:route>
        <cc:local-in id="WritePrimaryLog_HTML_142" routes-to="PrimaryLog_HTML_142"/>
        <cc:local-in id="WritePrimaryLog_CSV_142" routes-to="PrimaryLog_CSV_142"/>
        <cc:local-in id="WritePrimaryLog_XLSX_142" routes-to="PrimaryLog_XLSX_142"/>
        <cc:async-mediation id="PrimaryLog_HTML_142" routes-to="UpdatePrimaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageHTML" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="HTML" reference-id="props['inLogReferenceId']" variable-name="cloud-log-primary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrimaryLog_CSV_142" routes-to="UpdatePrimaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageCSV" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="CSV" reference-id="props['inLogReferenceId']" variable-name="cloud-log-primary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrimaryLog_XLSX_142" routes-to="UpdatePrimaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageXLSX" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="XLSX" reference-id="props['inLogReferenceId']" variable-name="cloud-log-primary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_WritePrimaryLog_HTML_142" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/WritePrimaryLog_HTML_142"/>
        <cc:local-out id="Call_WritePrimaryLog_CSV_142" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/WritePrimaryLog_CSV_142"/>
        <cc:local-out id="Call_WritePrimaryLog_XLSX_142" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/WritePrimaryLog_XLSX_142"/>
        <cc:async-mediation id="SecondaryLog_XLSX_142" routes-to="UpdateSecondaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageXLSX" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="XLSX" reference-id="props['inLogReferenceId']" variable-name="cloud-log-secondary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="WriteSecondaryLog_XLSX_142" routes-to="SecondaryLog_XLSX_142"/>
        <cc:async-mediation id="SecondaryLog_CSV_142" routes-to="UpdateSecondaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageCSV" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="CSV" reference-id="props['inLogReferenceId']" variable-name="cloud-log-secondary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="WriteSecondaryLog_CSV_142" routes-to="SecondaryLog_CSV_142"/>
        <cc:async-mediation id="SecondaryLog_HTML_142" routes-to="UpdateSecondaryLogTracking_142">
            <cc:steps>
                <cc:cloud-log id="LogMessageHTML" level="props['inLogLevel'].trim().toLowerCase()" message="@{props['inLogMessage']}" message-details="@{props['inLogMessageDetail']}" output-file-type="HTML" reference-id="props['inLogReferenceId']" variable-name="cloud-log-secondary">
                    <cc:log-column key="LocalIn" label="Local In">@{props['inExtraLocalIn']}</cc:log-column>
                    <cc:log-column key="ErrorCode" label="Error Code">@{props['inExtraErrorCode']}</cc:log-column>
                    <cc:log-column key="RecordNumber" label="Record Number">@{props['inExtraRecordNumber']}</cc:log-column>
                    <cc:log-column key="SupportData" label="Support Data">@{props['inExtraSupportData']}</cc:log-column>
                </cc:cloud-log>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="WriteSecondaryLog_HTML_142" routes-to="SecondaryLog_HTML_142"/>
        <cc:route id="RouteSecondaryLogType_142">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['int0025SecondaryLogFileFormat'] == 'HTML'" route="HTML"/>
                <cc:choose-route expression="props['int0025SecondaryLogFileFormat'] == 'CSV'" route="CSV"/>
                <cc:choose-route expression="true" route="XLSX"/>
            </cc:mvel-strategy>
            <cc:sub-route name="HTML" routes-to="Call_WriteSecondaryLog_HTML_142"/>
            <cc:sub-route name="CSV" routes-to="Call_WriteSecondaryLog_CSV_142"/>
            <cc:sub-route name="XLSX" routes-to="Call_WriteSecondaryLog_XLSX_142"/>
        </cc:route>
        <cc:local-out id="Call_WriteSecondaryLog_XLSX_142" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/WriteSecondaryLog_XLSX_142"/>
        <cc:local-out id="Call_WriteSecondaryLog_CSV_142" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/WriteSecondaryLog_CSV_142"/>
        <cc:local-out id="Call_WriteSecondaryLog_HTML_142" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/WriteSecondaryLog_HTML_142"/>
        <cc:local-out id="Call_WriteLog_112" store-message="none" endpoint="@{props.dynamicEndpoint112}">
        	<cc:set name="inLogMessage" value="props['localLogMessage'].message"/>
        	<cc:set name="inLogMessageDetail" value="props['localLogMessage'].details"/>
        	<cc:set name="inLogReferenceId" value="props['localLogMessage'].referenceId"/>
        	<cc:set name="inLogLevel" value="String.valueOf(props['localLogMessage'].level)"/>
        	<cc:set name="inExtraLocalIn" value="props['localLogMessage'].localIn"/>
        	<cc:set name="inExtraRecordNumber" value="props['localLogMessage'].recordNumber"/>
        	<cc:set name="inExtraErrorCode" value="props['localLogMessage'].errorCode"/>
        	<cc:set name="inExtraSupportData" value="props['localLogMessage'].supportData"/>
        </cc:local-out>
        <cc:local-in id="XsltPlus" routes-to="Call_DebugBefore_129" access="public" icon="icons/XsltPlus.png">
        	<cc:parameter default="'message'" documentation="Where the XML data being transformed can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inDataLocation" required="true" type="string"/>
        	<cc:parameter documentation="The path relative to ws/WSAR-INF where the transformation stylesheet to be applied is found" name="inPathToXsltFile" required="true" type="string"/>
        	<cc:parameter default="false" documentation="A boolean flag to indicate whether or not your XSLT transformation utilizes ETV markup.  If true, then Studio ETV processing will be applied after the XSLT and before any XTT if applicable." name="inIsUseETV" required="false" type="boolean"/><cc:parameter default="false" documentation="A boolean flag to indicate whether or not your XSLT transformation utilizes XTT markup.  If true, then Studio XTT processing will be applied after the XSLT and, if applicable, ETV." name="inIsUseXTT" required="false" type="boolean"/><cc:parameter default="'message'" documentation="How the results are returned to the caller, either on the message if the value is 'message', which is the default, or in a variable of the name given as the value." name="inReturnResults" required="true" type="string"/>
        	<cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the inDataLocation content is output on debug." name="inDebugMode" required="false" type="boolean"/><cc:parameter default="props['int0025FlexLog']" name="inFlexLogBean" required="props['inLogTarget'].trim().toLowerCase() == 'flexlog'" validation="props['inFlexLogBean'] instanceof com.workday.custom.int0025.ssk147.FlexLogBean"/><cc:parameter default="props['int0025IsDebugMode'] ? 'debug' : 'info'" documentation="The minimum log level of message produced by the XSLT that will be recorded to the Cloud Log" name="inMinLogLevel" required="false" type="string" validation="['debug','info','warn','error','critical'] contains props['inMinLogLevel'].trim().toLowerCase()"/>
        	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary', 'flexlog'] contains props['inLogTarget'].trim().toLowerCase()"/>
        	<cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        <cc:out-parameter documentation="Indicates whether or not any message of any logging level was put to the Cloud Log from either XSLT or ETV/XTT.  Will return 'true' if logged and false otherwise." name="outIsLoggedMessages129"/></cc:local-in>
        <cc:async-mediation id="ApplyTransform_129" routes-to="Call_DebugAfter_129">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>if (props['inDataLocation'] != 'message') {&#xD;
	message.setMessage(vars[props.inDataLocation].source, vars[props.inDataLocation].mimeType);&#xD;
}</cc:expression>
                    <cc:expression>props['outIsLoggedMessages129'] = false;</cc:expression>
                </cc:eval>
                <cc:xslt-plus id="XsltPlus" messages-property="localMessages129" url="@{props['inPathToXsltFile']}"/>
                <cc:etv execute-when="props['inIsUseETV']" id="Etv" message-property="localEtvXttMessages129"/>
                <cc:xtt execute-when="props['inIsUseXTT']" id="Xtt" append-messages="true" message-property="localEtvXttMessages129"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['outIsLoggedMessages129'] = ((props['localMessages129'] != empty) || ((props['inIsUseETV'] || props['inIsUseXTT']) &amp;&amp; props['localEtvXttMessages129'] != empty));</cc:expression>
                </cc:eval>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>if (props['inReturnResults'] != 'message') {&#xD;
	vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ApplyTransform_Error_129"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_ApplyTransform_Error_129" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"><cc:set name="inLogMessage" value="'XsltPlus Error'"/><cc:set name="inLogMessageDetail" value="'An error was encountered applying the ' # props['inPathToXsltFile'] # ' stylesheet to the data on ' # props['inDataLocation'] # '.'"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/><cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/><cc:set name="inIsResetError" value="false"/><cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inLogTarget" value="props['inLogTarget']"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_CloudLogXSLTMessages_129" store-message="none" execute-when="(props['inLogTarget'].trim().toLowerCase() != 'flexlog') &amp;&amp; (props['localMessages129'] != empty)" routes-response-to="Call_CloudLogEtvXttMessages_129" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CloudLogXSLTMessages"><cc:set name="inMessages" value="props['localMessages129']"/><cc:set name="inIsClearMessages" value="true"/><cc:set name="inMinLogLevel" value="props['inMinLogLevel']"/><cc:set name="inLogTarget" value="props['inLogTarget']"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_QueryCache_Error_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            
            
        <cc:set name="inLogMessage" value="'WWS Query Cache will be voided'"/><cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="'ValidateQueryCache@ValidatedAndSetHeaders_104'"/><cc:set name="inExtraSupportData" value="'props.localIsQueryCacheEffective = ' # props.localIsQueryCacheEffective # '\nprops.localIsQueryCacheEntryDate = ' # props.localIsQueryCacheEntryDate"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104'"/><cc:set name="inIsAbortOnError" value="true"/><cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/><cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'SOAP-Request__' # props['inWebServiceApplication'] # '.xml'"/><cc:set name="inLogTarget" value="props['inLogTarget']"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-out id="CallSoapSerial_104" store-message="none" endpoint="vm://wcc/PagedGet">
            <cc:set name="is.paged.get.request.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Filter/wd:Page'"/>
            <cc:set name="is.paged.get.response.current.page.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Page'"/>
            <cc:set name="is.paged.get.response.total.pages.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Pages'"/>
            <cc:set name="is.paged.get.response.total.results.xpath" value="'/env:Envelope/env:Body/*/wd:Response_Results/wd:Total_Results'"/>
            <cc:set name="is.paged.get.process.endpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessPage_104'"/>
            <cc:set name="is.paged.get.application" value="props['inWebServiceApplication']"/>
            <cc:set name="is.paged.get.version" value="props['inApiVersion']"/>
            <cc:set name="is.paged.get.page.zero" value="true"/>
            <cc:set name="is.paged.get.store.requests" value="true"/>
            
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_AbortOnChildThreadError_104" store-message="none" execute-when="props['outIsErrorsOnThreads'] &amp;&amp; props['inIsAbortOnError']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Errors Encountered During Parallel Processing'"/>
            <cc:set name="inLogMessageDetail" value="'Errors were encountered on child threads.  Therefore, a complete data set cannot be guaranteed and continued processing cannot be trusted to be accurate.  The integration will be terminated due to issues encountered processing and aggregating the PagedGet results.'"/>
            <cc:set name="inLogReferenceId" value="''"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="'Call_HandleError_AbortOnChildThreadError_104'"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="''"/>
            <cc:set name="inExtraErrorCode" value="'10406'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_104'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:local-out id="Call_WriteThreadLogsToCloudLog_104" store-message="none" routes-response-to="Call_HandleError_AbortOnChildThreadError_104" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/WriteThreadLogsToCloudLog"><cc:set name="inLogTarget" value="props['inLogTarget']"/></cc:local-out>
        <cc:local-in id="FinalizeReturnFromThread_104" routes-to="Call_WriteThreadLogsToCloudLog_104"/>
        <cc:aggregator id="AggregateParallelData_104" collate-when="props['aggregator.destination.force.collate'] &amp;&amp; props['localIsC2PData']" force-batch-on-last-message="false" force-batch-when="props['aggregator.destination.force.batch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="variable" output-mimetype="text/xml" output-variable="c2pAggregatedResult104" xpath="/*/*">
        <cc:header-text>@{props['inAggregatedResultsHeader']}</cc:header-text>
        <cc:footer-text>@{props['inAggregatedResultsFooter']}</cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-out id="Call_CreateLogEntryOnThread_CrossThreadTransfer_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while transferring the results from the SOAP response to be aggregated.  Processing of the remaining results will continue but this page will be excluded...'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
        </cc:local-out>
        <cc:async-mediation id="CrossThreadChildToChild_104" routes-to="AggregateParallelData_104" continue-after-error="rewind" execute-steps-when="props['aggregator.destination.force.collate'] &amp;&amp; props['localIsC2PData']" handle-downstream-errors="true">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output-mimetype="text/xml" input="variable" input-variable="c2pPageToAggregate104"/>
                <cc:eval id="ReleaseResource">
                    <cc:expression>vars['c2pPageToAggregate104'] = null /* Remove the variable now that we've finished with it */</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntryOnThread_CrossThreadTransfer_104"/>
        </cc:async-mediation>
        <cc:async-mediation id="ValidateChildReturnData_104" routes-to="CrossThreadChildToChild_104">
            <cc:steps>
                <cc:eval id="TestForData">
                    <cc:expression>props['localIsC2PData'] = ((vars['c2pPageToAggregate104'] != null) &amp;&amp; (vars['c2pPageToAggregate104'].xstreamB('/*/*')));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="AggregateParallel_104" routes-to="RouteAggregation_104">
            
            
            
            
        </cc:local-in>
        <cc:local-out id="Call_CreateLogEntryOnThread_Default_Debug_104" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processed'"/>
            <cc:set name="inLogMessageDetail" value="'A page of SOAP results was processed'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="''"/>
            <cc:set name="inExtraRecordNumber" value="parts[0].xstream('/env:Envelope/env:Body/*/wd:Response_Results/wd:Page')"/>
            <cc:set name="inExtraSupportData" value="'Sorry.  The Debug SSK Component is not thread-safe and therefore the data page cannot be archived for debug.'"/>
            <cc:set name="inExtraErrorCode" value="''"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Default_Error_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while extracing the results from the SOAP response using xpath[/env:Envelope/env:Body/*/wd:Response_Data].  Processing of the remaining results will continue...'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
        </cc:local-out>
        <cc:async-mediation id="CrossThread_Default_104" routes-to="Call_CreateLogEntryOnThread_Default_Debug_104" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="XsltPlus" output="variable" output-mimetype="text/xml" output-variable="c2pPageToAggregate104" url="mctx:vars/localAggregationXslt104"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntryOnThread_Default_Error_104"/>
        </cc:async-mediation>
        <cc:local-in id="ProcessPageParallel_104" routes-to="RouteThreadProcessing_104">
            
        </cc:local-in>
        <cc:local-out id="Call_InitializeThreadedLogging_104" store-message="none" routes-response-to="PrepareThreadXsltForAggregation_104" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StartThreadLog"/>
        <cc:route id="RouteThreadProcessing_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inParallelPageProcessorEndpoint'] != empty" route="Custom"/>
                <cc:choose-route expression="true" route="Default"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Custom" routes-to="CustomThreadProcessCatch_104"/>
            <cc:sub-route name="Default" routes-to="CrossThread_Default_104"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntryOnThread_Custom_Error_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'SOAP Page Processing Error on Custom Endpoint'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while processing the results from the SOAP response using dynamic endpoint ['# props['inParallelPageProcessorEndpoint'] #'].  The exception was either not handled or was rethrown from that code.  Processing of the remaining results on other threads will continue...'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
        </cc:local-out>
        <cc:async-mediation id="CustomThreadProcessCatch_104" routes-to="Call_CreateLogEntryOnThread_Custom_Debug_104" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_CreateLogEntryOnThread_Custom_Error_104"/>
        </cc:async-mediation>
        <cc:local-out id="Call_CustomDynamicEndpoint_104" store-message="none" routes-response-to="CrossThread_Custom_104" endpoint="@{props['inParallelPageProcessorEndpoint']}"/>
        <cc:async-mediation id="CrossThread_Custom_104" execute-steps-when="!props['inParallelSuppressAggregation']">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-mimetype="text/xml" output-variable="c2pPageToAggregate104"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntryOnThread_Custom_Debug_104" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_CustomDynamicEndpoint_104" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'Invoking Dynamic Endpoint on Thread'"/>
            <cc:set name="inLogMessageDetail" value="'A page of SOAP results is routing to '# props['inParallelPageProcessorEndpoint'] #' to be processed'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="''"/>
            <cc:set name="inExtraRecordNumber" value="parts[0].xstream('/env:Envelope/env:Body/*/wd:Response_Results/wd:Page')"/>
            <cc:set name="inExtraSupportData" value="'Sorry.  The Debug SSK Component is not thread-safe and therefore the data page cannot be archived for debug.'"/>
            <cc:set name="inExtraErrorCode" value="''"/>
        </cc:local-out>
        <cc:route id="RouteAggregation_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inParallelSuppressAggregation']" route="Suppress"/>
                <cc:choose-route expression="true" route="Aggregate"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Suppress" routes-to="Call_CreateLogEntryOnThread_AggregationSuppressed_Info_104"/>
            <cc:sub-route name="Aggregate" routes-to="ValidateChildReturnData_104"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntryOnThread_AggregationSuppressed_Info_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'PagedGet Aggregation Suppressed'"/>
            <cc:set name="inLogMessageDetail" value="'The results of the paginated response will not be aggregated per configuration'"/>
            <cc:set name="inLogReferenceId" value="java.lang.Thread.currentThread().getName()"/>
            <cc:set name="inLogLevel" value="'info'"/>
            
            
            
            
        </cc:local-out>
        <cc:local-out id="Call_ParallelPostProcess_104" store-message="none" execute-when="props.inIsParallelPagedGet" routes-response-to="Call_Finally_104" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ParallelPostProcess_104"/>
        <cc:local-in id="ParallelPostProcess_104" routes-to="Call_FinalizeReturnFromThread_104"/>
        <cc:local-out id="Call_FinalizeReturnFromThread_104" store-message="none" routes-response-to="SetReturnResults_Message_104" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/FinalizeReturnFromThread_104"/>
        <cc:async-mediation id="SetReturnResults_Message_104" routes-to="SetReturnResults_Variable_104" execute-steps-when="!props['inParallelSuppressAggregation'] &amp;&amp; props['inReturnResults'] == 'message'">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" input="variable" input-variable="c2pAggregatedResult104"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="SetReturnResults_Variable_104" execute-steps-when="!props['inParallelSuppressAggregation'] &amp;&amp; props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveVarToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, (vars.getVariable('c2pAggregatedResult104')), vars.getMimeType('c2pAggregatedResult104'));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteInputSource_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'message'" route="Message"/>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'variable'" route="Variable"/>
                <cc:choose-route expression="true" route="Property"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Message" routes-to="Validation_Message_104"/>
            <cc:sub-route name="Variable" routes-to="Validation_Variable_104"/>
            <cc:sub-route name="Property" routes-to="Validation_Property_104"/>
        </cc:route>
        <cc:async-mediation id="Validation_Property_104" routes-to="PreparePropertyInput_104">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>propname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = context.containsProperty(propname);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (context.getProperty(propname) instanceof java.util.Map) &amp;&amp; !(((java.util.Map)(context.getProperty(propname))).isEmpty());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10404" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a context property named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10405" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced context property named [@{props.inBuildRequestDataLocationId}] was not an instance of a java.util.Map, or that Map was empty.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Property_104"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Variable_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleBuildRequestValidationError_104">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Variable_104" routes-to="PrepareVariableInput_104">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>varname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = (vars.isVariable(varname)) &amp;&amp; (vars[varname] != null);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (vars[varname].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10402" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a message variable named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10403" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced message variable named [@{props.inBuildRequestDataLocationId}] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Variable_104"/>
        </cc:async-mediation>
        <cc:local-in id="HandleBuildRequestValidationError_104" routes-to="Validation_Handler_104"/>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Message_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleBuildRequestValidationError_104">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Property_104" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleBuildRequestValidationError_104">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="MoveResultsToVariable_104" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteConcurrency_104">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsParallelPagedGet']" route="Parallel"/>
                <cc:choose-route expression="true" route="Serial"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Parallel" routes-to="Call_InitializeThreadedLogging_104"/>
            <cc:sub-route name="Serial" routes-to="CallSoapSerial_104"/>
        </cc:route>
        <cc:async-mediation id="PrepareThreadXsltForAggregation_104" routes-to="CallSoapParallel_104" execute-steps-when="!props['inParallelSuppressAggregation']">
            <cc:steps>
                <cc:write id="WriteXslt" output="variable" output-variable="localAggregationXslt104">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;xsl:stylesheet version=&quot;3.0&quot; &#xD;
    xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;&#xD;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&#xD;
    xmlns:wd=&quot;urn:com.workday/bsvc&quot;&#xD;
    xmlns:env=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&#xD;
    exclude-result-prefixes=&quot;#all&quot;>&#xD;
    &#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;shallow-skip&quot;/>&#xD;
    &lt;xsl:mode streamable=&quot;yes&quot; on-no-match=&quot;deep-copy&quot; name=&quot;replicate&quot;/>&#xD;
    &#xD;
    &lt;xsl:template match=&quot;/&quot;>&#xD;
        &lt;SoapResults xmlns:wd=&quot;urn:com.workday/bsvc&quot;>&#xD;
        	&lt;xsl:apply-templates select=&quot;@{props['inXpathToResultsToAggregate']}&quot; mode=&quot;replicate&quot;/>&#xD;
        &lt;/SoapResults>&#xD;
    &lt;/xsl:template>&#xD;
&lt;/xsl:stylesheet></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_WriteThreadLogsToCloudLog_Flush_104" store-message="none" execute-when="props['inIsParallelPagedGet'] &amp;&amp; props['localParallelLog143'] != empty" routes-response-to="Teardown_104" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/WriteThreadLogsToCloudLog">
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_FlushInfo_104" store-message="none" execute-when="props['inIsParallelPagedGet'] &amp;&amp; props['localParallelLog143'] != empty" routes-response-to="Call_WriteThreadLogsToCloudLog_Flush_104" endpoint="@{props['inLogTarget'] == 'secondary' ? 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateSecondaryLogEntry' : 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry'}">
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
        <cc:set name="inLogMessage" value="'Unlogged thread messages found'"/><cc:set name="inLogMessageDetail" value="'All messages from child threads in parallel PagedGet were not logged.  Messages will be flushed to the log.  This may result in out-of-order message sequences.'"/><cc:set name="inLogLevel" value="'info'"/><cc:set name="inExtraRecordNumber" value="props['localParallelLog143'].size()"/></cc:local-out>
        <cc:async-mediation id="MakeVariableNullSafe_118" execute-steps-when="vars['c2pAggregatedResult118'] == null">
            <cc:steps>
                <cc:write id="Write" output="variable" output-mimetype="text/xml" output-variable="c2pAggregatedResult118">
                    <cc:message>
                        <cc:text>&lt;?xml version='1.0' encoding='UTF-8'?>&#xD;
&lt;wd:Import_Process_Messages xmlns:wd=&quot;urn:com.workday/bsvc&quot;/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_AggregatedData_107" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Transform_107" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"><cc:set name="inTargetType" value="'variable'"/><cc:set name="inTargetName" value="'localPreTransformData107'"/><cc:set name="inEntitySuffix" value="props.inPathToXsltFile"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_Debug_Core_109" store-message="none" execute-when="props['int0025IsDebugMode']" routes-response-to="Call_IEP_10" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"><cc:set name="inTargetType" value="'properties'"/><cc:set name="inTargetName" value="'int0025DebugPropertyList'"/></cc:local-out>
        <cc:local-out id="Call_Debug_SoapXslt_103" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_Transform_Error_103" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Transformation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a SOAP service call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inBuildRequestPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inBuildRequestPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inBuildRequestPathToXsltFile']"/>
            <cc:set name="inLogTarget" value="'primary'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:async-mediation id="Transform_Handler_103" routes-to="Call_HandleError_Transform_Error_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Transform_103" routes-to="Call_Debug_SoapXslt_103">
            <cc:steps>
                <cc:xslt-plus id="WriteSoap" input="message" url="@{props['inBuildRequestPathToXsltFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Transform_Handler_103"/>
        </cc:async-mediation>
        <cc:async-mediation id="PreparePropertyInput_103" routes-to="Transform_103">
            <cc:steps>
                <cc:write id="PrimeMessage">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;Root/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Property_103" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleBuildRequestValidationError_103">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Property_103" routes-to="PreparePropertyInput_103">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>propname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = context.containsProperty(propname);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (context.getProperty(propname) instanceof java.util.Map) &amp;&amp; !(((java.util.Map)(context.getProperty(propname))).isEmpty());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10304" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a context property named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10305" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced context property named [@{props.inBuildRequestDataLocationId}] was not an instance of a java.util.Map, or that Map was empty.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Property_103"/>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareVariableInput_103" routes-to="Transform_103">
            <cc:steps>
                <cc:eval id="PrimeMessage">
                    <cc:expression>message.setMessage(vars[props.inBuildRequestDataLocationId].source, vars[props.inBuildRequestDataLocationId].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Variable_103" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleBuildRequestValidationError_103">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Variable_103" routes-to="PrepareVariableInput_103">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>varname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = (vars.isVariable(varname)) &amp;&amp; (vars[varname] != null);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (vars[varname].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10302" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a message variable named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10303" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced message variable named [@{props.inBuildRequestDataLocationId}] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Variable_103"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Message_103" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleBuildRequestValidationError_103">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Message_103" routes-to="Transform_103">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsValueDefined'] = parts[0] != empty;&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (parts[0].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="10300" failure-message="Message part[0] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="10301" failure-message="Message part[0] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Message_103"/>
        </cc:async-mediation>
        <cc:route id="RouteInputSource_103">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'message'" route="Message"/>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'variable'" route="Variable"/>
                <cc:choose-route expression="true" route="Property"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Message" routes-to="Validation_Message_103"/>
            <cc:sub-route name="Variable" routes-to="Validation_Variable_103"/>
            <cc:sub-route name="Property" routes-to="Validation_Property_103"/>
        </cc:route>
        <cc:local-in id="BuildRequest_103" routes-to="RouteInputSource_103">
            <cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestPathToXsltFile']" documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;." name="inBuildRequestPathToXsltFile" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestDataLocation']" documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('inBuildRequestDataLocationId') ? props['inBuildRequestDataLocationId'] : null" documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example." name="inBuildRequestDataLocationId" required="false" type="string"/>
            <cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="props['inIsAbortOnError']" name="inIsAbortOnError" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_Validation_Error_103" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Validation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating parameters for a SOAP service call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_103'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:async-mediation id="Validation_Handler_103" routes-to="Call_HandleError_Validation_Error_103">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="HandleBuildRequestValidationError_103" routes-to="Validation_Handler_103"/>
        <cc:local-out id="Call_CreateLogEntry_MissingVersion_Warn_121" store-message="none" execute-when="props['int0025Version'] == empty" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"><cc:set name="inLogMessage" value="'Missing SSK Version Number'"/><cc:set name="inLogMessageDetail" value="'The SSK version number is held in the &quot;int0025StudioStarterKitVersion&quot; property and read from the WSAR-INF/ws-application.xml file.  This value provides important insights to Workday in managing the Integration Cloud and should be left in Studio CLAR file at all times.'"/><cc:set name="inLogLevel" value="'warn'"/><cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_MissingVersion_Warn_121'"/><cc:set name="inExtraSupportData" value="'Either the WSAR-INF/ws-application.xml file has been removed/modified, or MVEL code in SetConstantValues@Initialize has been removed/modified.  Please restore this code to enable version identification.'"/></cc:local-out>
        <cc:async-mediation id="Initialize_109" routes-to="TopLevelErrorTrap_109" continue-after-error="rewind" handle-downstream-errors="false">
            <cc:steps>
                <cc:eval id="FlexLogAssets">
                    <cc:expression>// This initialization happens outside of the CoreInitializationBean to support mock injection during unit tests&#xD;
props['int0025FlexLogMetaBean'] = new com.workday.custom.int0025.ssk109.FlexLogMetaConfiguration();</cc:expression>
                </cc:eval>
                <cc:custom id="InitializeCoreSSK" ref="SSK109InitializeCore"/>
                <cc:eval id="StaticAnalysisExemptions">
                    <cc:expression>// Add other local-in names to the list that you may be using as dynamic endpoints.  For example, if you have a SSK Component that you're using on the inParallelPageProcessorEndpoint parameter of SSK-104.&#xD;
props['int0025StaticCodeAnalysisExemptionList'].add('Main');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="PIM_InitializationFailed_109"/>
        </cc:async-mediation>
        <cc:local-out id="PIM_InitializationFailed_109" store-message="none" endpoint="vm://wcc/PutIntegrationMessage"><cc:set name="is.message.severity" value="'CRITICAL'"/><cc:set name="is.message.summary" value="context.exception == empty ? 'Failed to initialize SSK Framework configuration' : context.exception.message"/><cc:set name="is.message.detail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/></cc:local-out>
        <cc:async-mediation id="UpdatePrimaryLogTracking_142" routes-to="Call_StoreLogPrimary_142">
            <cc:steps>
                <cc:eval id="UpdateLogCounts">
                    <cc:expression>com.workday.custom.int0025.ssk142.GeneralCloudLogHelper.updateLogCounts(context, 'primary');</cc:expression>
					</cc:eval></cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="UpdateSecondaryLogTracking_142" routes-to="Call_StoreLogSecondary_142">
            <cc:steps>
                <cc:eval id="UpdateLogCounts">
                    <cc:expression>com.workday.custom.int0025.ssk142.GeneralCloudLogHelper.updateLogCounts(context, 'secondary');</cc:expression>
					</cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Teardown_120">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>isCleanUp = (props.inIsInvokedByHandleError &amp;&amp; context.isAbort()) || (!props.inIsInvokedByHandleError);</cc:expression>
                    <cc:expression>if (isCleanUp) {&#xD;
	foreach (propname : ['localRestUrl','localIsUseBatch','localIsDataJson','localRecordCount']) {
		context.removeProperty(propname);
	}&#xD;
}</cc:expression>
                    <cc:expression>if (isCleanUp) {&#xD;
	foreach (varname : ['localCountResult120']) {&#xD;
		vars[varname] = null;&#xD;
	}&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_120" routes-to="Teardown_120"><cc:parameter default="true" name="inIsInvokedByHandleError" required="true" type="boolean"/></cc:local-in>
        <cc:local-out id="Call_Debug_Result_120" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Results_120" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="props['inCustomObjectServiceAlias'] # '__Response.json'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_Results_Error_120" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the custom object results from the message rootpart to the '# props.inReturnResults #' variable.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_120'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:async-mediation id="Results_120" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_120"/>
        </cc:async-mediation>
        <cc:workday-out-rest id="CallCustomObjectAPI_120" store-message="none" routes-response-to="Call_Debug_Result_120" extra-path="@{props['localRestUrl']}" method="@{props['inHttpMethod']}"/>
        <cc:local-out id="Call_HandleError_CallService_Error_120" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Non-Effective Dated Custom Object Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while updating the non-effective dated custom object for the '# props['inCustomObjectServiceAlias'] #' custom object alias.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_120'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:async-mediation id="CallNonEffectiveDatedRequest_Catch_120" routes-to="CallCustomObjectAPI_120" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CallService_Error_120"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Request_120" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_Debug_URL_120" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="props['inCustomObjectServiceAlias'] # '__Request.json'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_BuildRequestFromXmlAndXsd_120" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Generate JSON From XSD Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while generating JSON from XML and XSD.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_120'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsdFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsdFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsdFile'], '/') :&#xD;&#xA;&#x9;props['inPathToXsdFile']"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:async-mediation id="BuildRequestFromXmlAndXsd_120" execute-steps-when="props['inPathToXsdFile'] != empty">
            <cc:steps>
                <cc:xml-to-json id="XmlToJson" output-mimetype="application/json" schema-url="@{props['inPathToXsdFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_BuildRequestFromXmlAndXsd_120"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_BuildRequestFromXmlAndXslt_120" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Generate JSON From XSLT Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while generating JSON from XML and XSLT.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_120'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inPathToXsltFile']"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:async-mediation id="BuildRequestFromXmlAndXslt_120" routes-to="LogXsltMessages_120" execute-steps-when="props['inPathToXsltFile'] != empty">
            <cc:steps>
                <cc:xslt-plus id="CountRecords" output="variable" output-mimetype="text/xml" output-variable="localCountResult120" url="xslt/ssk120/SSK120_CountRecords.xsl"/>
                <cc:eval id="SetValue">
                    <cc:expression>props['localRecordCount'] = vars['localCountResult120'].xstream('/totalRecords'); </cc:expression>
                </cc:eval>
                <cc:xslt-plus id="XsltPlus" output-mimetype="application/json" messages-property="localXsltMessages120" url="@{props['inPathToXsltFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_BuildRequestFromXmlAndXslt_120"/>
        </cc:async-mediation>
        <cc:splitter id="BatchSplitter_120">
            <cc:sub-route name="ProcessBatch" routes-to="Call_TransformXML_Batch_120"/>
            <cc:xml-stream-splitter xpath="/Blocks/*"/>
        </cc:splitter>
        <cc:local-out id="Call_HandleError_BuildBlockMessage_Error_120" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'XSLT3 Block Splitter Error'"/>
            <cc:set name="inLogMessageDetail" value="'The XML data was unable to be split using the XSLT Block Splitter'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'XsltBlockSplitter-SplitXml.xml'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_120'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:async-mediation id="BuildBlockMessage_120" routes-to="BatchSplitter_120" handle-downstream-errors="true">
            <cc:steps>
                <cc:xslt-plus id="SplitXML" url="xslt/ssk120/SSK120_XsltBlockSplit.xsl"/>
                <cc:eval id="UpdateURL">
                    <cc:expression>if (org.apache.commons.lang3.StringUtils.contains(props.localRestUrl, '?')) {&#xD;
	props['localRestUrl'] = props['localRestUrl'] # '&amp;bulk=true';&#xD;
} else {&#xD;
	props['localRestUrl'] = props['localRestUrl'] # '?bulk=true';&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_BuildBlockMessage_Error_120"/>
        </cc:async-mediation>
        <cc:route id="RouteBatch_120">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['localIsUseBatch']" route="Batch"/>
                <cc:choose-route expression="true" route="Single"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Batch" routes-to="BuildBlockMessage_120"/>
            <cc:sub-route name="Single" routes-to="Call_TransformXML_Single_120"/>
        </cc:route>
        <cc:route id="RouteSource_120">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['localIsDataJson']" route="JSON"/>
                <cc:choose-route expression="true" route="XML"/>
            </cc:mvel-strategy>
            <cc:sub-route name="JSON" routes-to="Call_ProcessJSON_120"/>
            <cc:sub-route name="XML" routes-to="Call_ProcessXML_120"/>
        </cc:route>
        <cc:async-mediation id="PrepareData_120" routes-to="RouteSource_120" execute-steps-when="props['inParameterDataLocation'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>message.setMessage(vars[props.inParameterDataLocation].source, vars[props.inParameterDataLocation].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_120" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Custom Object Preparation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a Custom Object call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_120'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
        <cc:set name="inTargetType" value="'properties'"/><cc:set name="inTargetName" value="'int0025DebugPropertyList'"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_120" routes-to="PrepareData_120" continue-after-error="rewind" handle-downstream-errors="true" routes-response-to="Call_Finally_120">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localIsUseBatch'] = false;</cc:expression>
                    <cc:expression>props['localIsDataJson'] = ((props['inParameterDataLocation'] == 'message') &amp;&amp; (parts[0].getMimeType().toLowerCase().startsWith('application/json'))) || (context.variables.isVariable(props.inParameterDataLocation) &amp;&amp; (vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('application/json')));</cc:expression>
                </cc:eval>
                <cc:eval id="BuildURL">
                    <cc:expression>props['localRestUrl'] = intsys.customObjectService.getExtrapath(props.inCustomObjectServiceAlias);</cc:expression>
                    <cc:expression>if (props['inHttpMethod'] == 'POST' &amp;&amp; props['inUpdateIfExists']) {&#xD;
	props['localRestUrl'] = props['localRestUrl'] # '?updateIfExists=true';&#xD;
}</cc:expression>
                </cc:eval>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_120"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_120" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_120"><cc:set name="inIsInvokedByHandleError" value="false"/></cc:local-out>
        <cc:local-in id="WriteNonEffectiveDatedCustomObject" routes-to="InitializeAndFinalize_120" access="public" icon="icons/WriteNonEffectiveDatedCustomObject.png">
            <cc:parameter documentation="The Custom Object Service configuration representing the non-effective dated custom object to update.  If passed, this will be a non-effective dated custom object that will be updated via a REST POST" name="inCustomObjectServiceAlias" required="true" type="string"/>
            <cc:parameter default="'POST'" documentation="This parameter allows you to control the behavior of the component with respect to the object's data.  One of 2 methods are supported:  PUT or POST.  Using &quot;PUT&quot; will result in an update to an existing Custom Object of only the fields you provide.  Using &quot;POST&quot; will create a new instance of the Custom Object.  If you also set inUpdateIfExists to &quot;true&quot;, then the API will update the instance if it already exists.  In this case for updates though, there is no partial update - you must provide all fields as any omitted field will be nullified.  DELETE operations are not supported by this component." name="inHttpMethod" required="true" type="string" validation="['PUT','POST'] contains props['inHttpMethod'].trim().toUpperCase()"/><cc:parameter default="false" documentation="Setting for updateIfExists parameter for Non-Effective Dated Custom Objects when using the HTTP &quot;POST&quot; method.  Note this is only implicitly effective for single-instance objects.  For multi-instance objects, a new instance will be created unless the specific instance id of the custom object record is also included in the json body data." name="inUpdateIfExists" required="false" type="boolean" validation="if (props['inHttpMethod'] != 'POST') {&#xD;&#xA;&#x9;props['inUpdateIfExists'] == empty&#xD;&#xA;}"/>
            <cc:parameter documentation="Where the data for the Non-Effective Dated Custom Object request can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inParameterDataLocation" required="true" type="string" validation="(props['inParameterDataLocation'] == 'message' &amp;&amp;&#xD;&#xA;&#x9;(parts[0].getMimeType().toLowerCase().startsWith('application/json') ||&#xD;&#xA;&#x9;(parts[0].isXml() &amp;&amp; parts[0].getMimeType().toLowerCase().startsWith('text/xml')))) || &#xD;&#xA;(context.variables.isVariable(props.inParameterDataLocation) &amp;&amp;&#xD;&#xA;&#x9;(vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('application/json') ||&#xD;&#xA;&#x9;(vars[props.inParameterDataLocation].isXml() &amp;&amp; vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('text/xml'))))"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the JSON request, e.g. &quot;xslt/GenerateJson.xslt&quot;." name="inPathToXsltFile" required="props['inPathToXsdFile'] == empty &amp;&amp; &#xD;&#xA;&#x9;((props['inParameterDataLocation'] == 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;parts[0].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;parts[0].getMimeType().toLowerCase().startsWith('text/xml')) || &#xD;&#xA;&#x9;(props['inParameterDataLocation'] != 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('text/xml')))" type="string" validation="props['inPathToXsltFile'] == empty ||&#xD;&#xA;&#x9;(props['inPathToXsdFile'] == empty &amp;&amp;&#xD;&#xA;&#x9;((props['inParameterDataLocation'] == 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;parts[0].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;parts[0].getMimeType().toLowerCase().startsWith('text/xml')) || &#xD;&#xA;&#x9;(props['inParameterDataLocation'] != 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('text/xml'))))"/>
            <cc:parameter documentation="The file path relative to /ws/WSAR-INF for the XSD file that will generate the JSON request, e.g. &quot;xslt/GenerateJson.xsd&quot;." name="inPathToXsdFile" required="props['inPathToXsltFile'] == empty &amp;&amp; &#xD;&#xA;&#x9;((props['inParameterDataLocation'] == 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;parts[0].isXml() &amp;&amp; &#xD;&#xA;&#x9;&#x9;parts[0].getMimeType().toLowerCase().startsWith('text/xml')) || &#xD;&#xA;&#x9;(props['inParameterDataLocation'] != 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('text/xml')))" type="string" validation="props['inPathToXsdFile'] == empty ||&#xD;&#xA;&#x9;(props['inPathToXsltFile'] == empty &amp;&amp;&#xD;&#xA;&#x9;((props['inParameterDataLocation'] == 'message' &amp;&amp;&#xD;&#xA;&#x9;&#x9;parts[0].isXml() &amp;&amp; &#xD;&#xA;&#x9;&#x9;parts[0].getMimeType().toLowerCase().startsWith('text/xml')) || &#xD;&#xA;&#x9;(props['inParameterDataLocation'] != 'message' &amp;&amp; &#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].isXml() &amp;&amp;&#xD;&#xA;&#x9;&#x9;vars[props.inParameterDataLocation].mimeType.toLowerCase().startsWith('text/xml'))))"/>
            <cc:parameter default="'message'" documentation="Where the results of the custom object response are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the Custom Object Service request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="false" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/><cc:parameter default="context.containsProperty('outCloudLogFieldOverrideMap145') ? props['outCloudLogFieldOverrideMap145'] : null" documentation="This parameter provides the opportunity to specify a Java HashMap from a context property to replace the error values being reported internally by the component.  The map is keyed by the attribute name of the SSK141 HandleError input parameter, and the value is a string to be used in place of the SSK120 default.  If the map is not provided, or if a map is given but does not contain a key for the logged parameter, then the SSK120 default behavior applies.  If only a single value is desired to be changed from the out-of-the-box behavior, then a map with a single entry could be provided.  In some cases, the logged value is not available to be override, e.g. inLocalIn or inLogLevel when there are hard errors." name="inErrorLogOverrideMap" required="false"/>
        </cc:local-in>
        <cc:local-in id="ProcessXML_120" routes-to="InitializeXml_120"/>
        <cc:local-in id="ProcessJSON_120" routes-to="Call_Debug_Request_120"/>
        <cc:local-out id="Call_ProcessJSON_120" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessJSON_120"/>
        <cc:local-out id="Call_ProcessXML_120" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessXML_120"/>
        <cc:local-out id="Call_ProcessJSON_Batch_120" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessJSON_120"/>
        <cc:local-in id="TransformXML_120" routes-to="BuildRequestFromXmlAndXslt_120"/>
        <cc:async-mediation id="InitializeXml_120" routes-to="RouteBatch_120">
            <cc:steps>
                <cc:xslt-plus id="CountRecords" output="variable" output-mimetype="text/xml" output-variable="localCountResult120" url="xslt/ssk120/SSK120_CountRecords.xsl"/>
                <cc:eval id="SetValue">
                    <cc:expression>props['localRecordCount'] = vars['localCountResult120'].xstream('/totalRecords'); &#xD;
props['localIsUseBatch'] = props['localRecordCount'] > 1;</cc:expression>
                    <cc:expression>if (props['localIsUseBatch']) {&#xD;
	props['localBlockSize'] = (props.containsKey('atf.aunit.test') &amp;&amp; props['atf.aunit.test']) ? 2 : 100;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_TransformXML_Single_120" store-message="none" routes-response-to="Call_ProcessJSON_Single_120" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/TransformXML_120"/>
        <cc:local-out id="Call_TransformXML_Batch_120" store-message="none" routes-response-to="Call_ProcessJSON_Batch_120" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/TransformXML_120"/>
        <cc:local-out id="Call_ProcessJSON_Single_120" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ProcessJSON_120"/>
        <cc:local-out id="Call_Debug_URL_120" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallNonEffectiveDatedRequest_Catch_120" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localRestUrl'"/>
            
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_PIE_108" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"><cc:set name="inLogMessage" value="'Progress Update Error'"/><cc:set name="inLogMessageDetail" value="'An error occurred while attempting to update the integration event progress.  Since this is not a critical action, processing of the integration will continue.  Potential error reponse data on the message will be output to the debug log file.'"/><cc:set name="inLogLevel" value="'warn'"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/><cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inIsAbortOnError" value="false"/><cc:set name="inIsResetError" value="false"/><cc:set name="inIncludeDebugOutput" value="true"/><cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'EventProgress__Error'"/><cc:set name="inLogTarget" value="'primary'"/></cc:local-out>
        <cc:async-mediation id="ErrorTrap_108" routes-to="PIM_108" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_PIE_108"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_ResultOutput_Error_102" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Storage Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while storing data to the Integration Event.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="ThreadedResultOutput_102" execute-steps-when="props['inSaveResultsToIntegrationEvent']">
            <cc:steps>
                <cc:zip id="Zip" format="zip"/>
                <cc:store id="StoreContent" output="variable" output-mimetype="text/xml" output-variable="localStoreResult_102" input="message" createDocumentReference="true" expiresIn="@{props['inDocumentRetentionPeriod']}" title="@{'RAAS-Results__' # props['inReportServiceAlias'] # (props['inIsChildThreadContext'] ? java.lang.Thread.currentThread().getName() : '')}.zip"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ResultOutput_Error_102"/>
        </cc:async-mediation>
        <cc:route id="Threading_141">
            <cc:mvel-strategy>
                <cc:choose-route expression="!props['inIsChildThreadContext']" route="MainThread"/>
                <cc:choose-route expression="true" route="ChildThread"/>
            </cc:mvel-strategy>
            <cc:sub-route name="MainThread" routes-to="Call_CreateLogEntry_141"/>
            <cc:sub-route name="ChildThread" routes-to="Call_CreateLogEntryOnThread_141"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntryOnThread_141" store-message="none" routes-response-to="Call_Debug_Child_141" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread"><cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;props['inLogMessage']"/><cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;props['inLogMessageDetail']"/><cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;props['inLogReferenceId']"/><cc:set name="inLogLevel" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogLevel')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogLevel')) :&#xD;&#xA;&#x9;&#x9;props['inLogLevel']"/><cc:set name="inExtraLocalIn" value="props['inExtraLocalIn']"/><cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;props['inExtraRecordNumber']"/><cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;props['inExtraSupportData']"/><cc:set name="inExtraErrorCode" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraErrorCode')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraErrorCode')) : &#xD;&#xA;&#x9;&#x9;props['inExtraErrorCode']"/></cc:local-out>
        <cc:local-out id="Call_LogXsltMessages_107" store-message="none" execute-when="props['localMessages107'] != empty" routes-response-to="Call_Debug_MergeResult_107" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CloudLogXSLTMessages"><cc:set name="inMessages" value="props['localMessages107']"/><cc:set name="inIsClearMessages" value="true"/><cc:set name="inMinLogLevel" value="'debug'"/><cc:set name="inLogTarget" value="props['inLogTargetForXsltMessages']"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_CreateThreadLogEntry_Info_102" store-message="none" execute-when="props['inIsChildThreadContext'] &amp;&amp; !props['inIsForceUseSoap']" routes-response-to="ComposeRequest_102" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread"><cc:set name="inLogMessage" value="'Executing reports-as-a-service for the '# props['inReportServiceAlias'] #' report alias using SOAP.'"/><cc:set name="inLogMessageDetail" value="'The URL constructed including querystring parameters exceed the maximum URL length for RESTful RaaS calls of 16000 Bytes.  Switching to use SOAP as protocol.'"/><cc:set name="inLogLevel" value="'info'"/></cc:local-out>
        <cc:async-mediation id="Teardown_128">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localPollURI','localIsContinueLoop','localMessageId','localMessageURI','localMessageTimestamp']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_128" routes-to="Teardown_128"/>
        <cc:local-out id="Call_CreateLogEntry_MessageDelete_LogInfo_128" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message Deleted'"/>
            <cc:set name="inLogMessageDetail" value="'The read message was deleted from the queue.  See the Reference ID for the message filename in the debug archive.'"/>
            <cc:set name="inLogReferenceId" value="props['outEntityName']"/>
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'CallQueue_Delete_128'"/>
            <cc:set name="inExtraRecordNumber" value="props['localMessageId']"/>
            <cc:set name="inExtraSupportData" value="'Message Index = ' # props['localMessageId'] # ';  Message Enqueued On = ' # props['localMessageTimestamp'] # ';  Message URI = ' # props['localMessageURI']"/>
            
        </cc:local-out>
        <cc:local-out id="Call_Debug_REST_DeleteResponse_128" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_CreateLogEntry_MessageDelete_LogInfo_128" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueueDelete_' # props['localMessageId'] # '.xml'"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_Delete_128" store-message="none" routes-response-to="Call_Debug_REST_DeleteResponse_128" endpoint="@{props['localMessageURI']}" http-method="DELETE">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_HandleError_CatchDequeueErrors_128" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Delete Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while deleting the next message from the Message Queue.  Processing will attempt to continue, but full deletion of all queue messages cannot be guaranteed.  An additional Administrator event may be required after the cause of this error has been resolved.'"/>
            <cc:set name="inLogReferenceId" value="props['localMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_128'"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="true"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localMessageURI'"/>
        </cc:local-out>
        <cc:async-mediation id="CatchDequeueErrors_128" routes-to="CallQueue_Delete_128" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CatchDequeueErrors_128"/>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_MessageRead_LogInfo_128" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message Retrieved'"/>
            <cc:set name="inLogMessageDetail" value="'A message was read from the queue.  The contents of the message were saved to the debug archive for future reference/audit.  See the Reference ID for the message filename in that archive.'"/>
            <cc:set name="inLogReferenceId" value="props['outEntityName']"/>
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_MessageRead_LogInfo_128'"/>
            <cc:set name="inExtraRecordNumber" value="props['localMessageId']"/>
            <cc:set name="inExtraSupportData" value="'Message Index = ' # props['localMessageId'] # ';  Message Enqueued On = ' # props['localMessageTimestamp'] # ';  Message URI = ' # props['localMessageURI']"/>
            
        </cc:local-out>
        <cc:local-out id="Call_Debug_REST_ReadResponse_128" store-message="none" routes-response-to="Call_CreateLogEntry_MessageRead_LogInfo_128" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="(com.workday.custom.int0025.SSKUtils.cleanFilename(props['inMessageURI'], '_')) # (com.workday.custom.int0025.SSKUtils.getFileExtenstionFromMimetype(message.getMimeType(0)))"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_Read_128" store-message="none" routes-response-to="Call_Debug_REST_ReadResponse_128" endpoint="@{props['localMessageURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Read_128" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueue_Read_128" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localMessageURI'"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_CatchReadErrors_128" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Read Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while reading the next message from the Message Queue.  Processing will attempt to continue, but full deletion of all queue messages cannot be guaranteed.  An additional Administrator event may be required after the cause of this error has been resolved.'"/>
            <cc:set name="inLogReferenceId" value="props['localMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_128'"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="true"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:async-mediation id="CatchReadErrors_128" routes-to="Call_Debug_REST_Read_128" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CatchReadErrors_128"/>
        </cc:async-mediation>
        <cc:local-in id="LogMessage_128" routes-to="CatchReadErrors_128">
            
            
            
        </cc:local-in>
        <cc:local-out id="Call_LogMessage_128" store-message="none" execute-when="props['inIsLogMessageBeforeDelete']" routes-response-to="Call_DeleteMessage_128" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/LogMessage_128">
            
            
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_CatchLocalOutErrors_128" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Processing Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while parsing the poll result to begin removal of the associated message.  Without message information, this message cannot be removed, and complete deletion of all messages from the queue cannot be guaranteed.  See Support Data for more information.'"/>
            <cc:set name="inLogReferenceId" value="props['inMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_128'"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="true"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:async-mediation id="CatchLocalOutErrors_128" routes-to="Call_LogMessage_128" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localMessageId'] = parts[0].xpath('/*:message/*:index');&#xD;
props['localMessageURI'] = props['inEndpoint'] # (parts[0].xpath('/*:message/*:uri'));&#xD;
props['localMessageTimestamp'] = parts[0].xpath('/*:message/*:uploaded');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CatchLocalOutErrors_128"/>
        </cc:async-mediation>
        <cc:splitter id="SplitMessages_128" no-split-message-error="false">
            <cc:sub-route name="ProcessMessage" routes-to="CatchLocalOutErrors_128"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:local-out id="Call_Debug_REST_PollResponse_128" store-message="none" execute-when="props['inDebugMode']" routes-response-to="EvaluateQueue_128" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueuePoll.xml'"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_128" store-message="none" routes-response-to="Call_Debug_REST_PollResponse_128" endpoint="@{props['localPollURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Poll_128" store-message="none" execute-when="props['inDebugMode']" routes-response-to="AllMessages_128" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localPollURI'"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_128" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Delete Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while deleting the next message from the Message Queue.'"/>
            <cc:set name="inLogReferenceId" value="props['inMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_128'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_128" routes-to="Call_Debug_REST_Poll_128" routes-response-to="Call_Finally_128">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localPollURI'] = props['inEndpoint'] # '/ccx/wd-queue/' # props['inQueueName'] # '/fresh?maxMessages=999'</cc:expression>
                    <cc:expression>props['localIsContinueLoop'] = true;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_128"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_128" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_128"/>
        <cc:local-in id="PurgeQueue" routes-to="InitializeAndFinalize_128" icon="icons/PurgeQueue.png">
            <cc:parameter default="props['int0025QueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['int0025QueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the REST request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/><cc:parameter default="false" documentation="If true, then the message content will be written out to the debug log prior to deletion.  Otherwise, the message will simply be dequeued." name="inIsLogMessageBeforeDelete" required="true" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_127">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_127" routes-to="Teardown_127"/>
        <cc:local-out id="Call_CreateLogEntry_MessageDelete_127" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message Deleted'"/>
            <cc:set name="inLogMessageDetail" value="'The message was deleted from the queue.  See the Reference ID for the message filename in the debug archive.'"/>
            <cc:set name="inLogReferenceId" value="props['outEntityName']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_MessageDelete_127'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_REST_DeleteResponse_127" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_CreateLogEntry_MessageDelete_127" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueueDelete.xml'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:http-out id="CallQueueDelete_127" store-message="none" routes-response-to="Call_Debug_REST_DeleteResponse_127" endpoint="@{props['localURI']}" http-method="DELETE">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Delete_127" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueueDelete_127" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_127" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Delete Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while deleting the next message from the Message Queue.'"/>
            <cc:set name="inLogReferenceId" value="props['inMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_127'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_127" routes-to="Call_Debug_REST_Delete_127" handle-downstream-errors="true" routes-response-to="Call_Finally_127">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # props['inMessageURI']</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_127"/>
        </cc:sync-mediation>
        <cc:local-in id="DeleteMessageFromQueue" routes-to="InitializeAndFinalize_127" icon="icons/DeleteMessageFromQueue.png">
            <cc:parameter default="props['int0025QueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['int0025QueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['outMessageURI']" name="inMessageURI" required="true" type="string"/>
            
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the REST request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="'message'" documentation="How the REST response is returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_126">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI','localIsPreserveMessage']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['localMessageCache126']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval id="ReduceDebug">
                    <cc:expression>if (context.containsProperty('int0025DebugPropertyList')) {&#xD;
	props['int0025DebugPropertyList'].remove('inEndpoint');&#xD;
	props['int0025DebugPropertyList'].remove('inQueueName');&#xD;
	props['int0025DebugPropertyList'].remove('inUsername');&#xD;
	props['int0025DebugPropertyList'].remove('inPassword');&#xD;
	props['int0025DebugPropertyList'].remove('inValidateOnly');&#xD;
	props['int0025DebugPropertyList'].remove('inDebugMode');&#xD;
	props['int0025DebugPropertyList'].remove('inIsAbortOnError');&#xD;
	props['int0025DebugPropertyList'].remove('inDataSource');&#xD;
	props['int0025DebugPropertyList'].remove('inXsltSplitDataToMessages');&#xD;
	props['int0025DebugPropertyList'].remove('inNamespaceSplitDataToMessages');&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="RestoreMessage_126" routes-to="Teardown_126" execute-steps-when="props['localIsPreserveMessage'] &amp;&amp; vars['localMessageCache126'] != null">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" output="message" input="variable" input-variable="localMessageCache126"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_126" routes-to="RestoreMessage_126"/>
        <cc:local-out id="Call_Debug_REST_EnqueueResponse_126" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueuePost.xml'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:http-out id="CallQueue_126" store-message="none" routes-response-to="Call_Debug_REST_EnqueueResponse_126" endpoint="@{props['localURI']}" http-method="POST">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Enqueue_126" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueue_126" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_EnqueueMessage_126" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An error occurred enqueuing a batch request.  Normal execution will attempt to continue...'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber"/>
            <cc:set name="inExtraSupportData"/>
            <cc:set name="inExtraErrorCode" value="'104'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_126'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'rootpart__queueMessageContent.' # (com.workday.custom.int0025.SSKUtils.getFileExtenstionFromMimetype(message.getMimeType(0)))"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="EnqueueMessage_Catch_126" routes-to="Call_Debug_REST_Enqueue_126" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_EnqueueMessage_126"/>
        </cc:async-mediation>
        <cc:splitter id="SplitMessages_126" no-split-message-error="false">
            <cc:sub-route name="ProcessBatch" routes-to="EnqueueMessage_Catch_126"/>
            <cc:xml-stream-splitter namespaces="@{props['inNamespaceSplitDataToMessages']}" xpath="@{props['inXsltSplitDataToMessages']}"/>
        </cc:splitter>
        <cc:route id="Route_126">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inXsltSplitDataToMessages'] != empty" route="MultipleMessages"/>
                <cc:choose-route expression="true" route="SingleMessage"/>
            </cc:mvel-strategy>
            <cc:sub-route name="MultipleMessages" routes-to="SplitMessages_126"/>
            <cc:sub-route name="SingleMessage" routes-to="EnqueueMessage_Catch_126"/>
        </cc:route>
        <cc:local-out id="Call_HandleError_PrepareData_126" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An error occurred caching message.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_126'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'MessageRoot__to_localMessageCache126.' # (com.workday.custom.int0025.SSKUtils.getFileExtenstionFromMimetype(message.getMimeType(0)))"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="PrepareData_126" routes-to="Route_126" execute-steps-when="props['localIsPreserveMessage']">
            <cc:steps>
                <cc:copy id="CopyMsgToVar" output="variable" output-variable="localMessageCache126"/>
                <cc:eval id="CopyVarToMsg">
                    <cc:expression>if (props['inDataSource'] != 'message') {&#xD;
	message.setMessage(vars[props.inDataSource].source, vars[props.inDataSource].mimeType);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="Call_HandleError_PrepareData_126"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_126" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An error occurred preparing message to be enqueued.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_126'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'properties'"/>
            <cc:set name="inTargetName" value="'globalDebugPropertyList'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_126" routes-to="PrepareData_126" routes-response-to="Call_Finally_126">
            <cc:request-steps>
                <cc:eval id="UpdateDebug">
                    <cc:expression>if (context.containsProperty('int0025DebugPropertyList')) {&#xD;
	props['int0025DebugPropertyList'].add('inEndpoint');&#xD;
	props['int0025DebugPropertyList'].add('inQueueName');&#xD;
	props['int0025DebugPropertyList'].add('inUsername');&#xD;
	props['int0025DebugPropertyList'].add('inValidateOnly');&#xD;
	props['int0025DebugPropertyList'].add('inDebugMode');&#xD;
	props['int0025DebugPropertyList'].add('inIsAbortOnError');&#xD;
	props['int0025DebugPropertyList'].add('inDataSource');&#xD;
	props['int0025DebugPropertyList'].add('inXsltSplitDataToMessages');&#xD;
	props['int0025DebugPropertyList'].add('inNamespaceSplitDataToMessages');&#xD;
}</cc:expression>
                </cc:eval>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="InitValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # '/ccx/wd-queue/' # props['inQueueName'];</cc:expression>
                    <cc:expression>props['localIsPreserveMessage'] = props['inDataSource'] != 'message';</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_126"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_126" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_126"/>
        <cc:local-in id="AddMessageToQueue" routes-to="InitializeAndFinalize_126" icon="icons/AddMessageToQueue.png">
            <cc:parameter default="props['int0025QueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['int0025QueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the REST request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="'message'" documentation="Where the data to be written to the queue is stored.  If this is 'message', then the message root part will be used (which is default), and otherwise, it is interpreted as the name of a variable." name="inDataSource" required="true" type="string"/>
            <cc:parameter documentation="An XPath expression used against the data provided to sub-divide the set to individual messages." name="inXsltSplitDataToMessages" required="false" type="string"/>
            <cc:parameter default="'xsd http://www.w3.org/2001/XMLSchema'" documentation="The namespace alias and fully qualified definition for any undefined namespaces in the XPath used for splitting the data.  The default value will satisfy requirements if the XML is in the default namespace." name="inNamespaceSplitDataToMessages" required="props['inXsltSplitDataToMessages'] != empty" type="string"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
            
        </cc:local-in>
        <cc:async-mediation id="Teardown_125">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_125" routes-to="Teardown_125"/>
        <cc:local-out id="Call_CreateLogEntry_MessageDelete_125" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message Deleted'"/>
            <cc:set name="inLogMessageDetail" value="'The read message was deleted from the queue.  See the Reference ID for the message filename in the debug archive.'"/>
            <cc:set name="inLogReferenceId" value="props['outEntityName']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_MessageDelete_125'"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_REST_DeleteResponse_125" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_CreateLogEntry_MessageDelete_125" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__CallQueueDelete_125.xml'"/>
        </cc:local-out>
        <cc:http-out id="CallQueueDelete_125" store-message="none" routes-response-to="Call_Debug_REST_DeleteResponse_125" endpoint="@{props['localURI']}" http-method="DELETE">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_HandleError_DequeueInit_125" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Delete Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while deleting the next message from the Message Queue.'"/>
            <cc:set name="inLogReferenceId" value="props['inMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_125'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:async-mediation id="DequeueInit_125" routes-to="CallQueueDelete_125" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DequeueInit_125"/>
        </cc:async-mediation>
        <cc:local-in id="Dequeue_125" routes-to="DequeueInit_125"/>
        <cc:local-out id="Call_Dequeue_125" store-message="none" execute-when="props['inIsDeleteAfterRead']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Dequeue_125" clone-request="true"/>
        <cc:async-mediation id="ReadMessage_125" routes-to="Call_Dequeue_125" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_MessageRead_125" store-message="none" execute-when="props['inDebugMode']" routes-response-to="ReadMessage_125" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="'Message Retrieved'"/>
            <cc:set name="inLogMessageDetail" value="'A message was read from the queue.  The contents of the message were saved to the debug archive for future reference/audit.  See the Reference ID for the message filename in that archive.'"/>
            <cc:set name="inLogReferenceId" value="props['outEntityName']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_MessageRead_125'"/>
            <cc:set name="inExtraSupportData" value="'Message Index = ' # props['inMessageId'] # ';  Message URI = ' # props['inMessageURI']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_REST_ReadResponse_125" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_CreateLogEntry_MessageRead_125" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="(com.workday.custom.int0025.SSKUtils.cleanFilename(props['inMessageURI'], '_')) # (com.workday.custom.int0025.SSKUtils.getFileExtenstionFromMimetype(message.getMimeType(0)))"/>
        </cc:local-out>
        <cc:http-out id="CallQueueRead_125" store-message="none" routes-response-to="Call_Debug_REST_ReadResponse_125" endpoint="@{props['localURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Read_125" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueueRead_125" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_125" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Read Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while reading the next message from the Message Queue.  The message has not been deleted from the queue.'"/>
            <cc:set name="inLogReferenceId" value="props['inMessageURI']"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_125'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'ReadMessageFromQueue_ErrorResponse.xml'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_125" routes-to="Call_Debug_REST_Read_125" handle-downstream-errors="true" routes-response-to="Call_Finally_125">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # props['inMessageURI']</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_125"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_125" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_125"/>
        <cc:local-in id="ReadMessageFromQueue" routes-to="InitializeAndFinalize_125" icon="icons/ReadMessageFromQueue.png">
            <cc:parameter default="props['int0025QueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['int0025QueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['outMessageId']" name="inMessageId" required="true" type="string"/>
            <cc:parameter default="props['outMessageURI']" name="inMessageURI" required="true" type="string"/>
            
            <cc:parameter default="true" documentation="A boolean flag to indicate if the message should be removed from the queue after being read." name="inIsDeleteAfterRead" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the REST request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="'message'" documentation="How the REST response is returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found.  " name="inReturnResults" required="true" type="string"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_124">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_124" routes-to="Teardown_124"/>
        <cc:async-mediation id="QueueResults_124">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>if (parts[0].xpathB('/*:messages/*:message')) {&#xD;
	props['outMessageId'] = parts[0].xpath('/*:messages/*:message[1]/*:index');&#xD;
	props['outMessageURI'] = parts[0].xpath('/*:messages/*:message[1]/*:uri');&#xD;
} else {&#xD;
	props['outMessageId'] = '';&#xD;
	props['outMessageURI'] = '';&#xD;
}</cc:expression>
                </cc:eval>
                <cc:eval execute-when="props.inReturnResults != empty &amp;&amp; props.inReturnResults != 'message'" id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_REST_PollResponse_124" store-message="none" execute-when="props['inDebugMode']" routes-response-to="QueueResults_124" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueuePoll.xml'"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_124" store-message="none" routes-response-to="Call_Debug_REST_PollResponse_124" endpoint="@{props['localURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_Poll_124" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueue_124" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inPollURI'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_124" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Query Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while querying the Message Queue for statistics.  Without queue information, the integration processing cannot safely continue and will be terminated.  See Support Data for more information.'"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_124'"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['globalIsDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'PollQueue_ErrorResponse.xml'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_124" routes-to="Call_Debug_REST_Poll_124" handle-downstream-errors="true" routes-response-to="Call_Finally_124">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # props['inPollURI'];&#xD;
if (props['inBatchSize'] != empty) {&#xD;
	props['localURI'] = props['localURI'] # '?maxMessages=' # props['inBatchSize'];&#xD;
}</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_124"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_124" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_124"/>
        <cc:local-in id="PollQueue" routes-to="InitializeAndFinalize_124" icon="icons/PollQueue.png">
            <cc:parameter default="props['int0025QueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['outPollURI']" documentation="The polling URI for the queue.  Parameter is defaulted to the output parameter from GetQueues." name="inPollURI" required="true" type="string"/>
            <cc:parameter documentation="Determines the number of messages that will be returned if there are more messages in the queue than the default batch size of 100.  If not defined, then the default behavior is applied and up to the default number of messages is returned." name="inBatchSize" required="false" type="string"/><cc:parameter default="props['int0025QueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['int0025QueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="'message'" documentation="How the queue poll results are returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found.  " name="inReturnResults" required="false" type="string"/><cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:out-parameter documentation="The REST resource id of the next message on the queue to be fetched." name="outMessageId"/>
            <cc:out-parameter documentation="The REST URI of the message to facilitate reading" name="outMessageURI"/>
        </cc:local-in>
        <cc:async-mediation id="Teardown_123">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_123" routes-to="Teardown_123"/>
        <cc:local-out id="Call_HandleError_QueueResults_123" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Result Error'"/>
            <cc:set name="inLogMessageDetail" value="props['inQueueName'] # ' was not found executing endpoint ' # props['inEndpoint'] # '/ccx/wd-queue/'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_123'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="QueueResults_123">
            <cc:steps>
                <cc:validate-xpath id="ValidateXpath" xpath="/*:queues/*:queue[*:name = &quot;@{props['inQueueName']}&quot;]"/>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outPollURI'] = parts[0].xpath('/*:queues/*:queue[*:name = &quot;'# props['inQueueName'] #'&quot;]/*:poll-uri');&#xD;
props['outMessageCount'] = parts[0].xpath('/*:queues/*:queue[*:name = &quot;'# props['inQueueName'] #'&quot;]/*:message-count');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_QueueResults_123"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_REST_QueueStatusResponse_123" store-message="none" execute-when="props['inDebugMode']" routes-response-to="QueueResults_123" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueueStatistics.xml'"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_123" store-message="none" routes-response-to="Call_Debug_REST_QueueStatusResponse_123" endpoint="@{props['localURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_QueueStatusRequest_123" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueue_123" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_123" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Query Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while querying the Message Queue for statistics.  See Support Data for more information.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_123'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'GetQueues_ErrorResponse.xml'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_123" routes-to="Call_Debug_REST_QueueStatusRequest_123" handle-downstream-errors="true" routes-response-to="Call_Finally_123">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # '/ccx/wd-queue/'</cc:expression>
                    <cc:expression>props['outPollURI'] = '';&#xD;
props['outMessageCount'] = 0;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_123"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_123" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_123"/>
        <cc:local-in id="GetQueues" routes-to="InitializeAndFinalize_123" icon="icons/GetQueues.png">
            <cc:parameter default="props['int0025QueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['int0025QueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the REST request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:out-parameter documentation="The relative Uniform Resource Identifier of the queue" name="outPollURI"/>
            <cc:out-parameter documentation="The number of messages currently on the queue for processing." name="outMessageCount"/>
        </cc:local-in>
        <cc:local-out id="Call_Debug_BlockSplitResults_116" store-message="none" execute-when="props['inDebugMode']" routes-response-to="ValidateBlockSplitResults_116" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug" clone-request="true">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'SSK116_BlockSplitResults.xml'"/>
        </cc:local-out>
        <cc:local-out id="Call_ParallelSubroutine_116" store-message="none" endpoint="vm://wcc/ParallelSubroutine">
            <cc:set name="parallel.processing.aggregation.endpoint" value="props['inAggregationEndpoint']"/>
            <cc:set name="parallel.processing.worker.endpoint" value="props['inProcessEndpoint']"/>
            <cc:set name="parallel.processing.worker.count" value="props['inParallelThreadCount']"/>
            <cc:set name="parallel.processing.worker.timeout" value="props['inParallelThreadTimeout']"/>
            <cc:set name="parallel.processing.timeout" value="props['inParallelSplitterTimeout']"/>
            <cc:set name="parallel.processing.splitter" value="spring.getBean('SSK116BlockSplitter')"/>
        </cc:local-out>
        <cc:route id="RouteSplit_116">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsUseParallel'] &amp;&amp; props['localIsBlocks']" route="Parallel"/>
                <cc:choose-route expression="true" route="Serial"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Parallel" routes-to="Call_InitializeThreadedLogging_116"/>
            <cc:sub-route name="Serial" routes-to="StoreOutput_116"/>
        </cc:route>
        <cc:route id="RouteParallelism_115">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsUseOrderedAggregation']" route="Serial"/>
                <cc:choose-route expression="true" route="Parallel"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Parallel" routes-to="PrepareFileResults_Parallel_115"/>
            <cc:sub-route name="Serial" routes-to="PrepareFileResults_Serial_115"/>
        </cc:route>
        <cc:async-mediation id="PrepareFileResults_Serial_115" routes-to="RouteFileCount_Serial_115">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localLabels'] = 'Data - Partial' # (props['inRetrievalDocTag'] == empty ? '' : ', ' # props['inRetrievalDocTag'])</cc:expression>
                    <cc:expression>props['localFileCount'] = da.size(org.apache.commons.lang3.StringUtils.split(props.localLabels, ','));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteFileCount_Serial_115">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['localFileCount'] &lt; 1" route="NoFiles"/>
                <cc:choose-route expression="true" route="Files"/>
            </cc:mvel-strategy>
            <cc:sub-route name="NoFiles" routes-to="Call_CreateLogEntry_NoFiles_Info_115"/>
            <cc:sub-route name="Files" routes-to="Call_Debug_Property_115"/>
        </cc:route>
        <cc:local-out id="Call_Aggregate_Append_115" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/AggregateSerial_115">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="LoadFile_115" routes-to="Call_Aggregate_Append_115">
            <cc:steps>
                <cc:copy id="CopyVarToMsg" input="variable" input-variable="wd.retrieve.variable"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Variable_115" store-message="none" execute-when="props['inDebugMode']" routes-response-to="LoadFile_115" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'wd.retrieve.variable'"/>
            <cc:set name="inEntityName" value="'DIS_Partial_File.xml'"/>
        </cc:local-out>
        <cc:route id="RetrieveFiles_115">
            <cc:doc-iterator labels="@{props['localLabels']}" sort-by="FILENAME_ASCENDING"/>
            <cc:sub-route name="Route" routes-to="Call_Debug_Variable_115"/>
        </cc:route>
        <cc:local-out id="Call_Debug_Property_115" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_AggregateSerialized_115" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localLabels'"/>
        </cc:local-out>
        <cc:local-in id="OrderedAggregation_115" routes-to="RetrieveFiles_115"/>
        <cc:local-out id="Call_AggregateSerialized_115" store-message="none" routes-response-to="Call_Aggregate_Finalize_115" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/OrderedAggregation_115"/>
        <cc:local-out id="Call_Aggregate_Finalize_115" store-message="none" routes-response-to="Call_Debug_Message_115" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/AggregateSerial_115">
            <cc:set name="inCollate" value="false"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:aggregator id="AggregateFileSerial_115" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:xml-message-content-collater output="message" output-mimetype="text/xml" xpath="*/*">
        <cc:header-text>&lt;DISRoot xmlns:tdf=&quot;urn:com.workday/tdf&quot;></cc:header-text>
        <cc:footer-text>&lt;/DISRoot></cc:footer-text>
      </cc:xml-message-content-collater>
        </cc:aggregator>
        <cc:local-in id="AggregateSerial_115" routes-to="AggregateFileSerial_115">
            
            
        <cc:parameter default="true" name="inCollate" required="true" type="boolean"/><cc:parameter default="false" name="inBatch" required="true" type="boolean"/></cc:local-in>
        <cc:route id="RouteThread_Message_144">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsChildThreadContext']" route="Child"/>
                <cc:choose-route expression="true" route="Parent"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Child" routes-to="GetMessageFragment_144"/>
            <cc:sub-route name="Parent" routes-to="Call_Aggregate_Message_144"/>
        </cc:route>
        <cc:route id="RouteThread_Variable_144">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsChildThreadContext']" route="Child"/>
                <cc:choose-route expression="true" route="Parent"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Child" routes-to="GetVariableFragment_144"/>
            <cc:sub-route name="Parent" routes-to="Variable_InitializeAndFinalize_Parent_144"/>
        </cc:route>
        <cc:async-mediation id="GetMessageFragment_144" routes-to="Call_CreateLogEntryOnThread_Debug_Message_144">
            <cc:steps>
                <cc:custom id="Custom" ref="SSK144DebugBean"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Message_144" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="(props['inEntityName'] != empty) ? props['inEntityName'] : com.workday.custom.int0025.ssk144.DebugBean.getEntityNameForMessage(context, props.inEntitySuffix)"/>
            <cc:set name="inLogMessageDetail" value="'Message root part initial fragment (up to 10 KB) saved in the Support Data field (full data may not be available if exceeds 10 KB)'"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="util.cleanString(props['int0025FileBackedManagedDataDebugFragment']) "/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Property_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'Property ' # props['inTargetName']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Properties_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="props['localKey144']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:route id="RouteProperties_144">
            <cc:loop-strategy condition="props['localCounter144'] &lt; props[props.inTargetName].size()" increment="props['localCounter144'] = props['localCounter144'] + 1" init="props['localCounter144'] = 0"/>
            <cc:sub-route name="Log" routes-to="MessageValues_Properties_144"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntry_Debug_Properties_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Debug_Properties_144" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="props['localKey144']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Variable_144" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="(props['inEntityName'] != empty) ? props['inEntityName'] : com.workday.custom.int0025.ssk144.DebugBean.getEntityNameForVariable(context, props.inTargetName, props.inEntitySuffix)"/>
            <cc:set name="inLogMessageDetail" value="'Variable initial fragment (up to 10 KB) saved in the Support Data field (full data may not be available if exceeds 10 KB)'"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="util.cleanString(props['int0025FileBackedManagedDataDebugFragment']) "/>
        </cc:local-out>
        <cc:async-mediation id="GetVariableFragment_144" routes-to="Call_CreateLogEntryOnThread_Debug_Variable_144">
            <cc:steps>
                <cc:custom id="Custom" ref="SSK144DebugBean"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteMap_144">
            <cc:loop-strategy condition="props['localCounter144'] &lt; props['localKeys144'].size()" increment="props['localCounter144'] = props['localCounter144'] + 1" init="props['localCounter144'] = 0"/>
            <cc:sub-route name="Log" routes-to="MessageValues_Map_144"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Map_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="props[props.inTargetName] # '/' # props['localKey144']"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:async-mediation id="GetMapKeys_144" routes-to="RouteMap_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKeys144'] = com.workday.custom.int0025.ssk144.DebugBean.getIterableList(context, props.inTargetName);</cc:expression>
                    <cc:expression>props['localCollection144'] = props[props.inTargetName];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteList_144">
            <cc:loop-strategy condition="props['localCounter144'] &lt; props['localKeys144'].size()" increment="props['localCounter144'] = props['localCounter144'] + 1" init="props['localCounter144'] = 0"/>
            <cc:sub-route name="Log" routes-to="MessageValues_List_144"/>
        </cc:route>
        <cc:async-mediation id="GetListKeys_144" routes-to="RouteList_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKeys144'] = props[props.inTargetName];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_List_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="props.inTargetName # ' Element ' # String.valueOf(props.localCounter144)"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:async-mediation id="GetSetKeys_144" routes-to="RouteSet_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKeys144'] = com.workday.custom.int0025.ssk144.DebugBean.getIterableList(context, props.inTargetName);</cc:expression>
                    <cc:expression>props['localCollection144'] = props[props.inTargetName];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="RouteSet_144">
            <cc:loop-strategy condition="props['localCounter144'] &lt; props['localKeys144'].size()" increment="props['localCounter144'] = props['localCounter144'] + 1" init="props['localCounter144'] = 0"/>
            <cc:sub-route name="Log" routes-to="MessageValues_Set_144"/>
        </cc:route>
        <cc:local-out id="Call_CreateLogEntryOnThread_Debug_Set_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="props.inTargetName # ' Element ' # String.valueOf(props.localCounter144)"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_Debug_Set_144" store-message="none" execute-when="!props['inIsChildThreadContext']" routes-response-to="Call_CreateLogEntryOnThread_Debug_Set_144" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry">
            <cc:set name="inLogMessage" value="props.inTargetName # ' Element ' # String.valueOf(props.localCounter144)"/>
            <cc:set name="inLogMessageDetail" value="props['localValue144']"/>
            <cc:set name="inLogLevel" value="'debug'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Warn_Finalize_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'Invalid Debug Target on Child Thread'"/>
            <cc:set name="inLogMessageDetail" value="'The &quot;finalize&quot; target is invalid to be used when executing the Debug component on a child thread.'"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntryOnThread_Warn_Undefined_144" store-message="none" execute-when="props['inIsChildThreadContext']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntryOnThread">
            <cc:set name="inLogMessage" value="'Undefined Debug Log'"/>
            <cc:set name="inLogMessageDetail" value="'RouteType_144 was not able to correctly process the inTargetType input parameter.'"/>
            <cc:set name="inLogLevel" value="'warn'"/>
            <cc:set name="inExtraSupportData" value="'props[inTargetType] = ' # props['inTargetType'] # '; props[inTargetName] = ' # props['inTargetName']"/>
        </cc:local-out>
        <cc:async-mediation id="MessageValues_Property_144" routes-to="Call_CreateLogEntry_Debug_Property_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localValue144'] = com.workday.custom.int0025.ssk144.DebugBean.getPropertyTargetValue(context, props.inTargetName);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="MessageValues_Properties_144" routes-to="Call_CreateLogEntry_Debug_Properties_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKey144'] = com.workday.custom.int0025.ssk144.DebugBean.getPropertiesTargetKey(props[props.inTargetName], props.localCounter144);</cc:expression>
                    <cc:expression>props['localValue144'] = com.workday.custom.int0025.ssk144.DebugBean.getPropertyTargetValue(context, props.localKey144);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="MessageValues_Map_144" routes-to="Call_CreateLogEntry_Debug_Map_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKey144'] = props['localKeys144'].get(props.localCounter144);</cc:expression>
                    <cc:expression>props['localValue144'] = com.workday.custom.int0025.ssk144.DebugBean.getMapTargetValue(context, props.localCollection144, props.localKey144);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="MessageValues_List_144" routes-to="Call_CreateLogEntry_Debug_List_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localValue144'] = com.workday.custom.int0025.ssk144.DebugBean.getPropertiesTargetKey(props['localKeys144'], props.localCounter144);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="MessageValues_Set_144" routes-to="Call_CreateLogEntry_Debug_Set_144">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localKey144'] = props['localKeys144'].get(props.localCounter144);</cc:expression>
                    <cc:expression>props['localValue144'] = com.workday.custom.int0025.ssk144.DebugBean.getItemValue(props.localKey144);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CreateLogEntry_Info_101" store-message="none" routes-response-to="InitializeAndFinalize_Property_101" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry"><cc:set name="inLogMessage" value="'SSK Component Usage Advice'"/><cc:set name="inLogMessageDetail" value="'Context properties can be added to the RaaS report prompts map more efficiently through a single Eval step with MVEL as opposed to using SSK101 AddReportPromptFromProperty.  Please see the User Guide for more information.'"/><cc:set name="inLogLevel" value="'info'"/><cc:set name="inExtraLocalIn" value="'AddReportPromptFromProperty'"/><cc:set name="inExtraSupportData" value="'While the component is functional, it is not the most-performant way to build prompts for a RaaS report.  AddReportPromptFromProperty serves as a guide and example to illustrate how to build a report prompt map for SSK102 ReadDataFromRaaS.  However, all prompts can easily be added in a single Eval step and save the overhead of validation and multiple mediation steps in the component.  This overhead is compounded when multiple prompts are needed.'"/></cc:local-out>
        <cc:local-out id="Call_Debug_SoapXslt_113" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
            
        </cc:local-out>
        <cc:local-out id="Call_HandleError_Transform_Error_113" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Transformation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while preparing a SOAP service call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'inBuildRequestPathToXsltFile'"/>
            <cc:set name="inEntityName" value="(org.apache.commons.lang.StringUtils.contains(props['inBuildRequestPathToXsltFile'], '/')) ?&#xD;&#xA;&#x9;org.apache.commons.lang.StringUtils.substringAfterLast(props['inBuildRequestPathToXsltFile'], '/') :&#xD;&#xA;&#x9;props['inBuildRequestPathToXsltFile']"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            
        </cc:local-out>
        <cc:async-mediation id="Transform_Handler_113" routes-to="Call_HandleError_Transform_Error_113">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Transform_113" routes-to="Call_Debug_SoapXslt_113">
            <cc:steps>
                <cc:xslt-plus id="WriteSoap" input="message" url="@{props['inBuildRequestPathToXsltFile']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Transform_Handler_113"/>
        </cc:async-mediation>
        <cc:async-mediation id="PreparePropertyInput_113" routes-to="Transform_113">
            <cc:steps>
                <cc:write id="PrimeMessage">
                    <cc:message>
                        <cc:text>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?>&#xD;
&lt;Root/></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Property_113" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleBuildRequestValidationError_113">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Property_113" routes-to="PreparePropertyInput_113">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>propname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = context.containsProperty(propname);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (context.getProperty(propname) instanceof java.util.Map) &amp;&amp; !(((java.util.Map)(context.getProperty(propname))).isEmpty());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="11304" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a context property named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="11305" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced context property named [@{props.inBuildRequestDataLocationId}] was not an instance of a java.util.Map, or that Map was empty.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Property_113"/>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareVariableInput_113" routes-to="Transform_113">
            <cc:steps>
                <cc:eval id="PrimeMessage">
                    <cc:expression>message.setMessage(vars[props.inBuildRequestDataLocationId].source, vars[props.inBuildRequestDataLocationId].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Variable_113" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleBuildRequestValidationError_113">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Variable_113" routes-to="PrepareVariableInput_113">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>varname = props['inBuildRequestDataLocationId'];&#xD;
props['localIsValueDefined'] = (vars.isVariable(varname)) &amp;&amp; (vars[varname] != null);&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (vars[varname].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="11302" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, a message variable named [@{props.inBuildRequestDataLocationId}] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="11303" failure-message="The inBuildRequestDataLocationId input parameter was set.  However, the referenced message variable named [@{props.inBuildRequestDataLocationId}] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Variable_113"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleBuildRequestValidationError_Message_113" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleBuildRequestValidationError_113">
            
            
            
            
            
            
            
            
            
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Message_113" routes-to="Transform_113">
            <cc:steps>
                <cc:eval id="EvaluateParameters">
                    <cc:expression>props['localIsValueDefined'] = parts[0] != empty;&#xD;
props['localIsValueTyped'] = props['localIsValueDefined'] &amp;&amp; (parts[0].isXml());</cc:expression>
                </cc:eval>
                <cc:validate-exp id="ValidateParameters">
                    <cc:expression error-number="11300" failure-message="Message part[0] could not be found.">props.localIsValueDefined</cc:expression>
                    <cc:expression error-number="11301" failure-message="Message part[0] was not valid XML data.">props.localIsValueTyped</cc:expression>
                </cc:validate-exp>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleBuildRequestValidationError_Message_113"/>
        </cc:async-mediation>
        <cc:route id="RouteInputSource_113">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'message'" route="Message"/>
                <cc:choose-route expression="props['inBuildRequestDataLocation'].trim().toLowerCase() == 'variable'" route="Variable"/>
                <cc:choose-route expression="true" route="Property"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Message" routes-to="Validation_Message_113"/>
            <cc:sub-route name="Variable" routes-to="Validation_Variable_113"/>
            <cc:sub-route name="Property" routes-to="Validation_Property_113"/>
        </cc:route>
        <cc:local-in id="BuildRequest_113" routes-to="RouteInputSource_113">
            <cc:parameter default="props['inApiVersion']" documentation="The version of the web service to be called, e.g. &quot;v30.0&quot;" name="inApiVersion" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestPathToXsltFile']" documentation="The file path relative to /ws/WSAR-INF for the XSLT file that will generate the SOAP request, e.g. &quot;xslt/GetWorkersRequest.xslt&quot;." name="inBuildRequestPathToXsltFile" required="true" type="string"/>
            <cc:parameter default="props['inBuildRequestDataLocation']" documentation="The java.util.Map instance that holds the key/value pairs of values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapVariableName.  The transform will define pre-established keys for the parameterized portions of the soap request.  Those pre-established keys should be used as the keys in the map so that their corresponding values can be embedded into the soap request." name="inBuildRequestDataLocation" required="false" type="string"/>
            <cc:parameter default="context.containsProperty('inBuildRequestDataLocationId') ? props['inBuildRequestDataLocationId'] : null" documentation="The name of the context variable that holds the data values to be used in the transform provided on the inPathToXsltFile parameter.  This is mutually-exclusive with inMapPropertyName.  The XML stored in the variable must be compatible with the XSLT provided on inPathToXsltFile.  See aUnit tests for a generic example of a multi-iteration, multi-variable example." name="inBuildRequestDataLocationId" required="false" type="string"/>
            <cc:parameter default="props['inDebugMode']" documentation="Controls whether or not the SOAP request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="props['inIsAbortOnError']" name="inIsAbortOnError" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_Validation_Error_113" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Validation Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while validating parameters for a SOAP service call.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_113'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            
        </cc:local-out>
        <cc:async-mediation id="Validation_Handler_113" routes-to="Call_HandleError_Validation_Error_113">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outIsSoapError'] = 'logic';&#xD;
props['outErrorMessage'] = (context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="HandleBuildRequestValidationError_113" routes-to="Validation_Handler_113"/>
        <cc:local-out id="Call_Debug_Child_141" store-message="none" execute-when="props['inIncludeDebugOutput'] &amp;&amp; props['inTargetType'] != empty" routes-response-to="Handler_141" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="props['inTargetType']"/>
            <cc:set name="inTargetName" value="props['inTargetName']"/>
            <cc:set name="inEntityName" value="props['inEntityName']"/>
        <cc:set name="inEntitySuffix" value="props['inEntitySuffix']"/><cc:set name="inIsChildThreadContext" value="true"/></cc:local-out>
        <cc:local-out id="Call_Debug_FilteredDocuments_110" store-message="none" execute-when="props['inDebugMode']" routes-response-to="RouteOnCount_110" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'Get_Event_Documents_Filtered.xml'"/>
        </cc:local-out>
        <cc:async-mediation id="Teardown_122">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="x-validate-only"/>
                        <cc:remove-header name="X-Tenant"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localURI']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_122" routes-to="Teardown_122"/>
        <cc:local-out id="Call_HandleError_QueueResults_122" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Result Error'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="props['inEndpoint'] # '/ccx/wd-queue/'"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_122'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="QueueResults_122">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outPollURI'] = parts[0].xpath('/*:queues/*:queue[*:name = &quot;'# props['inQueueName'] #'&quot;]/*:poll-uri');</cc:expression>
                    <cc:expression>props['outMessageCount'] = parts[0].xpath('/*:queues/*:queue[*:name = &quot;'# props['inQueueName'] #'&quot;]/*:message-count');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_QueueResults_122"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_REST_QueueStatusResponse_122" store-message="none" execute-when="props['inDebugMode']" routes-response-to="RouteQueueExists_122" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'REST-Response__QueueStatistics.xml'"/>
        </cc:local-out>
        <cc:http-out id="CallQueue_122" store-message="none" routes-response-to="Call_Debug_REST_QueueStatusResponse_122" endpoint="@{props['localURI']}" http-method="GET">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_Debug_REST_QueueStatusRequest_122" store-message="none" execute-when="props['inDebugMode']" routes-response-to="CallQueue_122" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localURI'"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_122" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Query Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while querying the Message Queue for statistics.  See Support Data for more information.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_122'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'GetQueues_ErrorResponse.xml'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_122" routes-to="Call_Debug_REST_QueueStatusRequest_122" handle-downstream-errors="true" routes-response-to="Call_Finally_122">
            <cc:request-steps>
                <cc:set-headers id="SetHeaders">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="X-Tenant" value="@{props['cc.customer.id']}"/>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetValues">
                    <cc:expression>props['localURI'] = props['inEndpoint'] # '/ccx/wd-queue/'</cc:expression>
                    <cc:expression>props['outMessageCount'] = 0;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_122"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_122" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_122"/>
        <cc:local-in id="CreateQueue" routes-to="InitializeAndFinalize_122" icon="icons/CreateQueue.png">
            <cc:parameter default="props['int0025QueueEndpoint']" documentation="The tenant endpoint at which the Message Queue REST API may be found." name="inEndpoint" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueName']" documentation="The name of the queue for which to return the polling URI." name="inQueueName" required="true" type="string"/>
            <cc:parameter default="props['int0025QueueUsername']" documentation="The username with which to authenticate to the tenant endpoint." name="inUsername" required="true" type="string"/>
            <cc:parameter default="props['int0025QueuePassword']" documentation="The password with which to authenticate to the tenant endpoint." name="inPassword" required="true" type="string"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the REST request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the REST request is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this sub-assembly will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:out-parameter documentation="The fully-qualified Uniform Resource Identifier of the queue" name="outPollURI"/>
            <cc:out-parameter documentation="The number of messages currently on the queue for processing." name="outMessageCount"/>
        </cc:local-in>
        <cc:route id="RouteQueueExists_122">
            <cc:mvel-strategy>
                <cc:choose-route expression="parts[0].xpathB('/*:queues/*:queue[*:name = &quot;'# props['inQueueName'] #'&quot;]')" route="ReturnQueue"/>
                <cc:choose-route expression="true" route="CreateQueue"/>
            </cc:mvel-strategy>
            <cc:sub-route name="ReturnQueue" routes-to="QueueResults_122"/>
            <cc:sub-route name="CreateQueue" routes-to="CreateCatch_122"/>
        </cc:route>
        <cc:local-out id="Call_HandleError_CreateQueue_122" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Result Error'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="props['inEndpoint'] # '/ccx/wd-queue/' # props['inQueueName']"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_122'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="CreateCatch_122" routes-to="CreateQueue_122" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CreateQueue_122"/>
        </cc:async-mediation>
        <cc:http-out id="CreateQueue_122" store-message="none" routes-response-to="CreateResults_122" endpoint="@{props['localURI']}@{props['inQueueName']}" http-method="PUT">
            <cc:rest-binding/>
            <cc:http-basic-auth password="@{props['inPassword']}" username="@{props['inUsername']}"/>
        </cc:http-out>
        <cc:local-out id="Call_HandleError_CreateResults_122" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message Queue Result Error'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="props['inEndpoint'] # '/ccx/wd-queue/'"/>
            <cc:set name="inExtraErrorCode" value="context.errorCode"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_122'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="CreateResults_122">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['outPollURI'] = parts[0].xpath('/*:queue/*:poll-uri');</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CreateResults_122"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Finally_127" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_127"/>
        <cc:route id="AllMessages_128">
            <cc:loop-strategy condition="props['localIsContinueLoop']"/>
            <cc:sub-route name="CheckQueue" routes-to="CallQueue_128"/>
        </cc:route>
        <cc:async-mediation id="EvaluateQueue_128" routes-to="SplitMessages_128">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>props['localIsContinueLoop'] = ((parts[0].xpath('/*:messages/@*:returned-count')) != (parts[0].xpath('/*:messages/@*:total-count')));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_DeleteMessage_128" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/DeleteMessage_128">
            
            
            
        </cc:local-out>
        <cc:local-in id="DeleteMessage_128" routes-to="CatchDequeueErrors_128">
            
            
            
        </cc:local-in>
        <cc:local-out id="HandleError_CustomLogic" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'An unhandled error occurred within the custom integration flow.'"/>
            <cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inLogReferenceId"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
        	<cc:set name="inFinallyEndpoint"/>
        	<cc:set name="inIsAbortOnError" value="false"/>
        	<cc:set name="inIsResetError" value="false"/>
        	<cc:set name="inIncludeDebugOutput" value="false"/>
        	<cc:set name="inLogTarget" value="'primary'"/>
        	<cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="PIM_PrimaryTag_142" store-message="none" execute-when="props['localIsLogReady142']" routes-response-to="PrimaryLogReset_142" endpoint="vm://wcc/PutIntegrationMessage">
            <cc:set name="is.event.wid" value="context.containsProperty('int0025EventWID') ? props['int0025EventWID'] : null"/>
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="'Saved log file to the Integration Event.'"/>
            <cc:set name="is.document.variable.name" value="'logStoreResult'"/>
            <cc:set name="is.document.file.name" value="props['localPrimaryLogFilenameForStorage']"/>
            <cc:set name="is.document.deliverable" value="'false'"/>
            
            <cc:set name="is.document.labels" value="props['int0025PrimaryLogAggregationTag'] != empty ? util.listToCommaDelimString(props['int0025PrimaryLogAggregationTag']) : null"/>
            <cc:set name="is.message.storage.enabled" value="false"/>
            
            
        </cc:local-out>
        <cc:async-mediation id="PrimaryLogReset_142" routes-to="Call_LogStatsPrimary_142" execute-steps-when="props['localIsLogReady142']">
            <cc:steps>
                <cc:eval id="Reset">
                    <cc:expression>vars['cloud-log-primary'] = null</cc:expression>
                    <cc:expression>props['int0025PrimaryLogCountByLogFile'] = 0</cc:expression>
                    <cc:expression>foreach (propname : ['localPrimaryLogFilenameForStorage']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval></cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrimaryDetermineOutput_142" routes-to="OutputPrimaryLog_142">
            <cc:steps>
                <cc:eval id="InitValue">
                    <cc:expression>props['localIsLogReady142'] = com.workday.custom.int0025.ssk142.GeneralCloudLogHelper.isLogReadyForOutput(context, 'primary');</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="SecondaryDetermineOutput_142" routes-to="OutputSecondaryLog_142">
            <cc:steps>
                <cc:eval id="InitValue">
                    <cc:expression>props['localIsLogReady142'] = com.workday.custom.int0025.ssk142.GeneralCloudLogHelper.isLogReadyForOutput(context, 'secondary');</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="SecondaryLogReset_142" routes-to="Call_LogStatsSecondary_142" execute-steps-when="props['localIsLogReady142']">
            <cc:steps>
                <cc:eval id="Reset">
                    <cc:expression>vars['cloud-log-secondary'] = null</cc:expression>
                    <cc:expression>props['int0025SecondaryLogCountByLogFile'] = 0</cc:expression>
                    <cc:expression>foreach (propname : ['localSecondaryLogFilenameForStorage']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="PIM_SecondaryTag_142" store-message="none" execute-when="props['localIsLogReady142']" routes-response-to="SecondaryLogReset_142" endpoint="vm://wcc/PutIntegrationMessage">
            <cc:set name="is.event.wid" value="context.containsProperty('int0025EventWID') ? props['int0025EventWID'] : null"/>
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="'Saved log file to the Integration Event.'"/>
            <cc:set name="is.document.variable.name" value="'logStoreResult'"/>
            <cc:set name="is.document.file.name" value="props['localSecondaryLogFilenameForStorage']"/>
            <cc:set name="is.document.deliverable" value="'false'"/>
            <cc:set name="is.document.labels" value="props['int0025SecondaryLogAggregationTag'] != empty ? util.listToCommaDelimString(props['int0025SecondaryLogAggregationTag']) : null"/>
            <cc:set name="is.message.storage.enabled" value="false"/>
        </cc:local-out>
        <cc:local-in id="ReportDiff" routes-to="ExecuteReportCompare_149" access="public" icon="icons/ReportDiff.png">
        	<cc:parameter documentation="Where to find the historic snapshot data for comparison.  If the value is 'message', then the contents of the message root part will be read.  Otherwise, the value is interpreted as the name of a variable where the data will be found." name="inDataSourceHistoric" required="true" type="string"/>
        	<cc:parameter default="'message'" documentation="Where to find the current snapshot data for comparison.  If the value is 'message', then the contents of the message root part will be read.  Otherwise, the value is interpreted as the name of a variable where the data will be found." name="inDataSourceCurrent" required="true" type="string"/>
            <cc:parameter default="props['outPropertyNameHistoricIdList149']" documentation="A reference to the set data structure as created by SSK149 InitializeReportDiff and populated by SSK149 BuildUniqueIdList.  This list is of the historic ids." name="inPropertyWithHistoricList" required="true"/><cc:parameter default="props['outPropertyNameCurrentIdList149']" documentation="A reference to the set data structure as created by SSK149 InitializeReportDiff and populated by SSK149 BuildUniqueIdList.  This list is of the current ids." name="inPropertyWithCurrentList" required="true"/><cc:parameter default="true" documentation="Boolean flag that, if TRUE, will omit any records from the result data set where no changes have been detected.  All output will have some diff: attribute added.  If the flag is set to FALSE, then the full superset of historic + current snapshots is output to create a full file and all changes are annotated." name="inIsReturnChangesOnly" required="true" type="boolean"/><cc:parameter default="'message'" documentation="How the diff results are returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="'primary'" documentation="In the event of an exception in the Java code, this parameter controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
        </cc:local-in>
        <cc:local-in id="BuildUniqueIdList" routes-to="Initialize_IdList_149" access="public" icon="icons/BuildUniqueIdList.png"><cc:parameter default="'message'" documentation="The location that holds the XML custom report data whose primary key is to be parsed into a Java set.  This data is the historic snapshot against which the current snapshot will be compared." name="inDataSource" required="true" type="string"/><cc:parameter default="props['outPropertyNameHistoricIdList149']" documentation="The property that holds the Java Set with the list of Ids as created by SK149 InitializeReportDiff.  When building the historic list, this will most likely be props['outPropertyNameHistoricIdList149'], whereas for the current list, this would likely be props['outPropertyNameCurrentIdList149']" name="inPropertyWithIdList" required="true"/><cc:parameter default="'primary'" documentation="In the event of an exception in the Java code, this parameter controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary','secondary'] contains props['inLogTarget'].trim().toLowerCase()"/><cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/></cc:local-in>
        <cc:async-mediation id="Initialize_IdList_149">
            <cc:steps>
                <cc:custom id="BuildList" method-name="process" ref="SSK149ListBuilderBean"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_IdList_Error_149"/>
        </cc:async-mediation>
        <cc:async-mediation id="ExecuteReportCompare_149">
            <cc:steps>
                <cc:custom id="Compare" output-mimetype="text/xml" method-name="process" ref="SSK149ReportDiffBean"/>
                <cc:eval execute-when="props['inReturnResults'].trim().toLowerCase() != 'message'" id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ExecuteReportCompare_Error_149"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_ExecuteReportCompare_Error_149" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'ReportDiff Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while differencing two reports via ordered streams.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_IdList_Error_149" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'ID List Build Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while building the id references from ' # props['inDataSource'] # ' to support differencing reports via ordered streams.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-in id="HandleByteOrderMark" routes-to="Initialize_148" access="public" icon="icons/HandleByteOrderMark.png"><cc:parameter default="'message'" documentation="Where to find the data to be processed.  If the value is 'message', then the contents of the message root part will be processed for a BOM.  Otherwise, the value is interpreted as the name of a variable where the data will be found." name="inDataSource" required="true" type="string"/><cc:parameter default="if (props['inDataSource'].trim().toLowerCase() == 'message') {&#xD;&#xA;&#x9;parts[0].mimeType;&#xD;&#xA;} else {&#xD;&#xA;&#x9;vars[props.inDataSource].mimeType;&#xD;&#xA;}" documentation="Content mime-type of the data to be processed for BOM removal.  When processing an input document to remove a BOM, the content-type will be inferred from the input source data.  When processing your output document to add a BOM, the inTargetContentType is used to determine the BOM for that character encoding." name="inTargetContentType" required="true" type="string"/><cc:parameter default="false" documentation="Flag to indicate whether or not a BOM should be removed during processing.  If TRUE, then the stream from inDataSource will be processed as the mime-type indicated by inContentType and will be checked for the presence of a BOM.  If found, the BOM will be removed and the stream returned as it was, minus the BOM." name="inIsRemoveBOM" required="props['inIsAddBOM'] == empty || (!props['inIsAddBOM'])" type="boolean" validation="(props['inIsRemoveBOM'] != empty &amp;&amp; props['inIsRemoveBOM'] &amp;&amp; (props['inIsAddBOM'] == empty || !props['inIsAddBOM'])) ||&#xD;&#xA;&#x9;(props['inIsRemoveBOM'] != empty &amp;&amp; !props['inIsRemoveBOM'] &amp;&amp; (props['inIsAddBOM'] != empty &amp;&amp; props['inIsAddBOM'])) ||&#xD;&#xA;&#x9;(props['inIsRemoveBOM'] == empty &amp;&amp; (props['inIsAddBOM'] != empty &amp;&amp; props['inIsAddBOM']))&#x9;"/><cc:parameter default="false" documentation="Flag to indicate whether or not a BOM should be added during processing.  If TRUE, then the stream from inDataSource will be processed and output in the character encoding indicated by inContentType.  The stream will be returned in the new encoding, and with a BOM added per that encoding type." name="inIsAddBOM" required="props['inIsRemoveBOM'] == empty || (!props['inIsRemoveBOM'])" type="boolean" validation="(props['inIsAddBOM'] != empty &amp;&amp; props['inIsAddBOM'] &amp;&amp; (props['inIsRemoveBOM'] == empty || !props['inIsRemoveBOM'])) ||&#xD;&#xA;&#x9;(props['inIsAddBOM'] != empty &amp;&amp; !props['inIsAddBOM'] &amp;&amp; (props['inIsRemoveBOM'] != empty &amp;&amp; props['inIsRemoveBOM'])) ||&#xD;&#xA;&#x9;(props['inIsAddBOM'] == empty &amp;&amp; (props['inIsRemoveBOM'] != empty &amp;&amp; props['inIsRemoveBOM']))"/><cc:parameter default="'message'" documentation="Where the results of the processing are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/><cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the aggregated, pre-transform data from variable localPreTransformData107 is output on debug as well as context properties in error conditions." name="inDebugMode" required="false" type="boolean"/><cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/><cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/><cc:out-parameter documentation="Will be set to TRUE if a Byte Order Mark was added to the data" name="outIsBOMAdded148"/><cc:out-parameter documentation="Will be set to TRUE if a Byte Order Mark was removed from the data" name="outIsBOMRemoved148"/></cc:local-in>
        <cc:route id="RouteInputByContentType_148">
            <cc:mvel-strategy>
                <cc:choose-route expression="parts[0].isXml()" route="XML"/>
                <cc:choose-route expression="true" route="NotXML"/>
            </cc:mvel-strategy>
            <cc:sub-route name="XML" routes-to="PrepareXML_148"/>
            <cc:sub-route name="NotXML" routes-to="PrepareNonXML_148"/>
        </cc:route>
        <cc:async-mediation id="PrepareNonXML_148" routes-to="ReturnResults_148">
            <cc:steps>
                <cc:custom id="ProcessText" method-name="processText" ref="SSK148ProcessorBean"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="PrepareXML_148" routes-to="ReturnResults_148">
            <cc:steps>
                <cc:custom id="ProcessXml" method-name="processXml" ref="SSK148ProcessorBean"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Initialize_148" routes-to="RouteInputByContentType_148" continue-after-error="rewind" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval execute-when="props['inDataSource'] != 'message'" id="CopyVarToMsg">
                    <cc:expression>message.setMessage(vars[props.inDataSource].source, vars[props.inDataSource].mimeType);</cc:expression>
                </cc:eval></cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_148"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_148" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'HandleByteOrderMark Error'"/>
            <cc:set name="inLogMessageDetail" value="'Unable to process the input data for a byte order mark'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'Message_For_BOM_Processing'"/>
        <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:async-mediation id="ReturnResults_148" execute-steps-when="props['inReturnResults'].trim().toLowerCase() != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_CloudLogEtvXttMessages_129" store-message="none" execute-when="(props['inIsUseETV'] || props['inIsUseXTT']) &amp;&amp; props['localEtvXttMessages129'] != empty" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CloudLogETVXTTMessages"><cc:set name="inMessages" value="props['localEtvXttMessages129']"/><cc:set name="inIsClearMessages" value="true"/><cc:set name="inMinLogLevel" value="props['inMinLogLevel']"/><cc:set name="inLogTarget" value="props['inLogTarget']"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_InitializeThreadedLogging_116" store-message="none" routes-response-to="Call_ParallelSubroutine_116" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StartThreadLog"><cc:set name="inIsResetIfStarted" value="false"/></cc:local-out>
        <cc:local-out id="Call_WriteThreadLogsToCloudLog_Flush_116" store-message="none" execute-when="props['inIsUseParallel'] &amp;&amp; props['localIsBlocks'] &amp;&amp; props['localParallelLog143'] != empty" routes-response-to="Teardown_116" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/WriteThreadLogsToCloudLog">
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
        </cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_FlushInfo_116" store-message="none" execute-when="props['inIsUseParallel'] &amp;&amp; props['localIsBlocks'] &amp;&amp; props['localParallelLog143'] != empty" routes-response-to="Call_WriteThreadLogsToCloudLog_Flush_116" endpoint="@{props['inLogTarget'] == 'secondary' ? 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateSecondaryLogEntry' : 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry'}">
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inLogMessage" value="'Unlogged thread messages found'"/>
            <cc:set name="inLogMessageDetail" value="'All messages from child threads in parallel PagedGet were not logged.  Messages will be flushed to the log.  This may result in out-of-order message sequences.'"/>
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraRecordNumber" value="props['localParallelLog143'].size()"/>
        </cc:local-out>
        <cc:local-in id="GetLogAggregationChain" routes-to="InitializeAndFinalize_136" access="public" icon="icons/GetLogAggregationChain.png"><cc:parameter default="(props['int0025LogChainWID'] == empty) ? props['int0025EventWID'] : props['int0025LogChainWID']" documentation="The Integration Event WID of the most recent event that holds the LogChain.xml file with the most up-to-date list of WIDs to be aggregated." name="inLogChainWID" required="true" type="string"/><cc:parameter default="false" documentation="A boolean flag to indicate if a LogChain.xml file is strictly expected.  If True and no LogChain.xml file is found, then an exception will be raised.  If False and no file is found, then an empty LogChain XML root document will be returned." name="inIsChainNotFoundAnError" required="true" type="boolean"/><cc:parameter default="'message'" documentation="Where the results of the response are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/><cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the GetEventDocuments results are output on debug as well as context properties in error conditions." name="inDebugMode" required="true" type="boolean"/><cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="true" type="boolean"/></cc:local-in>
        <cc:local-out id="Call_Finally_136" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_136"/>
        <cc:async-mediation id="Teardown_136">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>// Remove properties that are purely internal to the subassembly
foreach (propname : ['localFilename136','localCollection136','localEntryID136']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_136" routes-to="Teardown_136"/>
        <cc:sync-mediation id="InitializeAndFinalize_136" routes-to="GetEventDocuments_136" routes-response-to="Call_Finally_136">
            <cc:request-steps/>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_136"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_136" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"><cc:set name="inLogMessage" value="'Log Aggregation Chain Retrieval Error'"/><cc:set name="inLogMessageDetail" value="'An error occurred while attempting to load the log chain document held on the Reference ID event.'"/><cc:set name="inLogReferenceId" value="props.inLogChainWID"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/><cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Call_Finally_136'"/><cc:set name="inIsAbortOnError" value="true"/><cc:set name="inIsResetError" value="false"/><cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-out id="GetEventDocuments_136" routes-response-to="Call_Debug_GetEventDocuments_136" endpoint="vm://wcc/GetEventDocuments"><cc:set name="ie.event.wid" value="props['inLogChainWID']"/></cc:local-out>
        <cc:local-out id="Call_Debug_GetEventDocuments_136" store-message="none" execute-when="props['inDebugMode']" routes-response-to="LogChainFilesSort_136" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"><cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'GetEventDocuments__Response136.xml'"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:async-mediation id="DocumentAccessor_136" routes-to="Call_Debug_FilteredDocuments_136">
            <cc:steps>
                <cc:validate-exp id="ValidateExp">
                    <cc:expression error-number="13600" failure-message="A LogChain.xml file was not found on Integration Event @{props['inLogChainWID']}">parts[0].xpathB('/Documents/Document')</cc:expression>
                </cc:validate-exp>
                <cc:eval id="SetValues">
                    <cc:expression>props['localFilename136'] = parts[0].xpath('/Documents/Document[1]/Filename');&#xD;
props['localCollection136'] = parts[0].xpath('/Documents/Document[1]/Collection');&#xD;
props['localEntryID136'] = parts[0].xpath('/Documents/Document[1]/EntryID');</cc:expression>
                </cc:eval>
                <cc:retrieve id="Retrieve" output-mimetype="text/xml" collection="@{props['localCollection136']}" entry="@{props['localEntryID136']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DocumentAccessor_Error_136"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_DocumentAccessor_Error_136" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Log Aggregation Chain Retrieval Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while filtering event documents to access the most recent log chain document held on the Reference ID event.'"/>
            <cc:set name="inLogReferenceId" value="props.inLogChainWID"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Call_Finally_136'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['int0025IsDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'DocumentAccessor_136.xml'"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_Results_Error_136" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Log Aggregation Chain Retrieval Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the log chain document to the [' # props.inReturnResults # '] return variable.'"/>
            <cc:set name="inLogReferenceId" value="props.inLogChainWID"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Call_Finally_136'"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['int0025IsDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'Results_136.xml'"/>
            <cc:set name="inLogTarget" value="'primary'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="Results_136" execute-steps-when="props['inReturnResults'] != 'message'">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_136"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_FilteredDocuments_136" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Results_136" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'GetEventDocuments__SelectedChainFile136.xml'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="Teardown_134">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>// Remove properties that are purely internal to the subassembly
foreach (propname : ['localFilename136','localCollection136','localEntryID136']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>// And remove local variables that are no longer required&#xD;
foreach (varname : ['localRecordCount134']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_134" routes-to="Teardown_134"/>
        <cc:local-out id="Call_Finally_134" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_134"/>
        <cc:local-in id="ExtendLogAggregationChain" routes-to="InitializeAndFinalize_134" access="public" icon="icons/ExtendLogAggregationChain.png"><cc:parameter default="(props['int0025LogChainWID'] == empty) ? props['int0025EventWID'] : props['int0025LogChainWID']" documentation="The Integration Event WID of the most recent event in the chain of events that holds the LogChain.xml file with the most up-to-date list of WIDs to be aggregated." name="inLogChainWID" required="true" type="string"/><cc:parameter default="props['int0025EventWID']" documentation="The WID of the Integration Event to add to the end of the chain.  This value needs to be valid for calls made to the Integrations/Get_Event_Documents_Request web service / GetEventDocuments Studio component.  The current integration event is assumed." name="inNextChainEventLinkWID" required="true" type="string"/><cc:parameter default="'AggregatedLog'" documentation="A dynamic name to assign to the aggregated log file when it is ultimately produced.  This is only used when there is no LogChain.xml file and one is being originated." name="inAggregatedLogName" required="false" type="string"/><cc:parameter default="props['int0025SecondaryLogAggregationTabName']" documentation="The worksheet name to use for the event's log content in the aggregated log file.  If partial logs are used, then the tab name will follow this prefix, and the partial log file counter will be appended." name="inAggregatedTabName" required="true" type="string"/><cc:parameter default="props['int0025DocumentRetentionPeriod']" documentation="The length of time to retain the LogChain.xml file." name="inDocumentRetentionPeriod" required="true" type="string"/><cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the GetEventDocuments results are output on debug as well as context properties in error conditions." name="inDebugMode" required="true" type="boolean"/><cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="true" type="boolean"/></cc:local-in>
        <cc:sync-mediation id="InitializeAndFinalize_134" routes-to="GetEventDocuments_134" handle-downstream-errors="true" routes-response-to="Call_Finally_134">
            <cc:request-steps/>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_134"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_134" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"><cc:set name="inLogMessage" value="'Log Aggregation Chain Extension Error'"/><cc:set name="inLogMessageDetail" value="'An error occurred while attempting to add the current Integration Event to the log chain document held on the Reference ID event.'"/><cc:set name="inLogReferenceId" value="props.inLogChainWID"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/><cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Call_Finally_134'"/><cc:set name="inIsAbortOnError" value="true"/><cc:set name="inIsResetError" value="false"/><cc:set name="inIncludeDebugOutput" value="false"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-out id="GetEventDocuments_134" routes-response-to="Call_Debug_GetEventDocuments_134" endpoint="vm://wcc/GetEventDocuments"><cc:set name="ie.event.wid" value="props['inLogChainWID']"/></cc:local-out>
        <cc:local-out id="Call_Debug_GetEventDocuments_134" store-message="none" execute-when="props['inDebugMode']" routes-response-to="DocumentAccessor_134" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'GetEventDocuments__Response134.xml'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="DocumentAccessor_134" routes-to="RouteChain_134">
            <cc:steps>
                <cc:xslt-plus id="FilterEventDocuments" url="xslt/ssk134/SSK134_DocumentFilter.xsl"/>
                <cc:xslt-plus id="CountRecords" output="variable" output-mimetype="text/xml" output-variable="localRecordCount134" url="xslt/ssk134/SSK134_CountRecords.xsl"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['localDACount134'] = (int)vars['localRecordCount134'].xstream('/totalRecords');</cc:expression>
                    <cc:expression>props['localNewLogChainFilename'] = 'LogChain-' # String.valueOf(util.currentTime().timeInMillis) # '.xml';</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_DocumentAccessor_Error_134"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_DocumentAccessor_Error_134" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"><cc:set name="inLogMessage" value="'Log Aggregation Chain Extension Error'"/><cc:set name="inLogMessageDetail" value="'An error occurred while filtering event documents to identify the most recent log chain document held on the Reference ID event.'"/><cc:set name="inLogReferenceId" value="props.inLogChainWID"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/><cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Call_Finally_134'"/><cc:set name="inIsAbortOnError" value="true"/><cc:set name="inIsResetError" value="false"/><cc:set name="inIncludeDebugOutput" value="props['int0025IsDebugMode']"/><cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'DocumentAccessor134.xml'"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:route id="RouteChain_134">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['localDACount134'] > 0" route="ContinueChain"/>
                <cc:choose-route expression="true" route="NewChain"/>
            </cc:mvel-strategy>
            <cc:sub-route name="NewChain" routes-to="NewFile_134"/>
            <cc:sub-route name="ContinueChain" routes-to="AppendFile_134"/>
        </cc:route>
        <cc:async-mediation id="AppendFile_134" routes-to="StoreLogChain_134">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['localCollection134'] = parts[0].xpath('/Documents/Document[1]/Collection');&#xD;
props['localEntryID134'] = parts[0].xpath('/Documents/Document[1]/EntryID');&#xD;
props['localFilename134'] = parts[0].xpath('/Documents/Document[1]/Filename');</cc:expression>
                </cc:eval>
                <cc:retrieve id="RetrieveLogChain" output="variable" output-mimetype="text/xml" output-variable="localChain134" collection="@{props['localCollection134']}" entry="@{props['localEntryID134']}"/>
                <cc:xslt-plus id="AddLinkToChain" output="variable" output-mimetype="text/xml" output-variable="localChain134" input="variable" input-variable="localChain134" url="xslt/ssk134/SSK134_AppendChain.xsl"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_AppendFile_Error_134"/>
        </cc:async-mediation>
        <cc:async-mediation id="NewFile_134" routes-to="StoreLogChain_134">
            <cc:steps>
                <cc:write id="WriteXML" output="variable" output-mimetype="text/xml" output-variable="localChain134">
                    <cc:message>
                        <cc:text>&lt;Chain filename=&quot;@{props['inAggregatedLogName']}.xlsx&quot;>&#xD;
	&lt;Event tab=&quot;@{props['inAggregatedTabName']}&quot;>@{props['inNextChainEventLinkWID']}&lt;/Event>&#xD;
&lt;/Chain></cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="StoreLogChain_134" routes-to="PIM_Tag_134">
            <cc:steps>
                <cc:store id="StoreLogChain" output="variable" output-mimetype="text/xml" output-variable="localStoreResult134" input="variable" input-variable="localChain134" expiresIn="@{props['inDocumentRetentionPeriod']}" title="@{props['localNewLogChainFilename']}"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_StoreLogChain_Error_134"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_StoreLogChain_Error_134" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"><cc:set name="inLogMessage" value="'Log Aggregation Chain Extension Error'"/><cc:set name="inLogMessageDetail" value="'An error occurred while storing the extending the chain to the current event.'"/><cc:set name="inLogReferenceId" value="props.inLogChainWID"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/><cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Call_Finally_134'"/><cc:set name="inIsAbortOnError" value="true"/><cc:set name="inIsResetError" value="false"/><cc:set name="inIncludeDebugOutput" value="props['int0025IsDebugMode']"/><cc:set name="inTargetType" value="'variable'"/><cc:set name="inTargetName" value="'localChain134'"/><cc:set name="inEntityName" value="'localChain134.xml'"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-out id="Call_HandleError_AppendFile_Error_134" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"><cc:set name="inLogMessage" value="'Log Aggregation Chain Extension Error'"/><cc:set name="inLogMessageDetail" value="'An error occurred while accessing the most recent log chain document held on the Reference ID event and extending the chain.'"/><cc:set name="inLogReferenceId" value="props.inLogChainWID"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/><cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Call_Finally_134'"/><cc:set name="inIsAbortOnError" value="true"/><cc:set name="inIsResetError" value="false"/><cc:set name="inIncludeDebugOutput" value="props['int0025IsDebugMode']"/><cc:set name="inTargetType" value="'variable'"/><cc:set name="inTargetName" value="'localChain134'"/><cc:set name="inEntityName" value="'localChain134.xml'"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-out id="PIM_Tag_134" endpoint="vm://wcc/PutIntegrationMessage"><cc:set name="is.event.wid" value="props['inNextChainEventLinkWID']"/><cc:set name="is.message.severity" value="'INFO'"/><cc:set name="is.message.summary" value="'Saved file '# props['localNewLogChainFilename'] #' to the Integration Event.'"/><cc:set name="is.document.variable.name" value="'localStoreResult134'"/><cc:set name="is.document.file.name" value="props['localNewLogChainFilename']"/><cc:set name="is.document.labels" value="'INT_LogAggregationList'"/><cc:set name="is.document.deliverable" value="'false'"/><cc:set name="is.message.storage.enabled" value="false"/></cc:local-out>
        <cc:local-out id="PIM_ImportProcessTarget_113" routes-response-to="Call_CreateLogEntry_Response_Info_113" endpoint="vm://wcc/PutIntegrationMessage" clone-request="true"><cc:set name="is.message.severity" value="'INFO'"/><cc:set name="is.message.summary" value="'Import Job Started'"/><cc:set name="is.message.detail" value="'Import job started through ' # props.inWebServiceApplication # ' web service. The message target may be used to monitor processing. Check the integration logs after completion for process messages.'"/><cc:set name="is.message.targets" value="props['outImportProcessReference']"/><cc:set name="is.message.targets.type" value="'WID'"/></cc:local-out>
        <cc:local-out id="Call_CreateLogEntry_NoMessages_Dynamic_118" store-message="none" endpoint="@{(props.inLogTargetForXsltMessages == 'secondary') ? 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateSecondaryLogEntry' : 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CreateLogEntry'}">
            <cc:set name="inLogMessage" value="'No Import Process Messages'"/>
            <cc:set name="inLogMessageDetail" value="'No tenant errors were returned related to the import job.'"/>
            <cc:set name="inLogReferenceId" value="props['inProcessWID']"/>
            <cc:set name="inLogLevel" value="'info'"/>
            <cc:set name="inExtraLocalIn" value="'Call_CreateLogEntry_NoMessages_Dynamic_118'"/>
            
            
            
        </cc:local-out>
        <cc:route id="RouteMessages_118">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['localXsltMessages118'] != empty" route="Messages"/>
                <cc:choose-route expression="true" route="NoMessages"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Messages" routes-to="Call_CloudLogXSLTMessages_Dynamic_118"/>
            <cc:sub-route name="NoMessages" routes-to="Call_CreateLogEntry_NoMessages_Dynamic_118"/>
        </cc:route>
        <cc:local-out id="Call_CloudLogXSLTMessages_Dynamic_118" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CloudLogXSLTMessages">
            
            
            
            
            
            
            
            
        <cc:set name="inMessages" value="props['localXsltMessages118']"/><cc:set name="inIsClearMessages" value="true"/><cc:set name="inLogTarget" value="props.inLogTargetForXsltMessages"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-out id="LogXsltMessages_120" store-message="none" execute-when="props['inPathToXsltFile'] != empty" routes-response-to="BuildRequestFromXmlAndXsd_120" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CloudLogXSLTMessages"><cc:set name="inMessages" value="props['localXsltMessages120']"/><cc:set name="inIsClearMessages" value="true"/><cc:set name="inMinLogLevel" value="'debug'"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-in id="MultiItemFlowControl" routes-to="InitializeAndFinalize_130" icon="icons/MultiItemFlowControl.png">
        	<cc:parameter default="'a'" documentation="This is any string that can be used to differentiate between calls made to SSK130.  This allows for the calls to be nested, e.g. SSK130 is used to process a list of documents, each one of which results in a batch of API calls to be made, also handled by SSK130.  This string just has to be unique for each call and can be very short, even 1 character long, although for logging, tracing and debugging purposes, it is recommended to use something meaningful and relevant to the work being done, e.g. &quot;documents&quot; for processing the output of SSK110.  This value will help distinguish between internal properties of the component when there are nested calls." name="inUniqueKey" required="true" type="string"/><cc:parameter default="'message'" documentation="Where the XML data to be split can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inDataSource" required="true" type="string"/>
        	<cc:parameter default="'/*/*'" documentation="XPath expression to be used in the XPath attribute of the xml-stream-splitter.  This must be a streamable query as it is also used to count the items and provide record number context within the batch for logging and progress." name="inItemXPath" required="true" type="string"/>
        	<cc:parameter default="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Your_Local-In_Goes_Here'" documentation="Specifies the sub-assembly local-in (i.e., vm://INT0025_CheckWorkRights_VisaCheck_Inbound/&lt;Sample_Local-In>) that should be invoked to process each item from the spitter.  The sub-assembly may use the FlowControlBean's static methods to access information about the current item context, e.g. record number." name="inProcessEndpoint" required="true" type="string"/><cc:parameter documentation="The current percentage progress complete of the integration event at the time the component is called.  The value must be provided as a numeric type.  Values range between 10 and 90." name="inStartingProgressPercent" required="true" validation="(10 &lt;= props.inStartingProgressPercent) &amp;&amp; (props.inStartingProgressPercent &lt; props.inTargetEndingProgressPercent)"/>
        	<cc:parameter documentation="The expected percentage progress complete of the integration event at the time the component finishes.  The value can be passed as either a String or a Number.  The values provided are the same as for SSK108, which is, a value of 80% would be passed as &quot;80&quot;." name="inTargetEndingProgressPercent" required="true" validation="(props.inStartingProgressPercent &lt; props.inTargetEndingProgressPercent) &amp;&amp; (props.inTargetEndingProgressPercent &lt;= 90)"/>
            <cc:parameter default="1" documentation="This value will defer making calls to SSK108 to update the integration event completion percentage until a certain incremental amount of progress is made.  This helps to avoid making API calls to the tenant too frequently, which will have an adverse effect on integration performance and provides no functional value.  If the progress percent is desired to be updated every 5%, then it would be passed as &quot;5&quot;." name="inUpdateProgressAfterPercentIncrease" required="false" validation="((props.inUpdateProgressAfterPercentIncrease > 0) &amp;&amp; &#xD;&#xA;&#x9;((props.inTargetEndingProgressPercent - props.inStartingProgressPercent) >= props.inUpdateProgressAfterPercentIncrease))"/><cc:parameter default="'info'" documentation="The level at which the error handler responsible for intercepting the required No Split Message feedback will be logged.  Options include any Cloud Log level, e.g. &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;.  Default is &quot;info&quot; on assumption that if SSK130 is handling documents, SSK110 has already dealt with a no document scenario, and if it's SSK103 or SSK120, again the assumption is that XSLT or other validations have already addressed individual records and logged validation results." name="inLogLevelNoSplitMessageError" required="true" type="string" validation="['debug','info','warn','error','critical'] contains props['inLogLevelNoSplitMessageError'].trim().toLowerCase()"/><cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the aggregated, pre-transform data from variable localPreTransformData107 is output on debug as well as context properties in error conditions." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
        	
        </cc:local-in>
        <cc:sync-mediation id="InitializeAndFinalize_130" routes-to="Call_Debug_TotalRecords_130" handle-downstream-errors="false" routes-response-to="Call_Finally_130">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>com.workday.custom.int0025.ssk130.FlowControlBean.initializeLoop(context);</cc:expression>
                </cc:eval>
                <cc:eval execute-when="props.inDataSource != 'message'" id="MoveVarToMsg">
                    <cc:expression>message.setMessage(vars[props.inDataSource].source, vars[props.inDataSource].mimeType)</cc:expression>
                </cc:eval>
                <cc:xslt-plus id="CountRecords" output="variable" output-mimetype="text/xml" output-variable="localCountResult130" url="xslt/ssk130/SSK130_CountRecords.xsl"/>
            
                <cc:eval id="SetValue">
                    <cc:expression>totalRecords = String.valueOf(vars['localCountResult130'].xstream('/totalRecords'));&#xD;
com.workday.custom.int0025.ssk130.FlowControlBean.configureLoop(context, totalRecords);</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_130"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_130" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Multi-Item Flow Control Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while initializing the component state.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localCountResult130'"/><cc:set name="inEntityName" value="'localCountResult130.xml'"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_130'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
        </cc:local-out>
        <cc:async-mediation id="Teardown_130">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>com.workday.custom.int0025.ssk130.FlowControlBean.deregisterLoop(context);</cc:expression>
                    <cc:expression>// And remove local variables that are no longer required&#xD;
foreach (varname : ['localCountResult130']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_130" routes-to="Teardown_130"/>
        <cc:local-out id="Call_Finally_130" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_130"/>
        <cc:splitter id="ItemSplitter_130">
            <cc:sub-route name="ProcessItem" routes-to="Call_Debug_SplitItem_130"/>
            <cc:xml-stream-splitter xpath="@{props.inItemXPath}"/>
        </cc:splitter>
        <cc:local-out id="Call_IEP_130" store-message="none" execute-when="com.workday.custom.int0025.ssk130.FlowControlBean.isUpdateProgress()" routes-response-to="IncrementCountOfUpdates" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/IntegrationEventProgress"><cc:set name="inProgressPercentage" value="com.workday.custom.int0025.ssk130.FlowControlBean.getCurrentProgressPercent()"/><cc:set name="inProgressMessage" value="'Completed processing of item number ' # (com.workday.custom.int0025.ssk130.FlowControlBean.getCurrentItemNumber()) # '...'"/></cc:local-out>
        <cc:sync-mediation id="FlowControl_130" routes-to="Call_ProcessEndpoint_130" handle-downstream-errors="true" routes-response-to="Call_IEP_130">
            <cc:request-steps>
                <cc:eval id="SetValues">
                    <cc:expression>com.workday.custom.int0025.ssk130.FlowControlBean.incrementItemCounter();&#xD;
com.workday.custom.int0025.ssk130.FlowControlBean.recalculateProgressUpdateThreshold();</cc:expression>
                </cc:eval>
                <cc:eval id="LoopDetectBugWorkaround1">
                    <cc:expression>//This Loop-Detected workaround is necessary; otherwise, any exceptions raised in the close-down process and handled by SA-109 will produce a loop detected error and obscure the actual error that occurred within Main.&#xD;
//props[&quot;localProcessFlagLoopControl130&quot;] = com.workday.custom.int0025.ssk109.LocalOutHelper.SnapshotLoopDetection(context);&#xD;
com.workday.custom.int0025.ssk130.FlowControlBean.startLoopDetectBugWorkaround(context);</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>com.workday.custom.int0025.ssk130.FlowControlBean.incrementPercentAccumulator();</cc:expression>
                </cc:eval>
                <cc:eval id="LoopDetectBugWorkaround2">
                    <cc:expression>//com.workday.custom.int0025.ssk109.LocalOutHelper.ClearLoopDetectionFlags(context, props[&quot;localProcessFlagLoopControl130&quot;]);&#xD;
com.workday.custom.int0025.ssk130.FlowControlBean.stopLoopDetectBugWorkaround(context);</cc:expression>
                </cc:eval>
            </cc:response-steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_FlowControl_130"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_ProcessEndpoint_130" store-message="none" endpoint="@{props.inProcessEndpoint}" propagate-abort="false"/>
        <cc:local-out id="Call_HandleError_FlowControl_130" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Multi-Item Flow Control Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while processing one of the items in the batch.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="com.workday.custom.int0025.ssk130.FlowControlBean.getCurrentItemNumber()"/><cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            
            
            
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_130'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
        </cc:local-out>
        <cc:async-mediation id="IncrementCountOfUpdates" execute-steps-when="com.workday.custom.int0025.ssk130.FlowControlBean.isUpdateProgress()">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>com.workday.custom.int0025.ssk130.FlowControlBean.incrementUpdateCounter();</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="ProcessEndpointExample_130" routes-to="PerItemProcess_130"/>
        <cc:async-mediation id="PerItemProcess_130">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>if (props['localErrorLogFieldOverride'] == empty) {&#xD;
	props.localErrorLogFieldOverride = new java.util.HashMap();&#xD;
} else {&#xD;
	props.localErrorLogFieldOverride.clear();&#xD;
}</cc:expression>
                    <cc:expression>props.localErrorLogFieldOverride.put('inExtraRecordNumber', (com.workday.custom.int0025.ssk130.FlowControlBean.getCurrentItemNumber()));&#xD;
props.localErrorLogFieldOverride.put('inLogReferenceId', (com.workday.custom.int0025.ssk130.FlowControlBean.getCurrentProgressPercent()));</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="NoSplitCatch_130" routes-to="ItemSplitter_130" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_NoSplitError_130"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_NoSplitError_130" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Multi-Item Flow Control - No Split Found'"/>
            <cc:set name="inLogMessageDetail" value="'No items were found when the inItemXPath was applied to the inDataSource data.'"/>
            <cc:set name="inLogLevel" value="props.inLogLevelNoSplitMessageError"/>
            <cc:set name="inExtraLocalIn" value="'ItemSplitter_130'"/>
            <cc:set name="inExtraSupportData" value="''"/>
            <cc:set name="inExtraErrorCode" value="(props.inLogLevelNoSplitMessageError == 'info') ? '' : '13000'"/>
            <cc:set name="inIsAbortOnError" value="(props.inLogLevelNoSplitMessageError.toLowerCase() == 'info') ? false : props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntityName" value="'SSK130_Data_to_Split.xml'"/>
            <cc:set name="inFinallyEndpoint" value="(props.inLogLevelNoSplitMessageError == 'info') ? null : 'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_130'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_SplitItem_130" store-message="none" execute-when="props['inDebugMode']" routes-response-to="FlowControl_130" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"><cc:set name="inTargetType" value="'message'"/><cc:set name="inEntitySuffix" value="'SplitItem_UniqueKey-' # props['inUniqueKey']"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-out id="Call_Debug_TotalRecords_130" store-message="none" execute-when="props['inDebugMode']" routes-response-to="NoSplitCatch_130" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"><cc:set name="inTargetType" value="'variable'"/><cc:set name="inTargetName" value="'localCountResult130'"/><cc:set name="inEntitySuffix" value="'uniqueKey-' # props['inUniqueKey']"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-out id="Call_DebugBefore_129" store-message="none" execute-when="props['inDebugMode']" routes-response-to="ApplyTransform_129" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"><cc:set name="inTargetType" value="(props['inDataLocation'] == 'message') ? 'message' : 'variable'"/><cc:set name="inTargetName" value="(props['inDataLocation'] == 'message') ? null : props['inDataLocation']"/><cc:set name="inEntityName" value="(props['inDataLocation'] == 'message') ? 'rootpart.xml' : (props['inDataLocation'] # '.xml')"/><cc:set name="inEntitySuffix" value="''"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-in id="GetRootOpenTag" routes-to="Initialize_135" access="public" icon="icons/GetRootOpenTag.png">
        	<cc:parameter default="'message'" documentation="Where the XML data can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inDataLocation" required="true" type="string"/>
        	<cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not debug output is produced on error handling." name="inDebugMode" required="false" type="boolean"/>
        	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
        	<cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
			<cc:parameter default="context.containsProperty('outCloudLogFieldOverrideMap145') ? props['outCloudLogFieldOverrideMap145'] : null" documentation="This parameter provides the opportunity to specify a Java HashMap from a context property to replace the error values being reported internally by the component.  The map is keyed by the attribute name of the SSK141 HandleError input parameter, and the value is a string to be used in place of the SSK103 default.  If the map is not provided, or if a map is given but does not contain a key for the logged parameter, then the SSK103 default behavior applies.  If only a single value is desired to be changed from the out-of-the-box behavior, then a map with a single entry could be provided.  In some cases, the logged value is not available to be override, e.g. inLocalIn or inLogLevel when there are hard errors." name="inErrorLogOverrideMap" required="false"/>
			<cc:out-parameter name="outRootOpenTag135"/></cc:local-in>
        <cc:local-in id="GetRootCloseTag" routes-to="Initialize_138" access="public" icon="icons/GetRootCloseTag.png">
        	<cc:parameter default="'message'" documentation="Where the XML data can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inDataLocation" required="true" type="string"/>
        	<cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not debug output is produced on error handling." name="inDebugMode" required="false" type="boolean"/>
        	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
        	<cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
            <cc:parameter default="context.containsProperty('outCloudLogFieldOverrideMap145') ? props['outCloudLogFieldOverrideMap145'] : null" documentation="This parameter provides the opportunity to specify a Java HashMap from a context property to replace the error values being reported internally by the component.  The map is keyed by the attribute name of the SSK141 HandleError input parameter, and the value is a string to be used in place of the SSK103 default.  If the map is not provided, or if a map is given but does not contain a key for the logged parameter, then the SSK103 default behavior applies.  If only a single value is desired to be changed from the out-of-the-box behavior, then a map with a single entry could be provided.  In some cases, the logged value is not available to be override, e.g. inLocalIn or inLogLevel when there are hard errors." name="inErrorLogOverrideMap" required="false"/>
	        <cc:out-parameter name="outRootCloseTag138"/></cc:local-in>
        <cc:local-in id="OverrideCloudLogFields" routes-to="ManageFieldOverrideMap_145" access="public" icon="icons/OverrideCloudLogFields.png">
            <cc:parameter documentation="Value that will be written to the Message attribute of the Cloud Logger instead of the default behavior of the SSK Component.  If this is empty or omitted, no value is written to the override map, and the SSK Component default behavior will be applied." name="inLogMessage" required="false" type="string"/>
            <cc:parameter documentation="Value that will be written to the Message Details attribute of the Cloud Logger instead of the default behavior of the SSK Component.  If this is empty or omitted, no value is written to the override map, and the SSK Component default behavior will be applied." name="inLogMessageDetail" required="false" type="string"/>
            <cc:parameter documentation="Value that will be written to the Reference Id attribute of the Cloud Logger instead of the default behavior of the SSK Component.  If this is empty or omitted, no value is written to the override map, and the SSK Component default behavior will be applied." name="inLogReferenceId" required="false" type="string"/>
            <cc:parameter documentation="Value that determines the Level attribute of the Cloud Logger instead of the default behavior of the SSK Component.  If this is empty or omitted, no value is written to the override map, and the SSK Component default behavior will be applied." name="inLogLevel" required="false" type="string" validation="(props['inLogLevel'] == empty) || (['debug','info','warn','error','critical'] contains props['inLogLevel'].trim().toLowerCase())"/>
            <cc:parameter documentation="Value written to the RecordNumber Extra Column on the log instead of the default behavior of the SSK Component.  If this is empty or omitted, no value is written to the override map, and the SSK Component default behavior will be applied." name="inExtraRecordNumber" required="false"/>
            <cc:parameter documentation="Value written to the SupportData Extra Column on the log instead of the default behavior of the SSK Component.  If this is empty or omitted, no value is written to the override map, and the SSK Component default behavior will be applied." name="inExtraSupportData" required="false"/>
            <cc:parameter documentation="Value written to the ErrorCode Extra Column on the log instead of the default behavior of the SSK Component.  If this is empty or omitted, no value is written to the override map, and the SSK Component default behavior will be applied." name="inExtraErrorCode" required="false"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the map of override values is debug-logged to the cloud log after update." name="inDebugMode" required="true" type="boolean"/>
            <cc:out-parameter documentation="A Java HashMap that can be used as input to the inErrorLogOverrideMap input parameter of other components, e.g. CallSoap.  SSK Components that provide the inErrorLogOverrideMap input parameter are compatible with this map, and this component may be used to manage the values to be used prior to calling the other components in the event of errors." name="outCloudLogFieldOverrideMap145"/></cc:local-in>
        <cc:async-mediation id="ManageFieldOverrideMap_145" routes-to="Call_Debug_FieldOverrides_145">
            <cc:steps>
                <cc:eval id="UpdateValues">
                    <cc:expression>if (props['outCloudLogFieldOverrideMap145'] == empty) {&#xD;
	props['outCloudLogFieldOverrideMap145'] = new java.util.HashMap();&#xD;
} else {&#xD;
	props['outCloudLogFieldOverrideMap145'].clear();&#xD;
}</cc:expression>
                    <cc:expression>if (props['inLogMessage'] != empty) {&#xD;
	props['outCloudLogFieldOverrideMap145'].put('inLogMessage', props['inLogMessage']);&#xD;
}&#xD;
if (props['inLogMessageDetail'] != empty) {&#xD;
	props['outCloudLogFieldOverrideMap145'].put('inLogMessageDetail', props['inLogMessageDetail']);&#xD;
}&#xD;
if (props['inLogLevel'] != empty) {&#xD;
	props['outCloudLogFieldOverrideMap145'].put('inLogLevel', props['inLogLevel']);&#xD;
}&#xD;
if (props['inLogReferenceId'] != empty) {&#xD;
	props['outCloudLogFieldOverrideMap145'].put('inLogReferenceId', props['inLogReferenceId']);&#xD;
}&#xD;
if (props['inExtraRecordNumber'] != empty) {&#xD;
	props['outCloudLogFieldOverrideMap145'].put('inExtraRecordNumber', props['inExtraRecordNumber']);&#xD;
}&#xD;
if (props['inExtraSupportData'] != empty) {&#xD;
	props['outCloudLogFieldOverrideMap145'].put('inExtraSupportData', props['inExtraSupportData']);&#xD;
}&#xD;
if (props['inExtraErrorCode'] != empty) {&#xD;
	props['outCloudLogFieldOverrideMap145'].put('inExtraErrorCode', props['inExtraErrorCode']);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_FieldOverrides_145" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"><cc:set name="inTargetType" value="'map'"/><cc:set name="inTargetName" value="'outCloudLogFieldOverrideMap145'"/></cc:local-out>
        <cc:async-mediation id="Teardown_129">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>com.workday.custom.int0025.ssk130.FlowControlBean.deregisterLoop(context);</cc:expression>
                    <cc:expression>// And remove local variables that are no longer required&#xD;
foreach (varname : ['localCountResult130']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_129" routes-to="Teardown_129"/>
        <cc:local-out id="Call_HandleError_FinalizeResults_161" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;('An error occurred while copying the API results from the message rootpart to variable '# props['inReturnResults'] #'.')"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;''"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_161'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
        	<cc:set name="inTargetType" value="'property'"/>
        	<cc:set name="inTargetName" value="'inReturnResults'"/>
        	
        </cc:local-out>
        <cc:async-mediation id="FinalizeResults_161">
            <cc:steps>
                <cc:json-to-xml execute-when="props['inReturnResultsAsXml']" id="Convert" output="message" output-mimetype="text/xml"/>
                <cc:eval execute-when="props['inReturnResults'] != 'message'" id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="Error" routes-to="Call_HandleError_FinalizeResults_161"/>
        </cc:async-mediation>
        <cc:http-out id="CallApi_161" store-message="none" routes-response-to="Call_Debug_Response_161" endpoint="@{props['localEndpoint161']}" accept="@{props['inHttpHeaderAccept']}" http-method="@{props['inHttpMethod']}">
        </cc:http-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_161" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'CallRestApi Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred preparing the REST API request.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;''"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_161'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
        	<cc:set name="inTargetType" value="'property'"/>
        	<cc:set name="inTargetName" value="'localEndpoint161'"/>
        	
        </cc:local-out>
        <cc:local-in id="CallRestApi" routes-to="InitializeAndFinalize_161" access="public" icon="icons/CallExtendApi.png">
            <cc:parameter default="props['outAccessToken160']" documentation="Authorization header as returned by SSK Component 160 - GetAccessToken." name="inAccessToken" required="true" type="string"/>
            <cc:parameter default="props['int0025RestBaseApiEndpoint']" documentation="The base URL for the Workday REST API endpoint.  For Extend, the endpoint value would be 'https://api.workday.com' for all tenants (the tenant is encoded into the access token).  Whereas, for a tenanted endpoint, the value might look like 'https://wcpdev-services1.wd101.myworkday.com/ccx/api' for a WCPDEV tenant, or 'https://wd5-impl-services1.workday.com/ccx/api' for an IMPL tenant in WD5." name="inGatewayEndpoint" required="true" type="string"/>
            <cc:parameter default="'extend = /serviceName/version/resource/etc  or  tenant = /serviceName/version/&lt;tenant>/resource/etc'" documentation="The relative URI to be combined with the inGatewayEndpoint value to create the full REST API URL to be executed.  When working with Extend, most WWS endpoints (not endpoints for Model Level Component business objects) will be obtained through the API Explorer in Dev Site.  If retrieving Worker info for Logan McNeil for example, the endpoint for Extend could be expressed as '/staffing/v3/workers/3aa5550b7fe348b98d7b5741afc65534' or '/common/v1/workers/3aa5550b7fe348b98d7b5741afc65534'.  If using a tenanted version of the endpoint, this parameter could be similarly expressed as '/staffing/v3/&lt;tenant>/workers/3aa5550b7fe348b98d7b5741afc65534' or '/common/v1/&lt;tenant>/workers/3aa5550b7fe348b98d7b5741afc65534'.  If the literal &quot;&lt;tenant>&quot; value is used in the URI, it will be substitution-replaced by the actual tenant name in which the integration is running.  For example, if running for Global Modern Services in a WD5 implementation tenant, a parameter value of '/common/v1/&lt;tenant>/workers/3aa5550b7fe348b98d7b5741afc65534' would be changed to something like '/common/v1/gms2/workers/3aa5550b7fe348b98d7b5741afc65534', which when ultimately combined with the inGatewayEndpoint parameter would result in execution of this fully-built URL: 'https://wd5-impl-services1.workday.com/ccx/api/common/v1/gms2/workers/3aa5550b7fe348b98d7b5741afc65534'.  The general pattern is given by the default value." name="inApiPath" required="true" type="string"/>
            <cc:parameter default="'GET'" documentation="The HTTP verb to be used with the outbound REST call.  GET uses no body and retrieves data.  POST requires a body and will &quot;insert&quot; new data.  PUT requires a body and will do a destructive &quot;update&quot;, i.e. omitted fields are removed from the original object.  PATCH requires a body and will do a non-destructive &quot;update&quot;, i.e. omitted fields will be preserved on the original object and only those included are updated.  DELETE may optionally include a body and will &quot;delete&quot; / remove the object instance." name="inHttpMethod" required="true" type="string" validation="['GET','POST','PUT','PATCH','DELETE'] contains props['inHttpMethod'].trim().toUpperCase()"/>
            <cc:parameter default="false" documentation="Indicates if the inApiPath provided is to be accessed by GET and supports REST endpoint paginated retrieval." name="inIsPaginatedGet" required="true" type="boolean" validation="(!props['inIsPaginatedGet']) ||&#xD;&#xA;&#x9;(props['inIsPaginatedGet'] &amp;&amp; props['inHttpMethod'].trim().toUpperCase() == 'GET')"/><cc:parameter default="100" documentation="When the inHttpMethod is GET and the endpoint specified by inApiPath returns a collection, all records may not be returned in a single call.  The default page size of the endpoint is 20 records, but that may be increased to 100.  This parameter specifies the number of records to retrieve in a single API request/page and must be between 0 and 100." name="inLimitForPaginatedGet" required="props['inHttpMethod'].trim().toUpperCase() == 'GET' &amp;&amp; props['inIsPaginatedGet']" type="integer" validation="(props['inHttpMethod'].trim().toUpperCase() != 'GET') ||&#xD;&#xA;&#x9;(!props['inIsPaginatedGet']) ||&#xD;&#xA;&#x9;(props['inLimitForPaginatedGet'] > 0 &amp;&amp; props['inLimitForPaginatedGet'] &lt;= 100)"/>
            <cc:parameter default="0" documentation="When the inHttpMethod is GET and the endpoint specified by inApiPath returns a collection, all records may not be returned in a single call.  This parameter specifies the number of records to skip before beginning selection for the page of data returned from the API request." name="inOffsetForPaginatedGet" required="props['inHttpMethod'].trim().toUpperCase() == 'GET' &amp;&amp; props['inIsPaginatedGet']" type="integer" validation="(props['inHttpMethod'].trim().toUpperCase() != 'GET') ||&#xD;&#xA;&#x9;(!props['inIsPaginatedGet']) ||&#xD;&#xA;&#x9;(props['inOffsetForPaginatedGet'] >= 0)"/>
            <cc:parameter default="true" documentation="When the inHttpMethod is GET and the endpoint specified by inApiPath returns a collection, all records may not be returned in a single call.  This parameter indicates that, if more records exist than can be returned in a single call/page, then the component should loop to reetrieve all records regardless of max count or page sizes." name="inIsRetrieveAllForPaginatedGet" required="props['inHttpMethod'].trim().toUpperCase() == 'GET' &amp;&amp; props['inIsPaginatedGet']" type="boolean"/>
            <cc:parameter default="'message'" documentation="If the endpoint call requires a body, then this is where the payload content can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found.  The mime-type will be inferred from the message/variable." name="inDataLocation" required="['POST','PUT','PATCH'] contains props['inHttpMethod'].trim().toUpperCase()" type="string"/>
            <cc:parameter default="'application/json'" name="inHttpHeaderAccept" required="true" type="string"/>
            <cc:parameter default="false" documentation="Returns the JSON schema of the response instead of actual data." name="inIsMeta" required="false" type="boolean"/>
            <cc:parameter default="'message'" documentation="How the REST results are returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="false" documentation="Either return the JSON response from the endpoint directly, or convert it to XML with JsonToXml first." name="inReturnResultsAsXml" required="false" type="boolean"/>
            <cc:parameter default="'primary'" documentation="In the event of an API error from the tenant, this parameter controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the API request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the API request and response are output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
            <cc:parameter default="context.containsProperty('outCloudLogFieldOverrideMap145') ? props['outCloudLogFieldOverrideMap145'] : null" documentation="This parameter provides the opportunity to specify a Java HashMap from a context property to replace the error values being reported internally by the component.  The map is keyed by the attribute name of the SSK141 HandleError input parameter, and the value is a string to be used in place of the SSK103 default.  If the map is not provided, or if a map is given but does not contain a key for the logged parameter, then the SSK103 default behavior applies.  If only a single value is desired to be changed from the out-of-the-box behavior, then a map with a single entry could be provided.  In some cases, the logged value is not available to be override, e.g. inLocalIn or inLogLevel when there are hard errors." name="inErrorLogOverrideMap" required="false"/>
        	<cc:out-parameter documentation="The total possible number of records in the tenant.  This is not necessarily the number of records being returned by the component depending on the calling parameterization." name="outTotalRecordCountForPagination161"/>
        </cc:local-in>
        <cc:local-out id="Call_Debug_Response_160" store-message="none" execute-when="props['inDebugMode']" routes-response-to="ParseResponse_160" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>            
            <cc:set name="inEntitytName" value="'Response__AccessToken.json'"/><cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_ParseResponse_160" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            
            
            
            
            
            
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'GetAccessToken Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred while reading the access token from the API JSON response.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;props['inClientId']"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_160'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
        	<cc:set name="inTargetType" value="'message'"/>
        	
        	<cc:set name="inEntityName" value="'RequestAccessToken160__Response.txt'"/>
        <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/></cc:local-out>
        <cc:async-mediation id="ParseResponse_160">
            <cc:steps>
                <cc:json-to-xml id="ConvertResponse"/>
                <cc:validate-exp id="ValidateToken">
                    <cc:expression error-number="16000" failure-message="No access token was returned from the WCP token endpoint!">parts[0].xstreamB('root/data/access_token')</cc:expression>
                </cc:validate-exp>
                <cc:eval id="SetToken">
                    <cc:expression>props['outAccessToken160'] = parts[0].xstream('root/data/access_token')</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ParseResponse_160"/>
        </cc:async-mediation>
        <cc:http-out id="RequestAccessToken_160" store-message="none" routes-response-to="Call_Debug_Response_160" endpoint="@{props['inTokenEndpoint']}" http-method="POST"/>
        <cc:local-out id="Call_HandleError_RequestAccessToken_160" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            
            
            
            
            
            
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'GetAccessToken Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred calling the token endpoint.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;props['inClientId']"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_160'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
        	<cc:set name="inTargetType" value="'property'"/>
        	<cc:set name="inTargetName" value="'inTokenEndpoint'"/>
        	
        <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/></cc:local-out>
        <cc:async-mediation id="TokenRequestCatch_160" routes-to="RequestAccessToken_160" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval execute-when="props['inProvider'] == 'tenant'" id="InitValues">
                    <cc:expression>if (props['inTokenEndpoint'].toLowerCase().contains('&lt;tenant>')) {&#xD;
	tenant = props['cc.customer.id'];&#xD;
	props['inTokenEndpoint'] = props['inTokenEndpoint'].replace('&lt;tenant>', tenant);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_RequestAccessToken_160"/>
        </cc:async-mediation>
        <cc:local-in id="GetAccessToken" routes-to="InitializeAndFinalize_160" access="public" icon="icons/GetAccessToken.png">
            <cc:parameter default="props['int0025RestTokenEndpoint']" documentation="The URL endpoint from which to retrieve an OAuth2 access token.  For Extend, the endpoint value would be 'https://auth.api.workday.com/v1/token' for all tenants (the tenant is determined by the tenant alias).  Whereas, for a tenanted endpoint, the value might look like 'https://wcpdev-services1.wd101.myworkday.com/ccx/oauth2/&lt;tenant>/token' for a WCPDEV tenant, or 'https://wd5-impl-services1.workday.com/ccx/oauth2/&lt;tenant>/token' for an IMPL tenant in WD5." name="inTokenEndpoint" required="true" type="string"/>
            <cc:parameter default="props['int0025RestProvider']" documentation="Identifies whether REST APIs are served by Extend or by the Tenant.  This is automatically determined by the SSK Integration Services configuration.  No changes are needed to this parameter." name="inProvider" required="true" type="string" validation="['extend','tenant'] contains props['int0025RestProvider'].trim().toLowerCase()"/><cc:parameter default="props['int0025RestTenantAlias']" documentation="The tenant alias as known and mapped through the API Gateway and Extend Developer Site.  In some cases, this will be the same as the tenant name found in the cc.customer.id context property.  In others, e.g. sandbox, it will be different.  This parameter is not required and is ignored when using tenanted REST APIs and not Extend." name="inTenantAlias" required="props['int0025RestProvider'] == 'extend'" type="string"/>
            <cc:parameter default="props['int0025RestClientId']" documentation="Client ID value used in token requests for OAuth.  This will match the API Client in the Dev Console for Extend, or the API Clients for Integrations for the tenanted version." name="inClientId" required="true" type="string"/>
            <cc:parameter default="props['int0025RestClientSecret']" documentation="Client Secret value used in token requests for OAuth.  This will match the API Client in the Dev Console for Extend, or the API Clients for Integrations for the tenanted version." name="inClientSecret" required="true" type="string"/>
            <cc:parameter default="props['int0025RestRefreshToken']" documentation="A persistent Refresh Token defined in the tenanted External Client Credstore for a given account/holder.  If not provided, the token endpoint will be attempted with a grant type of client_credentials.  If it is valued, then the grant_type will be refresh_token." name="inRefreshToken" required="props['int0025RestProvider'] == 'tenant'" type="string"/>
            <cc:parameter default="'primary'" documentation="In the event of an API error from the tenant, this parameter controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the API response is output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="context.containsProperty('outCloudLogFieldOverrideMap145') ? props['outCloudLogFieldOverrideMap145'] : null" documentation="This parameter provides the opportunity to specify a Java HashMap from a context property to replace the error values being reported internally by the component.  The map is keyed by the attribute name of the SSK141 HandleError input parameter, and the value is a string to be used in place of the SSK103 default.  If the map is not provided, or if a map is given but does not contain a key for the logged parameter, then the SSK103 default behavior applies.  If only a single value is desired to be changed from the out-of-the-box behavior, then a map with a single entry could be provided.  In some cases, the logged value is not available to be override, e.g. inLocalIn or inLogLevel when there are hard errors." name="inErrorLogOverrideMap" required="false"/>
        	<cc:out-parameter documentation="Authorization bearer header token for use with calls to Workday REST, either via Extend through the API gateway or directly to the tenanted endpoint.  Note that the access token from the Extend and the Tenant token endpoints CANNOT be interchanged, i.e. an access token obtained from the tenant's token endpoint is not compatible with the Extend API Gateway.  Nor are access tokens obtained through Extend token endpoint compatible to be set as a header on calls to the tenanted WWS, including also the SOAP API and will result in errors either directly or indirectly through Studio Components such as PutIntegrationMessage." name="outAccessToken160"/>
        </cc:local-in>
        <cc:sync-mediation id="InitializeAndFinalize_160" routes-to="TokenRequestCatch_160" routes-response-to="Call_Finally_160">
            <cc:request-steps>
                <cc:write id="WritePreEncodedAuthHeader" output-mimetype="text/plain">
                    <cc:message>
                        <cc:text>@{props['inClientId'] + ':' + props['inClientSecret']}</cc:text>
                    </cc:message>
                </cc:write>
                <cc:base64-encode id="EncodeAuthHeader" output="message" output-mimetype="text/plain" input="message"/>
                <cc:set-headers id="SetHeaders" output="message" clear-all="true">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="Authorization" value="@{(props['inProvider'] == 'tenant') ? 'Basic' : 'ID'} @{parts[0].text}"/>
                        <cc:add-header name="Accept" value="application/json"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:write execute-when="(props['inRefreshToken'] == empty) &amp;&amp; (props['inProvider'] == 'extend')" id="WriteMessageBodyClientCredentials" output-mimetype="application/x-www-form-urlencoded">
                    <cc:message>
                        <cc:text>grant_type=client_credentials&amp;tenant_alias=@{props['inTenantAlias']}</cc:text>
                    </cc:message>
                </cc:write>
                <cc:write execute-when="props['inRefreshToken'] != empty" id="WriteMessageBodyRefreshToken" output-mimetype="application/x-www-form-urlencoded">
                    <cc:message>
                        <cc:text>grant_type=refresh_token&amp;refresh_token=@{props['inRefreshToken']}</cc:text>
                    </cc:message>
                </cc:write>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_160"/>
        </cc:sync-mediation>
        <cc:sync-mediation id="InitializeAndFinalize_161" routes-to="RouteOnHttpMethod_161" handle-downstream-errors="false" routes-response-to="Call_Finally_161">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>if (props['inApiPath'].toLowerCase().contains('&lt;tenant>')) {&#xD;
	tenant = props['cc.customer.id'];&#xD;
	props['inApiPath'] = props['inApiPath'].replace('&lt;tenant>', tenant);&#xD;
}</cc:expression>
                    <cc:expression>if ((props['inHttpMethod'].trim().toUpperCase() != 'GET') &amp;&amp; (props['inDataLocation'] != 'message')) {&#xD;
	message.setMessage(vars[props.inDataLocation].source, vars[props.inDataLocation].mimeType);&#xD;
}</cc:expression>
                    <cc:expression>if ((props['inHttpMethod'].trim().toUpperCase() == 'PATCH') &amp;&amp; (props['wd.http.client'] != 'apache')) {&#xD;
	props['localHttpClientCache161'] = props['wd.http.client'];&#xD;
	props['wd.http.client'] = 'apache';&#xD;
}</cc:expression>
                    <cc:expression>props['outTotalRecordCountForPagination161'] = 0;</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
            </cc:response-steps>
            <cc:send-error id="Error" routes-to="Call_HandleError_InitializeAndFinalize_161"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_160" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_160"/>
        <cc:local-out id="Call_Finally_161" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_161"/>
        <cc:async-mediation id="Teardown_160">
            <cc:steps>
                <cc:set-headers id="ClearHeaders" output="message" clear-all="true">
                    <cc:remove-headers>
                        <cc:remove-header name="Authorization"/>
                        <cc:remove-header name="Accept"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_160" routes-to="Teardown_160"/>
        <cc:async-mediation id="Teardown_161">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>if (context.containsProperty('localHttpClientCache161')) {&#xD;
	props['wd.http.client'] = props['localHttpClientCache161'];&#xD;
}</cc:expression>
                    <cc:expression>foreach (propname : ['localEndpoint161','localHttpClientCache161','localOffset161']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
                <cc:set-headers id="ClearHeaders" output="message" clear-all="true">
                    <cc:remove-headers>
                        <cc:remove-header name="content-length"/>
                        <cc:remove-header name="Authorization"/>
                        <cc:remove-header name="Accept"/>
                        <cc:remove-header name="Content-Type"/>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_161" routes-to="Teardown_161"/>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_160" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'GetAccessToken Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred while creating the initial grant request.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_160'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
        	<cc:set name="inTargetType" value="'property'"/>
        	<cc:set name="inTargetName" value="'inClientId'"/>
        	
        <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/><cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;''"/></cc:local-out>
        <cc:local-out id="Call_Debug_Response_161" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug"><cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'CallRestApi__Response.json'"/><cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_CallApi_161" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'REST API Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred calling the REST API endpoint.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;props['inClientId']"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_161'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localEndpoint161'"/>
            
        </cc:local-out>
        <cc:async-mediation id="ApiCatch_161" routes-to="CallApi_161" handle-downstream-errors="true">
            <cc:steps>
                <cc:set-headers execute-when="context.containsProperty('inIsMeta') &amp;&amp; props['inIsMeta']" id="SetHeadersMeta" clear-all="false">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="wd-metadata-api-version" value="v1"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="SetConditionalHeader">
                    <cc:expression>if (props['inValidateOnly'] &amp;&amp; props['inHttpMethod'] != 'GET') {&#xD;
	message.setHeader('x-validate-only', (props['inValidateOnly'] ? 1 : 0));&#xD;
}</cc:expression>
                </cc:eval>
                <cc:set-headers id="SetHeaders" output="message" clear-all="true">
                    <cc:remove-headers>
                        <cc:remove-header name="content-length"/>
                    </cc:remove-headers>
                    <cc:add-headers>
                        <cc:add-header name="Authorization" value="Bearer @{props['inAccessToken']}"/>
                        <cc:add-header name="Accept" value="application/json"/>
                        <cc:add-header name="Content-Type" value="application/json"/>
                    </cc:add-headers>
                </cc:set-headers>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CallApi_161"/>
        </cc:async-mediation>
        <cc:async-mediation id="Initialize_135">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>if (props['inDataLocation'] != 'message') {&#xD;
	message.setMessage(vars[props.inDataLocation].source, vars[props.inDataLocation].mimeType);&#xD;
}</cc:expression>
                </cc:eval>
                <cc:xslt-plus id="XsltPlus" output-mimetype="text/plain" url="xslt/ssk135/SSK135_GetOpenTag.xsl"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['outRootOpenTag135'] = parts[0].text;</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Initialize_135"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Initialize_135" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'GetRootOpenTag Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while parsing the input data for a root tag.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="''"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
        <cc:set name="inEntityName" value="'rootpart__GetRootOpenTag.xml'"/><cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:local-out id="Call_HandleError_Initialize_138" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'GetRootCloseTag Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while parsing the input data for a root tag.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="''"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="''"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'rootpart__GetRootCloseTag.xml'"/>
        <cc:set name="inErrorLogOverrideMap" value="props['inErrorLogOverrideMap']"/></cc:local-out>
        <cc:async-mediation id="Initialize_138">
            <cc:steps>
                <cc:eval id="MoveVarToMsg">
                    <cc:expression>if (props['inDataLocation'] != 'message') {&#xD;
	message.setMessage(vars[props.inDataLocation].source, vars[props.inDataLocation].mimeType);&#xD;
}</cc:expression>
                </cc:eval>
                <cc:xslt-plus id="XsltPlus" output-mimetype="text/plain" url="xslt/ssk138/SSK138_GetCloseTag.xsl"/>
                <cc:eval id="SetValues">
                    <cc:expression>props['outRootCloseTag138'] = parts[0].text;</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Initialize_138"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Request_161" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_Debug_Body_161" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localEndpoint161'"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
        </cc:local-out>
        <cc:local-out id="Call_Debug_Body_161" store-message="none" execute-when="props['inDebugMode'] &amp;&amp; (['POST','PUT','PATCH','DELETE'] contains props['inHttpMethod'].trim().toUpperCase())" routes-response-to="ApiCatch_161" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'CallRestApi__RequestBody.json'"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
        </cc:local-out>
        <cc:local-in id="SetExternalIntegrationHeaders" routes-to="Initialize_119" access="public" icon="icons/SetExternalIntegrationHeaders.png">
        	<cc:parameter default="'set'" documentation="Action to take on the HTTP headers - setting the header values, or perhaps clearing them when making mixed HTTP/SOAP calls between Workday and vendor APIs." name="inAction" required="true" type="string" validation="['set','clear'] contains props['inAction'].trim().toLowerCase()"/>
        	<cc:parameter documentation="Optional value to be set to the wd-external-request-id HTTP header.  This request-id is more likely to vary on a call-by-call basis, and is therefore more appropriately managed through the SOAP-related SSK components directly." name="inHeaderRequestId" required="false" type="string"/>
        	<cc:parameter documentation="Value to be set to the wd-external-application-id HTTP header." name="inHeaderApplicationId" required="false" type="string"/>
        	<cc:parameter documentation="Value to be set to the wd-external-originator-id HTTP header." name="inHeaderOriginatorId" required="false" type="string"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
        	<cc:parameter default="'primary'" documentation="Controls whether the message is logged to the primary or secondary logs.  Sub-assembly processing and validation messages will still go to the primary log, but data-level messages will be directed per this configuration.  Note that the Extra Column configuration of the default secondary log is still coded and therefore assumed." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
        	<cc:out-parameter documentation="A context property picked up by other SSK components supporting the &quot;wd-external-request-id&quot; SOAP header and enabling a set-once-and-reuse pattern for the integration to not redefine the value on every component call.  Since this will be set as the default though on that component input parameter, you will have to pass an empty value explicitly if you don't want that value to be set.  Simply removing the input parameter is not enough as the default is still applied by the local-in when the local-out hasn't set the value." name="outRequestIdHeader119"/><cc:out-parameter documentation="A context property picked up by other SSK components supporting the &quot;wd-external-system-id&quot; SOAP header and enabling a set-once-and-reuse pattern for the integration to not redefine the value on every component call.  Since this will be set as the default though on that component input parameter, you will have to pass an empty value explicitly if you don't want that value to be set.  Simply removing the input parameter is not enough as the default is still applied by the local-in when the local-out hasn't set the value." name="outSystemIdHeader119"/><cc:out-parameter documentation="A context property picked up by other SSK components supporting the &quot;wd-external-originator-id&quot; SOAP header and enabling a set-once-and-reuse pattern for the integration to not redefine the value on every component call.  Since this will be set as the default though on that component input parameter, you will have to pass an empty value explicitly if you don't want that value to be set.  Simply removing the input parameter is not enough as the default is still applied by the local-in when the local-out hasn't set the value." name="outOriginatorIdHeader119"/>
        </cc:local-in>
        <cc:async-mediation id="SetHeaders_119" routes-to="ClearHeaders_119" execute-steps-when="'set' == props['inAction'].trim().toLowerCase()">
            <cc:steps>
                <cc:eval id="SetProperties">
                    <cc:expression>if (context.containsProperty('inHeaderRequestId')) {&#xD;
	props['outRequestIdHeader119'] = props['inHeaderRequestId'];&#xD;
}</cc:expression>
                    <cc:expression>if (context.containsProperty('inHeaderApplicationId')) {&#xD;
	props['outApplicationIdHeader119'] = props['inHeaderApplicationId'];&#xD;
}</cc:expression>
                    <cc:expression>if (context.containsProperty('inHeaderOriginatorId')) {&#xD;
	props['outOriginatorIdHeader119'] = props['inHeaderOriginatorId'];&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="ClearHeaders_119" execute-steps-when="'clear' == props['inAction'].trim().toLowerCase()">
            <cc:steps>
                <cc:set-headers id="ClearHeaders">
                    <cc:remove-headers>
                        <cc:remove-header name="wd-external-originator-id"/>
                        <cc:remove-header name="wd-external-application-id"/>
                        <cc:remove-header name="wd-external-request-id"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="RemoveProperties">
                    <cc:expression>foreach (propname : ['outRequestIdHeader119','outApplicationIdHeader119','outOriginatorIdHeader119']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Initialize_119" routes-to="SetHeaders_119" handle-downstream-errors="true">
            <cc:steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Error_119"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_Error_119" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"><cc:set name="inLogMessage" value="'An error occurred in SetExternalIntegrationHeaders'"/><cc:set name="inLogMessageDetail" value="'An error was raised while attempting to ' # props['inAction'] # ' the External SOAP message headers.'"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inExtraLocalIn" value="context.errorComponentId"/><cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : ((context.exception != null) ? context.exception.message : '')"/><cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/><cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/><cc:set name="inIsResetError" value="false"/><cc:set name="inLogTarget" value="props['inLogTarget']"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:local-in id="CreateFlexLogEntry" routes-to="CreateLogEntry_147" access="public" icon="icons/CreateFlexLogEntry.png"><cc:parameter default="props['int0025FlexLog']" documentation="A Java reference to an instance of the FlexLogBean class.  There should only ever be one reference to one instance of this class.  If the WSAR-INF/xslt/ssk147/SSK147_FlexLogs.xml configuration file is properly defined, then SSK will automatically create that instance and store the reference to the &quot;int0025FlexLog&quot; context property as a part of the SSK initialization." name="inFlexLogBean" required="true" validation="props['inFlexLogBean'] instanceof com.workday.custom.int0025.ssk147.FlexLogBean"/><cc:parameter default="'flex-log'" documentation="Defines the name of the FlexLog to which the entry will be written.  The value corresponds to /int0025:FlexLogs/int0025:FlexLog/@int0025:logName in the WSAR-INF/xslt/ssk147/SSK147_FlexLogs.xml configuration file." name="inLogName" required="true" type="string"/></cc:local-in>
        <cc:local-in id="StoreAllFlexLogs" routes-to="InitializeAndFinalize_StoreAllFlexLogs_147" access="public" icon="icons/StoreAllFlexLogs.png">
            
        <cc:parameter default="props['int0025FlexLog']" name="inFlexLogBean" required="true" validation="props['inFlexLogBean'] instanceof com.workday.custom.int0025.ssk147.FlexLogBean"/></cc:local-in>
        <cc:local-out id="Call_StoreAllFlexLogs" store-message="none" execute-when="context.containsProperty('int0025FlexLog') &amp;&amp; props['int0025FlexLog'] != empty" routes-response-to="Call_StoreLogPrimary" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreAllFlexLogs"/>
        <cc:local-in id="StoreFlexLog" routes-to="BeforeAndAfterStoreLog_147">
            <cc:parameter default="props['int0025FlexLog']" name="inFlexLogBean" required="true" validation="props['inFlexLogBean'] instanceof com.workday.custom.int0025.ssk147.FlexLogBean"/><cc:parameter default="'flex-log'" documentation="...references back to the int0025:FlexLog/@int0025:logKey value from the XML configuration directive.  Identifies the log to which the entry is to be written." name="inLogName" required="true" type="string"/>
        </cc:local-in>
        <cc:local-out id="Call_StoreAllFlexLogs_Error_109" store-message="none" execute-when="context.containsProperty('int0025FlexLog') &amp;&amp; props['int0025FlexLog'] != empty" routes-response-to="Call_StoreLogPrimary_Error_109" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreAllFlexLogs"/>
        <cc:local-out id="Call_StoreAllFlexLogs_GEH" store-message="none" execute-when="context.containsProperty('int0025FlexLog') &amp;&amp; props['int0025FlexLog'] != empty" routes-response-to="Call_StoreLogPrimary_GEH" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreAllFlexLogs"/>
        <cc:async-mediation id="CreateLogEntry_147">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['inFlexLogBean'].writeLogEntry(context);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="FlexLogStats" routes-to="FlexLogStats_147">
            <cc:parameter default="props['int0025FlexLog']" name="inFlexLogBean" required="true" validation="props['inFlexLogBean'] instanceof com.workday.custom.int0025.ssk147.FlexLogBean"/><cc:parameter default="'flex-log'" documentation="...references back to the int0025:FlexLog/@int0025:logKey value from the XML configuration directive.  Identifies the log to which the entry is to be written." name="inLogName" required="true" type="string"/>
        </cc:local-in>
        <cc:local-out id="Call_HandleError_Initialize_Error_149" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Report Comparison Initialization Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while setting up the data structures necessary to difference two reports using the ReportDiff strategy.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="Initialize_149">
            <cc:steps>
                <cc:eval id="InitReportDiffValues">
                    <cc:expression>props['outPropertyNameHistoricIdList149'] = 'globalHistoricIdList';&#xD;
props['outPropertyNameCurrentIdList149'] = 'globalCurrentIdList';</cc:expression>
                </cc:eval>
                <cc:custom id="InitDataStructures" ref="SSK149DataStructureBean"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Initialize_Error_149"/>
        </cc:async-mediation>
        <cc:local-in id="InitializeReportDiff" routes-to="Initialize_149" access="public" icon="icons/InitializeReportDiff.png">
            
            
            
            <cc:parameter default="'primary'" documentation="In the event of an exception in the Java code, this parameter controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary','secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            
            <cc:out-parameter documentation="The name of the mediation context property that holds the reference to the Java set into which all historic snapshot data records IDs will be parsed and loaded." name="outPropertyNameHistoricIdList149"/>
            <cc:out-parameter documentation="The name of the mediation context property that holds the reference to the Java set into which all current snapshot data records IDs will be parsed and loaded." name="outPropertyNameCurrentIdList149"/>
        </cc:local-in>
        <cc:route id="LoopAllLogs_147">
            <cc:loop-strategy condition="props['localCounter147'] &lt; props['localLogNames147'].length" increment="props['localCounter147'] = props['localCounter147'] + 1" init="props['localCounter147'] = 0"/>
            <cc:sub-route name="StoreLog" routes-to="Call_StoreEachLog_147"/>
        </cc:route>
        <cc:local-in id="Finally_StoreAllFlexLogs_147" routes-to="Teardown_StoreAllFlexLogs_147"/>
        <cc:async-mediation id="Teardown_StoreAllFlexLogs_147">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localLogNames147','localCounter147','localFilesToWriteCounter147','localTotalFilesToWrite147','localRetention147','localLogFilenameForStorage147','localIsDeliverable147','localDocumentTag147','localCountOfDebug147','localCountOfInfo147','localCountOfWarn147','localCountOfError147','localCountOfCritical147','localIsCriticalEntries147','localIsErrorEntries147','localIsWarningEntries147','localIsInfoEntries147','localIsDebugEntries147']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>vars['logStoreResult147'] = null;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:sync-mediation id="InitializeAndFinalize_StoreAllFlexLogs_147" routes-to="LoopAllLogs_147" handle-downstream-errors="true" routes-response-to="Call_Finally_StoreAllFlexLogs_147">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localLogNames147'] = props['inFlexLogBean'].getAllLogNames();</cc:expression>
                </cc:eval></cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_147"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_StoreAllFlexLogs_147" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_StoreAllFlexLogs_147"/>
        <cc:local-out id="Call_StoreEachLog_147" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/StoreFlexLog"><cc:set name="inFlexLogBean" value="props['inFlexLogBean']"/><cc:set name="inLogName" value="props.localLogNames147[props.localCounter147]"/></cc:local-out>
        <cc:async-mediation id="OutputFlexLog_147" routes-to="PIM_FlexLogTag_147">
            <cc:steps>
                <cc:eval id="Setup">
                    <cc:expression>flexLog = props['inFlexLogBean'].getFlexLog(props.inLogName);&#xD;
&#xD;
props['localLogFilenameForStorage147'] = flexLog.getStorageFilename();&#xD;
props['localRetention147'] = flexLog.getRetention();&#xD;
props['localIsDeliverable147'] = flexLog.isDeliverable();&#xD;
props['localDocumentTag147'] = flexLog.getDocumentTag();</cc:expression></cc:eval>
                <cc:store id="StoreFlexLog" output="variable" output-variable="logStoreResult147" input="message" createDocumentReference="false" expiresIn="@{props['localRetention147'] }" title="@{props['localLogFilenameForStorage147']}"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="PIM_FlexLogTag_147" store-message="none" routes-response-to="FlexLogReset_147" endpoint="vm://wcc/PutIntegrationMessage">
            <cc:set name="is.event.wid" value="context.containsProperty('int0025EventWID') ? props['int0025EventWID'] : null"/>
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="'Saved FlexLog file to the Integration Event.'"/>
            <cc:set name="is.document.variable.name" value="'logStoreResult147'"/>
            <cc:set name="is.document.file.name" value="props['localLogFilenameForStorage147']"/>
            <cc:set name="is.document.deliverable" value="String.valueOf(props.localIsDeliverable147)"/>
            <cc:set name="is.document.labels" value="props['localDocumentTag147'] != empty ? props['localDocumentTag147'] : null"/>
            <cc:set name="is.message.storage.enabled" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="FlexLogReset_147">
            <cc:steps>
                <cc:eval id="Reset">
                    <cc:expression>foreach (propname : ['localLogFilenameForStorage147','localRetention147','localIsDeliverable147','localDocumentTag147']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_FlexLogStats_147" routes-response-to="Call_Finally_StoreFlexLog_147" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/FlexLogStats"/>
        <cc:local-out id="PIM_Critical_Stats_FlexLog_147" store-message="none" execute-when="props['localIsCriticalEntries147']" routes-response-to="PIM_Error_Stats_FlexLog_147" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'CRITICAL'"/>
            <cc:set name="is.message.summary" value="props['localCountOfCritical147'] + ' critical error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Error_Stats_FlexLog_147" store-message="none" execute-when="props['localIsErrorEntries147']" routes-response-to="PIM_Warning_Stats_FlexLog_147" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'ERROR'"/>
            <cc:set name="is.message.summary" value="props['localCountOfError147'] + ' error(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Warning_Stats_FlexLog_147" store-message="none" execute-when="props['localIsWarningEntries147']" routes-response-to="PIM_Info_Stats_FlexLog_147" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'WARNING'"/>
            <cc:set name="is.message.summary" value="props['localCountOfWarn147'] + ' warning(s) encountered!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Info_Stats_FlexLog_147" store-message="none" execute-when="props['localIsInfoEntries147']" routes-response-to="PIM_Debug_Stats_FlexLog_147" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'INFO'"/>
            <cc:set name="is.message.summary" value="props['localCountOfInfo147'] + ' informational message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:local-out id="PIM_Debug_Stats_FlexLog_147" store-message="none" execute-when="props['localIsDebugEntries147']" endpoint="vm://wcc/PutIntegrationMessage" propagate-abort="false">
            <cc:set name="is.message.severity" value="'DEBUG'"/>
            <cc:set name="is.message.summary" value="props['localCountOfDebug147'] + ' debug message(s) added!  See attached file for details.'"/>
        </cc:local-out>
        <cc:sync-mediation id="BeforeAndAfterStoreLog_147" routes-to="RouteLogSplit_147" routes-response-to="Call_FlexLogStats_147">
            <cc:request-steps/>
            <cc:response-steps/>
        </cc:sync-mediation>
        <cc:async-mediation id="Teardown_StoreFlexLog_147">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localFilesToWriteCounter147','localTotalFilesToWrite147','localRetention147','localLogFilenameForStorage147','localIsDeliverable147','localDocumentTag147','localCountOfDebug147','localCountOfInfo147','localCountOfWarn147','localCountOfError147','localCountOfCritical147','localIsCriticalEntries147','localIsErrorEntries147','localIsWarningEntries147','localIsInfoEntries147','localIsDebugEntries147']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>vars['logStoreResult147'] = null;</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_StoreFlexLog_147" routes-to="Teardown_StoreFlexLog_147"/>
        <cc:local-out id="Call_Finally_StoreFlexLog_147" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_StoreFlexLog_147"/>
        <cc:splitter id="SplitLogToFiles_147">
            <cc:sub-route name="SubRoute" routes-to="OutputFlexLog_147"/>
            <cc:custom-splitter ref="SSK147FlexLogStorageSplitter"/>
        </cc:splitter>
        <cc:route id="RouteLogSplit_147">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inFlexLogBean'].isSplitLogFile(props.inLogName)" route="Multiple"/>
                <cc:choose-route expression="true" route="Single"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Multiple" routes-to="SplitLogToFiles_147"/>
            <cc:sub-route name="Single" routes-to="PrepareLogOutput"/>
        </cc:route>
        <cc:async-mediation id="PrepareLogOutput" routes-to="OutputFlexLog_147">
            <cc:steps>
                <cc:eval id="Setup">
                    <cc:expression>props['inFlexLogBean'].setLogToMessageRootPart(context, props.inLogName);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_MergeResult_107" store-message="none" execute-when="props['inDebugMode']" routes-response-to="FinalizeResults_107" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            
            <cc:set name="inEntitySuffix" value="props.inPathToXsltFile # '_merged'"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
        </cc:local-out>
        <cc:async-mediation id="FlexLogStats_147" routes-to="PIM_Critical_Stats_FlexLog_147">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>flexLog = props['inFlexLogBean'].getFlexLog(props.inLogName);&#xD;
&#xD;
props['localIsCriticalEntries147'] = flexLog.isCriticalEntries();&#xD;
props['localIsErrorEntries147'] = flexLog.isErrorEntries();&#xD;
props['localIsWarningEntries147'] = flexLog.isWarningEntries();&#xD;
props['localIsInfoEntries147'] = flexLog.isInfoEntries();&#xD;
props['localIsDebugEntries147'] = flexLog.isDebugEntries();&#xD;
&#xD;
props['localCountOfDebug147'] = flexLog.getCountOfDebug();&#xD;
props['localCountOfInfo147'] = flexLog.getCountOfInfo();&#xD;
props['localCountOfWarn147'] = flexLog.getCountOfWarn();&#xD;
props['localCountOfError147'] = flexLog.getCountOfError();&#xD;
props['localCountOfCritical147'] = flexLog.getCountOfCritical();</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_147" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'FlexLog Storage Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while committing log data to files. Log details may have been lost due to the error.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_StoreAllFlexLogs_147'"/>
            <cc:set name="inIsAbortOnError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="FlexLogXsltMessages_129" routes-to="Call_CloudLogXSLTMessages_129" execute-steps-when="(props['inLogTarget'].trim().toLowerCase() == 'flexlog') &amp;&amp; (props['localMessages129'] != empty)">
            <cc:steps>
                <cc:eval id="WriteLogEntries">
                    <cc:expression>props['inFlexLogBean'].writeLogEntries(props['localMessages129']);</cc:expression>
                    <cc:expression>props['localMessages129'].clear();</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="FlexLogXsltMessages_107" routes-to="Call_LogXsltMessages_107" execute-steps-when="(props['inLogTargetForXsltMessages'].trim().toLowerCase() == 'flexlog') &amp;&amp; (props['localMessages107'] != empty)">
            <cc:steps>
                <cc:eval id="WriteLogEntries">
                    <cc:expression>props['inFlexLogBean'].writeLogEntries(props['localMessages107']);</cc:expression>
                    <cc:expression>props['localMessages107'].clear();</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="FlexLogXsltMessages_118" execute-steps-when="(props['inLogTargetForXsltMessages'].trim().toLowerCase() == 'flexlog') &amp;&amp; (props['localMessages107'] != empty)">
            <cc:steps>
                <cc:eval id="WriteLogEntries">
                    <cc:expression>props['inFlexLogBean'].writeLogEntries(props['localMessages107']);</cc:expression>
                    <cc:expression>props['localMessages107'].clear();</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="Teardown_162">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localOffset162', 'localEndpoint162']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>foreach (varname : ['queryCache162']) {&#xD;
	vars[varname] = null;&#xD;
}</cc:expression>
                </cc:eval>
                <cc:set-headers id="ClearHeaders" output="message" clear-all="true">
                    <cc:remove-headers>
                        <cc:remove-header name="content-length"/>
                        <cc:remove-header name="Authorization"/>
                        <cc:remove-header name="Accept"/>
                        <cc:remove-header name="Content-Type"/>
                        <cc:remove-header name="x-validate-only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_162" routes-to="Teardown_162"/>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_162" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'WQL Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred preparing the WQL API request.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_162'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="props['inQuerySource']"/>
            <cc:set name="inTargetName" value="props['inQuerySourceId']"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_162" routes-to="Call_PrepareQuery_162" handle-downstream-errors="false" routes-response-to="Call_Finally_162">
            <cc:request-steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['outTotalRecordCount162'] = 0;</cc:expression>
                    <cc:expression>props['localOffset162'] = props['inOffset'];</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps/>
            <cc:send-error id="Error" routes-to="Call_HandleError_InitializeAndFinalize_162"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_162" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_162"/>
        <cc:local-in id="WQL" routes-to="InitializeAndFinalize_162" access="public" icon="icons/WQL.png">
            <cc:parameter default="props['outAccessToken160']" documentation="Authorization header as returned by SSK Component 160 - GetAccessToken." name="inAccessToken" required="true" type="string"/>
            <cc:parameter default="props['int0025RestBaseApiEndpoint']" documentation="The base URL for the Workday REST API endpoint.  For Extend, the endpoint value would be 'https://api.workday.com' for all tenants (the tenant is encoded into the access token).  Whereas, for a tenanted endpoint, the value might look like 'https://wcpdev-services1.wd101.myworkday.com/ccx/api' for a WCPDEV tenant, or 'https://wd5-impl-services1.workday.com/ccx/api' for an IMPL tenant in WD5." name="inGatewayEndpoint" required="true" type="string"/>
            <cc:parameter default="(props['int0025RestProvider'] == 'tenant') ? '/wql/v1/&lt;tenant>/data' : '/wql/v1/data'" documentation="The relative URI to be combined with the inGatewayEndpoint value to create the full REST API URL to be executed.  Note that '&lt;tenant>' will be substitution-replaced by the current tenant context.  Since WQL supports both GET and POST methods and there is no performance difference in the versions, this component exclusively uses POST to support potentially longer expressions.  Therefore, the inApiPath should not include the '?query=' querystring." name="inApiPath" required="true" type="string"/>            
            <cc:parameter default="'message'" documentation="Where to find the WQL statement to be executed.  Valid values include 'message', 'variable' and 'property'." name="inQuerySource" required="true" type="string" validation="['message', 'variable', 'property'] contains props['inQuerySource'].trim().toLowerCase()"/>            
            <cc:parameter documentation="The name of the Mediation Variable or MediationContext Property where the WQL query can be found to be executed.  This parameter is not needed if the inQuerySource parameter is 'message'." name="inQuerySourceId" required="['variable', 'property'] contains props['inQuerySource'].trim().toLowerCase()" type="string" validation="(((props['inQuerySource'] == 'message') &amp;&amp; (props['inQuerySourceId'] == empty)) ||&#xD;&#xA;&#x9;((props['inQuerySource'] == 'variable') &amp;&amp; (vars.isVariable(props.inQuerySourceId))) ||&#xD;&#xA;&#x9;((props['inQuerySource'] == 'property') &amp;&amp; (context.containsProperty(props.inQuerySourceId))))"/>
            <cc:parameter default="false" documentation="This parameter indicates if the WQL query referenced by inQuerySource and inQuerySourceId is ready to be used as the body of the POST API call, or if it is just a raw, plain text query that requires formatting to the JSON object required by the WQL resource.  The default assumes that the value is a raw query and will format it to the object." name="inQuerySourceIsBodyReady" required="true" type="boolean"/>
            <cc:parameter default="10000" documentation="The number of records to retrieve in a single API request." name="inLimit" required="true" type="integer" validation="props['inLimit'] > 0 &amp;&amp; props['inLimit'] &lt;= 10000"/>
            <cc:parameter default="0" documentation="The number of records to skip before beginning selection for the API request." name="inOffset" required="true" type="integer" validation="props['inOffset'] >= 0"/>
            <cc:parameter default="true" documentation="Retrieves all records regardless of max count or page sizes." name="inIsRetrieveAll" required="true" type="boolean"/>
            <cc:parameter default="'message'" documentation="How the REST results are returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="false" documentation="Either return the JSON response from WQL directly, or convert it to XML with JsonToXml first." name="inReturnResultsAsXml" required="false" type="boolean"/>
            <cc:parameter default="'primary'" documentation="In the event of an API error from the tenant, this parameter controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>            
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the API request and response are output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
            <cc:parameter default="context.containsProperty('outCloudLogFieldOverrideMap145') ? props['outCloudLogFieldOverrideMap145'] : null" documentation="This parameter provides the opportunity to specify a Java HashMap from a context property to replace the error values being reported internally by the component.  The map is keyed by the attribute name of the SSK141 HandleError input parameter, and the value is a string to be used in place of the SSK103 default.  If the map is not provided, or if a map is given but does not contain a key for the logged parameter, then the SSK103 default behavior applies.  If only a single value is desired to be changed from the out-of-the-box behavior, then a map with a single entry could be provided.  In some cases, the logged value is not available to be override, e.g. inLocalIn or inLogLevel when there are hard errors." name="inErrorLogOverrideMap" required="false"/>
        	<cc:out-parameter documentation="The total possible number of records in the tenant.  This is not necessarily the number of records being returned by the component depending on the calling parameterization." name="outTotalRecordCount162"/>
        </cc:local-in>
        <cc:splitter id="ImportRequestArchivesSplitter_118" no-split-message-error="false">
            <cc:sub-route name="ProcessFile" routes-to="ImportRequestsSplitter_Catch_118"/>
            <cc:xml-stream-splitter xpath="/*/*"/>
        </cc:splitter>
        <cc:local-out id="Call_DebugAfter_129" store-message="none" execute-when="props['inDebugMode']" routes-response-to="FlexLogXsltMessages_129" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="(props['inReturnResults'] == 'message') ? 'message' : 'variable'"/>
            <cc:set name="inTargetName" value="(props['inReturnResults'] == 'message') ? null : props['inReturnResults']"/>
            <cc:set name="inEntityName" value="(props['inReturnResults'] == 'message') ? 'rootpart.xml' : (props['inReturnResults'] # '.xml')"/>
            <cc:set name="inEntitySuffix" value="''"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
        </cc:local-out>
        <cc:local-out id="Call_LogXsltMessages_105" store-message="none" execute-when="props['localMessages105'] != empty" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CloudLogXSLTMessages">
            <cc:set name="inMessages" value="props['localMessages105']"/>
            <cc:set name="inIsClearMessages" value="true"/>
            <cc:set name="inMinLogLevel" value="'debug'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
        </cc:local-out>
        <cc:async-mediation id="LogChainFilesSort_136" routes-to="Call_Debug_SortedChains_136">
            <cc:steps>
                <cc:xslt-plus id="FilterEventDocuments" output-mimetype="text/xml" url="xslt/ssk136/SSK136_DocumentFilter.xsl"/>
                <cc:xslt-plus id="SortDocuments" output-mimetype="text/xml" url="xslt/ssk136/SSK136_DocumentSort.xsl"/>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_SortedChains_136" store-message="none" execute-when="props['inDebugMode']" routes-response-to="DocumentAccessor_136" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'GetEventDocuments__SortedChainFiles136.xml'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:async-mediation id="HandleNoResults_115" routes-to="Call_Finally_NoFiles_115">
            <cc:steps>
                <cc:write id="WriteEmptyRoot" output-mimetype="text/xml">
                    <cc:message>
                        <cc:text>&lt;?xml version='1.0' encoding='UTF-8'?>&#xD;
&lt;DISRoot xmlns:tdf=&quot;urn:com.workday/tdf&quot;/></cc:text>
                    </cc:message>
                </cc:write></cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Response_162" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'Response__WQL-offset-' + props['localOffset162'] + '.json'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:http-out id="CallApi_162" store-message="none" routes-response-to="Call_Debug_Response_162" endpoint="@{props['localEndpoint162']}" http-method="POST">
        </cc:http-out>
        <cc:local-out id="Call_HandleError_CallApi_162" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'WQL Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred calling the WQL API.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;props['inClientId']"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraErrorCode" value="(context.containsProperty('http.response.code')) ? (String.valueOf(props['http.response.code'])) : ((context.errorCode != null) ? String.valueOf(context.errorCode) : '')"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_162'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'Response__WQL-offset-' + props['localOffset162'] + '-error.json'"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
        </cc:local-out>
        <cc:async-mediation id="ApiCatch_162" routes-to="CallApi_162" handle-downstream-errors="true">
            <cc:steps>
                <cc:set-headers id="SetHeaders" output="message" clear-all="true">
                    <cc:remove-headers>
                        <cc:remove-header name="content-length"/>
                    </cc:remove-headers>
                    <cc:add-headers>
                        <cc:add-header name="Authorization" value="Bearer @{props['inAccessToken']}"/>
                        <cc:add-header name="Accept" value="application/json"/>
                        <cc:add-header name="Content-Type" value="application/json"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:copy id="CopyCacheToMsg" output-mimetype="application/json" input="variable" input-variable="queryCache162"/>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CallApi_162"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Request_162" store-message="none" execute-when="props['inDebugMode']" routes-response-to="ApiCatch_162" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localEndpoint161'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_BuildQuery_162" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'WQL Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred preparing the WQL API request.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_162'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localEndpoint162'"/>
        </cc:local-out>
        <cc:async-mediation id="BuildQuery_162" routes-to="Call_Debug_Request_162">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>if (props['inApiPath'].toLowerCase().contains('&lt;tenant>')) {&#xD;
	tenant = props['cc.customer.id'];&#xD;
	props['inApiPath'] = props['inApiPath'].replace('&lt;tenant>', tenant);&#xD;
}</cc:expression>
                    <cc:expression>props['localEndpoint162'] = props.inGatewayEndpoint # (props['inApiPath'].startsWith('/') ? props.inApiPath : ('/' # props.inApiPath)) # '?offset=' + props['localOffset162'] + '&amp;limit=' + props['inLimit'];</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_BuildQuery_162"/>
        </cc:async-mediation>
        <cc:local-in id="NextPage_162" routes-to="BuildQuery_162"/>
        <cc:local-out id="Call_SplitArray_All_162" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/SplitArray_162"/>
        <cc:local-out id="Call_NextPageAgain_162" store-message="none" routes-response-to="Call_SplitArray_All_162" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/NextPage_162"/>
        <cc:route id="RetrieveRestOfPages_162">
            <cc:loop-strategy condition="props['localOffset162'] &lt; props['outTotalRecordCount162']" increment="props['localOffset162'] = props['localOffset162'] + props['inLimit']"/>
            <cc:sub-route name="FetchPage" routes-to="Call_NextPageAgain_162"/>
        </cc:route>
        <cc:local-in id="All_162" routes-to="RetrieveRestOfPages_162">
            <cc:parameter default="'json'" name="inTargetMimeType162" required="true" type="string" validation="['json', 'xml'] contains props['inTargetMimeType162'].trim().toLowerCase()"/>
        </cc:local-in>
        <cc:local-out id="Call_Aggregate_Collate_162" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/AggregateJson_162">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:splitter id="JsonSplitter_162" no-split-message-error="false">
            <cc:sub-route name="Process" routes-to="Call_Aggregate_Collate_162"/>
            <cc:json-splitter json-path="$.data[*]"/>
        </cc:splitter>
        <cc:local-in id="SplitArray_162" routes-to="JsonSplitter_162"/>
        <cc:aggregator id="JsonAggregator_162" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:json-collater output-mimetype="application/json"/>
        </cc:aggregator>
        <cc:local-in id="AggregateJson_162" routes-to="JsonAggregator_162">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_NextPage_162" store-message="none" routes-response-to="ResponseTotal_162" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/NextPage_162"/>
        <cc:async-mediation id="ResponseTotal_162" routes-to="ContinueRetrieval_162">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['outTotalRecordCount162'] = (int)(json.numberAtJsonPathWithDefault('$.total', parts[0], 0));</cc:expression>
                    <cc:expression>props['localOffset162'] = props['localOffset162'] + props['inLimit'];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="ContinueRetrieval_162">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsRetrieveAll'] &amp;&amp; (props['outTotalRecordCount162'] > props['inLimit'])" route="RetrieveAll"/>
                <cc:choose-route expression="true" route="CurrentOnly"/>
            </cc:mvel-strategy>
            <cc:sub-route name="RetrieveAll" routes-to="Call_SplitArray_Single_162"/>
            <cc:sub-route name="CurrentOnly" routes-to="FormatResults_162"/>
        </cc:route>
        <cc:local-out id="Call_HandleError_FormatResults_162" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'JSON Result Reformat Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;('An error occurred while moving the JSON results from the data array to the document root..')"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_162'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'results.json'"/>
        </cc:local-out>
        <cc:async-mediation id="FormatResults_162" routes-to="FinalizeResults_All_162">
            <cc:steps>
                <cc:json-transformer id="JsonTransformer" output-mimetype="application/json">
                    <cc:json-mapping json-path="$">json.arrayAtJsonPath('$.data', parts[0])</cc:json-mapping>
                </cc:json-transformer>
            </cc:steps>
            <cc:send-error id="Error" routes-to="Call_HandleError_FormatResults_162"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_FinalizeResults_All_162" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;('An error occurred while copying the results from the message rootpart to variable '# props['inReturnResults'] #'.')"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_162'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            
        <cc:set name="inEntityName" value="props['inReturnResultsAsXml'] ? 'results.xml' : 'results.json'"/></cc:local-out>
        <cc:async-mediation id="FinalizeResults_All_162">
            <cc:steps>
                <cc:json-to-xml execute-when="props['inReturnResultsAsXml']" id="Convert" output="message" output-mimetype="text/xml"/>
                <cc:eval execute-when="props['inReturnResults'] != 'message'" id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="Error" routes-to="Call_HandleError_FinalizeResults_All_162"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Aggregate_Batch_162" store-message="none" routes-response-to="FinalizeResults_All_162" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/AggregateJson_162">
            <cc:set name="inCollate" value="false"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:local-out id="RetrieveAll_162" store-message="none" routes-response-to="Call_Aggregate_Batch_162" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/All_162">
            <cc:set name="inTargetMimeType162" value="props['inReturnResultsAsXml'] ? 'xml' : 'json'"/>
        </cc:local-out>
        <cc:local-out id="Call_SplitArray_Single_162" store-message="none" routes-response-to="RetrieveAll_162" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/SplitArray_162"/>
        <cc:async-mediation id="Teardown_163">
            <cc:steps>
                <cc:set-headers id="ClearRootPartHeaders" output="rootpart" clear-all="false">
                    <cc:remove-headers>
                        <cc:remove-header name="Content-Disposition"/>
                        <cc:remove-header name="Content-Type"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:set-headers id="ClearMessageHeaders" output="message" clear-all="false">
                    <cc:remove-headers>
                        <cc:remove-header name="Authorization"/>
                        <cc:remove-header name="Accept"/>
                        <cc:remove-header name="Content-Type"/>
                        <cc:remove-header name="X-Validate-Only"/>
                    </cc:remove-headers>
                    <cc:add-headers/>
                </cc:set-headers>
                <cc:eval id="CleanUp">
                    <cc:expression>foreach (propname : ['localEndpoint163','localMimeType163']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
                    <cc:expression>message.removeAllAttachments();</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_163" routes-to="Teardown_163"/>
        <cc:local-out id="Call_HandleError_FinalizeResults_163" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;('An error occurred while copying the JSON results from the message rootpart to variable '# props['inReturnResults'] #'.')"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_163'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'StoreExtendAttachment__Response.json'"/>
        </cc:local-out>
        <cc:async-mediation id="FinalizeResults_163">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['outAttachmentWID163'] = json.stringAtJsonPathWithDefault('$.id', parts[0], 'NOT_FOUND');</cc:expression>
                </cc:eval>
                <cc:eval execute-when="props['inReturnResults'] != 'message'" id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_FinalizeResults_163"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Response_163" store-message="none" execute-when="props['inDebugMode']" routes-response-to="FinalizeResults_163" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'StoreExtendAttachment__Response.json'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:http-out id="CallApi_163" store-message="none" routes-response-to="Call_Debug_Response_163" endpoint="@{props['localEndpoint163']}" http-method="POST">
        </cc:http-out>
        <cc:local-out id="Call_HandleError_CallApi_163" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'Extend Attachment API Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred calling the Extend API gateway for the attachment endpoint.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;props['inClientId']"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_163'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'StoreExtendAttachment__Request.json'"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
        </cc:local-out>
        <cc:async-mediation id="ApiCatch_163" routes-to="CallApi_163" handle-downstream-errors="true">
            <cc:steps>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_CallApi_163"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Request_163" store-message="none" execute-when="props['inDebugMode']" routes-response-to="ApiCatch_163" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localEndpoint163'"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_ComposeBody_163" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'Error Composing Attachment Request'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred configuring the message rootpart and first message attachment, parts[1].'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;props['inClientId']"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_163'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="props['inDataLocation'] == 'message' ? 'message' : 'variable'"/>
            <cc:set name="inTargetName" value="props['inDataLocation'] == 'message' ? '' : props['inDataLocation']"/>
            <cc:set name="inEntityName" value="'Attachment_Request_formdata_data.json'"/>
        </cc:local-out>
        <cc:async-mediation id="ComposeBody_163" routes-to="Call_Debug_Request_163" handle-downstream-errors="true">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>if (props['inDataLocation'] == 'message') {&#xD;
	//explicitly set to rootPart.  message.setMessage doesn't accomplish the necessary outbound request&#xD;
	message.setRootPart(parts[0].source, parts[0].mimeType);&#xD;
}</cc:expression>
                    <cc:expression>if (props['inDataLocation'] != 'message') {&#xD;
	message.setRootPart(vars[props.inDataLocation].source, vars[props.inDataLocation].mimeType);&#xD;
}</cc:expression>
                </cc:eval>
                <cc:set-headers id="SetRootPartHeaders" output="rootpart" clear-all="false">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="Content-Disposition" value="form-data; name=&quot;data&quot;"/>
                        <cc:add-header name="Content-Type" value="application/json"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:set-headers id="SetMessageHeaders" output="message" clear-all="false">
                    <cc:remove-headers>
                        <cc:remove-header name="content-length"/>
                    </cc:remove-headers>
                    <cc:add-headers>
                        <cc:add-header name="Authorization" value="Bearer @{props['inAccessToken']}"/>
                        <cc:add-header name="Accept" value="*/*"/>
                        <cc:add-header name="Content-Type" value="multipart/form-data"/>
                        <cc:add-header name="x-validate-only" value="@{props['inValidateOnly'] ? 1 : 0}"/>
                    </cc:add-headers>
                </cc:set-headers>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ComposeBody_163"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_ComposeAttachment_163" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'Attachment Encoding Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred base64 encoding the attachment data to parts[1].'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;props['inClientId']"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_163'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="false"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'AttachmentContent'"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
        </cc:local-out>
        <cc:async-mediation id="ComposeAttachment_163" routes-to="ComposeBody_163">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>if (props['inFileLocation'] != 'message') {&#xD;
	message.addAttachment(vars[props.inFileLocation].source, vars[props.inFileLocation].mimeType);&#xD;
} else {&#xD;
	message.addAttachment(parts[0].source, parts[0].mimeType);&#xD;
}</cc:expression>
                    <cc:expression>props['localMimeType163'] = message.getMimeType(1);</cc:expression>
                </cc:eval>
                <cc:set-headers id="SetAttachmentHeaders" output="attachment" output-attachment-index="0" clear-all="false">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="Content-Disposition" value="@{'form-data; name=&quot;attachmentContent&quot;; filename=&quot;' # props['inFilename'] # '&quot;'}"/>
                        <cc:add-header name="Content-Type" value="@{props['localMimeType163']}"/>
                    </cc:add-headers>
                </cc:set-headers>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_ComposeAttachment_163"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_163" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'StoreExtendAttachment Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred preparing the Extend API gateway request.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_163'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localEndpoint163'"/>
        </cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_163" routes-to="ComposeAttachment_163" handle-downstream-errors="false" routes-response-to="Call_Finally_163">
            <cc:request-steps>
                <cc:set-headers execute-when="context.containsProperty('inIsMeta') &amp;&amp; props['inIsMeta']" id="SetHeadersMeta" clear-all="false">
                    <cc:remove-headers/>
                    <cc:add-headers>
                        <cc:add-header name="wd-metadata-api-version" value="v1"/>
                    </cc:add-headers>
                </cc:set-headers>
                <cc:eval id="InitValues">
                    <cc:expression>props['localEndpoint163'] = props.inGatewayEndpoint # (props['inApiPath'].startsWith('/') ? props.inApiPath : ('/' # props.inApiPath));</cc:expression>
                </cc:eval>
            </cc:request-steps>
            <cc:response-steps>
            </cc:response-steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_163"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_163" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_163"/>
        <cc:local-in id="StoreExtendAttachment" routes-to="InitializeAndFinalize_163" access="public" icon="icons/StoreExtendAttachment.png">
            <cc:parameter default="props['outAccessToken160']" documentation="Authorization header as returned by SSK Component 160 - GetAccessToken.  That token must have been generated from the Workday Extend token endpoint." name="inAccessToken" required="true" type="string" validation="props['int0025RestProvider'] == 'extend'"/>
            <cc:parameter default="props['int0025RestBaseApiEndpoint']" documentation="The base URL for the Workday Extend API Gateway.  This component is specific to Workday Extend and the Model Level Component Attachment Objects.  Use of this component with the tenanted REST endpoint will result in errors." name="inGatewayEndpoint" required="true" type="string"/>
            <cc:parameter documentation="The relative URI to be combined with the inGatewayEndpoint value to create the full REST API URL to be executed." name="inApiPath" required="true" type="string"/>
            <cc:parameter default="'message'" documentation="This is where the data portion of the payload content can be found.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found.  The mime-type will be inferred from the message/variable, though it should be application/json.  The contents of the location should be a JSON object ready to compose the POST request.  The &quot;file&quot; attribute in the JSON should be &quot;cid:attachmentContent&quot;, e.g. {&quot;file&quot;: &quot;cid:attachmentContent&quot;, your other fields/values...}." name="inDataLocation" required="true" type="string" validation="props['inDataLocation'] != props['inFileLocation']"/>
            <cc:parameter default="'message'" documentation="This is where the binary portion of the payload content can be found for the multi-part message.  This is the actual file content being stored to the attachment.  If the value is &quot;message&quot;, then the message root will be used as the data source.  Otherwise, the name will be interpreted as a variable name where the data can be found.  The mime-type will be inferred from the message/variable." name="inFileLocation" required="true" type="string" validation="props['inDataLocation'] != props['inFileLocation']"/>
            <cc:parameter name="inFilename" required="true" type="string"/>
            <cc:parameter default="false" name="inIsMeta" type="boolean"/>
            <cc:parameter default="'message'" documentation="How the REST results are returned to the caller.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter default="'primary'" documentation="In the event of an API error from the tenant, this parameter controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            <cc:parameter default="props['int0025IsValidationMode']" documentation="Controls whether or not the API request is actually executed against the tenant or is only validated for potential errors." name="inValidateOnly" required="true" type="boolean"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the API request and response are output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="false" documentation="Indicates where this component is being invoked while executing on a child thread, or on the main thread.  When used in the sub-assembly indicated by the &quot;parallel.processing.worker.endpoint&quot; parameter on a ParallelSubRoutine component, or in the sub-assembly indicated by the &quot;inParallelPageProcessorEndpoint&quot; parameter on SSK104 CallSoapPaged, or in the sub-assembly indicated by the &quot;is.paged.get.process.endpoint&quot; of the PagedGet component, this parameter should be set to true so that thread-safe logging can be used.  When executing from a child thread, Debug output is disabled due to thread-safety." name="inIsChildThreadContext" required="true" type="boolean"/>
            <cc:parameter default="context.containsProperty('outCloudLogFieldOverrideMap145') ? props['outCloudLogFieldOverrideMap145'] : null" documentation="This parameter provides the opportunity to specify a Java HashMap from a context property to replace the error values being reported internally by the component.  The map is keyed by the attribute name of the SSK141 HandleError input parameter, and the value is a string to be used in place of the SSK103 default.  If the map is not provided, or if a map is given but does not contain a key for the logged parameter, then the SSK103 default behavior applies.  If only a single value is desired to be changed from the out-of-the-box behavior, then a map with a single entry could be provided.  In some cases, the logged value is not available to be override, e.g. inLocalIn or inLogLevel when there are hard errors." name="inErrorLogOverrideMap" required="false"/>
            <cc:out-parameter name="outAttachmentWID163"/>
        </cc:local-in>
        <cc:local-out id="SSK152_ConfigurationSetup" store-message="none" routes-response-to="Call_InitializeFrameworkThenRunMain" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/ConfigurationSetup" clone-request="false" propagate-abort="true" unset-properties="false"><cc:set name="inApiVersion" value="'v44.0'"/><cc:set name="inServiceNameGeneral" value="'INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - General'"/><cc:set name="inServiceNameLogPrimary" value="'INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - Primary Logging'"/><cc:set name="inServiceNameLogSecondary" value="'INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - Secondary Logging'"/><cc:set name="inServiceNameFunctional" value="'INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - Functional'"/><cc:set name="inServiceNameMessageQueue" value="'INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - Message Queue'"/><cc:set name="inServiceNameExtend" value="'INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - Workday Extend'"/><cc:set name="inServiceNameRest" value="'INT0025 CheckWorkRights VisaCheck Inbound - Attribute and Map Service - Workday REST'"/><cc:set name="inServiceNameListener" value="'INT0025 CheckWorkRights VisaCheck Inbound - Listener Service'"/></cc:local-out>
        <cc:local-in id="ConfigurationSetup" routes-to="Foundation_152" access="public" icon="icons/ConfigurationSetup.png">
        	<cc:parameter default="'v39.0'" documentation="Value to use throughout the rest of the integration for the Workday SOAP API version" name="inApiVersion" required="true" type="string"/>
        	<cc:parameter documentation="The name of the Attribute/Map Service that configures the General SSK aspects." name="inServiceNameGeneral" required="false" type="string"/>
        	<cc:parameter documentation="The name of the Attribute/Map Service that configures the SSK Functional aspects." name="inServiceNameFunctional" required="false" type="string"/>
        	<cc:parameter documentation="The name of the Attribute/Map Service that configures the SSK MessageQueue details." name="inServiceNameMessageQueue" required="false" type="string"/>
        	<cc:parameter documentation="The name of the Attribute/Map Service that configures the SSK Primary Log aspects." name="inServiceNameLogPrimary" required="false" type="string"/>
        	<cc:parameter documentation="The name of the Attribute/Map Service that configures the SSK Secondary Log aspects." name="inServiceNameLogSecondary" required="false" type="string"/>
        	<cc:parameter documentation="The name of the Attribute/Map Service that configures the SSK Workday REST functionality for use with Workday Extend." name="inServiceNameExtend" required="false" type="string"/>
        	<cc:parameter documentation="The name of the Attribute/Map Service that configures the SSK Workday REST functionality for use with the Workday tenanted services outside of / without Workday Extend." name="inServiceNameRest" required="false" type="string"/><cc:parameter documentation="The name of the Attribute/Map Service that configures the SSK Listener Service accommodations." name="inServiceNameListener" required="false" type="string"/>
       	</cc:local-in>
        <cc:local-out id="PIM_ConfigurationError_152" routes-response-to="FoundationError_152" endpoint="vm://wcc/PutIntegrationMessage"><cc:set name="is.message.severity" value="'CRITICAL'"/><cc:set name="is.message.summary" value="'SSK Configuration Setup Failed!'"/><cc:set name="is.message.detail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/></cc:local-out>
        <cc:async-mediation id="FoundationError_152">
            <cc:steps>
                <cc:eval id="Abort">
                    <cc:expression>context.setAbort(true);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_Filter_110" store-message="none" execute-when="props['inDebugMode']" routes-response-to="Call_Debug_FilteredDocuments_110" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'localXslt110'"/><cc:set name="inEntityName" value="'localXslt110.xsl'"/>
        </cc:local-out>
        <cc:local-in id="PrepareQuery_162" routes-to="ComposeQuery_162">
            <cc:parameter default="'json'" name="inTargetMimeType162" required="true" type="string" validation="['json', 'xml'] contains props['inTargetMimeType162'].trim().toLowerCase()"/>
        </cc:local-in>
        <cc:async-mediation id="ComposeQuery_162" routes-to="Call_Debug_QueryBody_162">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>contentType = (props['inQuerySourceIsBodyReady']) ? 'application/json' : 'text/plain';&#xD;
if (props['inQuerySource'] == 'variable') {&#xD;
	message.setMessage(vars[props.inQuerySourceId].source, contentType);&#xD;
} else if (props['inQuerySource'] == 'property') {	&#xD;
	message.setMessagePart(0, contentType, context.getProperty(props.inQuerySourceId));&#xD;
}</cc:expression>
                    <cc:expression>if (props['inQuerySourceIsBodyReady']) {&#xD;
	vars.setVariable('queryCache162', parts[0].source, parts[0].mimeType);&#xD;
}</cc:expression>
                </cc:eval>
                <cc:write execute-when="!props['inQuerySourceIsBodyReady']" id="SourceToCache" output="variable" output-mimetype="application/json" output-variable="queryCache162">
                    <cc:message>
                        <cc:text>{&quot;query&quot;: &quot;</cc:text>
                        <cc:message-content/>
                        <cc:text>&quot;}</cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_QueryBody_162" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug">
            <cc:set name="inTargetType" value="'variable'"/>
            <cc:set name="inTargetName" value="'queryCache162'"/>
            <cc:set name="inEntityName" value="'WQL-Query.json'"/><cc:set name="inIsChildThreadContext" value="false"/>
        </cc:local-out>
        <cc:local-out id="Call_PrepareQuery_162" store-message="none" routes-response-to="Call_NextPage_162" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/PrepareQuery_162"/>
        <cc:route id="RouteOnHttpMethod_161">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsPaginatedGet']" route="Paginated GET"/>
                <cc:choose-route expression="true" route="All Others"/>
            </cc:mvel-strategy>
            <cc:sub-route name="Paginated GET" routes-to="InitializePagination_161"/>
            <cc:sub-route name="All Others" routes-to="Call_Endpoint_NoPagination_161"/>
        </cc:route>
        <cc:local-out id="Call_HandleError_BuildQuery_161" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'REST API Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;'An error occurred preparing the REST API request.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_161'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'property'"/>
            <cc:set name="inTargetName" value="'localEndpoint161'"/>
        </cc:local-out>
        <cc:async-mediation id="BuildQuery_161" routes-to="Call_Debug_Request_161">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localEndpoint161'] = props.inGatewayEndpoint # (props['inApiPath'].startsWith('/') ? props.inApiPath : ('/' # props.inApiPath));</cc:expression>
                    <cc:expression>if (props['inIsPaginatedGet']) {&#xD;
	props['localEndpoint161'] = props['localEndpoint161'] # '?offset=' + props['localOffset161'] + '&amp;limit=' + props['inLimitForPaginatedGet'];&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_BuildQuery_161"/>
        </cc:async-mediation>
        <cc:local-in id="Endpoint_161" routes-to="BuildQuery_161"/>
        <cc:local-out id="Call_Endpoint_NoPagination_161" store-message="none" routes-response-to="FinalizeResults_161" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Endpoint_161"/>
        <cc:local-out id="Call_Endpoint_FirstPage_161" store-message="none" routes-response-to="ResponseTotal_161" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Endpoint_161"/>
        <cc:async-mediation id="InitializePagination_161" routes-to="Call_Endpoint_FirstPage_161">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>props['localOffset161'] = props['inOffsetForPaginatedGet'];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="ResponseTotal_161" routes-to="ContinueRetrieval_161">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>props['outTotalRecordCountForPagination161'] = (int)(json.numberAtJsonPathWithDefault('$.total', parts[0], 0));</cc:expression>
                    <cc:expression>props['localOffset161'] = props['localOffset161'] + props['inLimitForPaginatedGet'];</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:route id="ContinueRetrieval_161">
            <cc:mvel-strategy>
                <cc:choose-route expression="props['inIsRetrieveAllForPaginatedGet'] &amp;&amp; (props['outTotalRecordCountForPagination161'] > props['inLimitForPaginatedGet'])" route="RetrieveAll"/>
                <cc:choose-route expression="true" route="CurrentOnly"/>
            </cc:mvel-strategy>
            <cc:sub-route name="RetrieveAll" routes-to="Call_SplitArray_Single_161"/>
            <cc:sub-route name="CurrentOnly" routes-to="FormatResults_161"/>
        </cc:route>
        <cc:aggregator id="JsonAggregator_161" collate-when="props['inCollate']" force-batch-on-last-message="false" force-batch-when="props['inBatch']">
            <cc:size-batch-strategy batch-size="-1"/>
            <cc:json-collater output-mimetype="application/json"/>
        </cc:aggregator>
        <cc:local-in id="AggregateJson_161" routes-to="JsonAggregator_161">
            <cc:parameter default="true" name="inCollate" required="true" type="boolean"/>
            <cc:parameter default="false" name="inBatch" required="true" type="boolean"/>
        </cc:local-in>
        <cc:local-out id="Call_Aggregate_Collate_161" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/AggregateJson_161">
            <cc:set name="inCollate" value="true"/>
            <cc:set name="inBatch" value="false"/>
        </cc:local-out>
        <cc:splitter id="JsonSplitter_161" no-split-message-error="false">
            <cc:sub-route name="Process" routes-to="Call_Aggregate_Collate_161"/>
            <cc:json-splitter json-path="$.data[*]"/>
        </cc:splitter>
        <cc:local-in id="SplitArray_161" routes-to="JsonSplitter_161"/>
        <cc:local-out id="Call_SplitArray_All_161" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/SplitArray_161"/>
        <cc:local-out id="Call_NextPageAgain_161" store-message="none" routes-response-to="Call_SplitArray_All_161" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Endpoint_161"/>
        <cc:route id="RetrieveRestOfPages_161">
            <cc:loop-strategy condition="props['localOffset161'] &lt; props['outTotalRecordCountForPagination161']" increment="props['localOffset161'] = props['localOffset161'] + props['inLimitForPaginatedGet']"/>
            <cc:sub-route name="FetchPage" routes-to="Call_NextPageAgain_161"/>
        </cc:route>
        <cc:local-in id="All_161" routes-to="RetrieveRestOfPages_161">
            <cc:parameter default="'json'" name="inTargetMimeType162" required="true" type="string" validation="['json', 'xml'] contains props['inTargetMimeType162'].trim().toLowerCase()"/>
        </cc:local-in>
        <cc:local-out id="Call_SplitArray_Single_161" store-message="none" routes-response-to="RetrieveAll_161" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/SplitArray_161"/>
        <cc:local-out id="RetrieveAll_161" store-message="none" routes-response-to="Call_Aggregate_Batch_161" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/All_161">
            <cc:set name="inTargetMimeType162" value="props['inReturnResultsAsXml'] ? 'xml' : 'json'"/>
        </cc:local-out>
        <cc:local-out id="Call_Aggregate_Batch_161" store-message="none" routes-response-to="FinalizeResults_161" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/AggregateJson_161">
            <cc:set name="inCollate" value="false"/>
            <cc:set name="inBatch" value="true"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_FormatResults_161" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessage')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessage')) : &#xD;&#xA;&#x9;&#x9;'JSON Result Reformat Error'"/>
            <cc:set name="inLogMessageDetail" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogMessageDetail')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogMessageDetail')) : &#xD;&#xA;&#x9;&#x9;('An error occurred while moving the JSON results from the data array to the document root.')"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inLogReferenceId" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inLogReferenceId')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inLogReferenceId')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraRecordNumber" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraRecordNumber')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraRecordNumber')) : &#xD;&#xA;&#x9;&#x9;''"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inExtraSupportData" value="(props['inErrorLogOverrideMap'] != empty &amp;&amp; props['inErrorLogOverrideMap'].containsKey('inExtraSupportData')) ? &#xD;&#xA;&#x9;(props['inErrorLogOverrideMap'].get('inExtraSupportData')) : &#xD;&#xA;&#x9;&#x9;((context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message)"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_161'"/>
            <cc:set name="inLogTarget" value="props['inLogTarget']"/>
            <cc:set name="inIsChildThreadContext" value="props['inIsChildThreadContext']"/>
            <cc:set name="inIsAbortOnError" value="true"/>
            <cc:set name="inIsResetError" value="false"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'results.json'"/>
        </cc:local-out>
        <cc:async-mediation id="FormatResults_161" routes-to="FinalizeResults_161">
            <cc:steps>
                <cc:json-transformer id="JsonTransformer" output-mimetype="application/json">
                    <cc:json-mapping json-path="$">json.arrayAtJsonPath('$.data', parts[0])</cc:json-mapping>
                </cc:json-transformer>
            </cc:steps>
            <cc:send-error id="Error" routes-to="Call_HandleError_FormatResults_161"/>
        </cc:async-mediation>
        <cc:async-mediation id="Teardown_151">
            <cc:steps>
                <cc:eval id="CleanUp">
                    <cc:expression>if (!props['inSystemHasMultipleAttachments']) {&#xD;
	cachedVarName = 'ssk151-' # props.inIntegrationSystemWID;&#xD;
	vars[cachedVarName] = null;&#xD;
}&#xD;
vars['attachmentContent151'] = null;</cc:expression>
						<cc:expression>foreach (propname : ['localIsCached']) {&#xD;
	context.removeProperty(propname);&#xD;
}</cc:expression>
					</cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="Finally_151" routes-to="Teardown_151"/>
        <cc:local-out id="Call_HandleError_Results_Error_151" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Message to Variable Copy Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while copying the Attachment Service File from the message rootpart to variable ' # props.inReturnResults # '.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_151'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inLogTarget" value="props.inLogTarget"/></cc:local-out>
        <cc:async-mediation id="Results_151" continue-after-error="rewind" execute-steps-when="props['inReturnResults'].toString().toLowerCase() != 'message'" handle-downstream-errors="false">
            <cc:steps>
                <cc:eval id="MoveMsgToVar">
                    <cc:expression>vars.setVariable(props.inReturnResults, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_Results_Error_151"/>
        </cc:async-mediation>
        <cc:local-out id="Call_HandleError_GetAndDecodeFile_Error_151" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'Attachment Service File Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while retrieving and decoding the file associated with Attachment Service ' # props.inAttachmentServiceName # '.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_151'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="props['inDebugMode']"/>
        <cc:set name="inTargetType" value="'message'"/><cc:set name="inEntityName" value="'GetIntegrationAttachment-Decode.xml'"/><cc:set name="inLogTarget" value="props.inLogTarget"/></cc:local-out>
        <cc:async-mediation id="GetAndDecodeFile_151" routes-to="Results_151" continue-after-error="rewind" handle-downstream-errors="false">
            <cc:steps>
                <cc:xslt-plus id="GetAttachment" output="message" output-mimetype="text/xml" input="message" url="xslt/ssk151/SSK151_GetAttachmentData.xsl"/>
                <cc:validate-exp id="AttachmentExists">
                    <cc:expression error-number="15100" failure-message="Attachment Service @{props['inAttachmentServiceName']} not found ">parts[0].isXml()</cc:expression>
                    <cc:expression error-number="15101" failure-message="Attachment not found for Attachment Service @{props['inAttachmentServiceName']}">parts[0].xstreamB('/*/*')</cc:expression>
                </cc:validate-exp>
                <cc:copy id="Copy" output="variable" output-mimetype="text/plain" output-variable="attachmentContent151" input-xpath="/root/wd:Attachment_Data/wd:File/text()"/>
                <cc:base64-decode id="DecodeAttachment" output="message" output-mimetype="application/octet-stream" input="variable" input-variable="attachmentContent151"/>
                <cc:eval id="SetMime">
                    <cc:expression>parts[0].setMimeType(props['inReturnResultsMimeType'])</cc:expression>
                </cc:eval>
            </cc:steps>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_GetAndDecodeFile_Error_151"/>
        </cc:async-mediation>
        <cc:local-out id="Call_Debug_GetIntegrationSystems_151" store-message="none" execute-when="props['inDebugMode']" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Debug" clone-request="true">
            <cc:set name="inTargetType" value="'message'"/>
            <cc:set name="inEntityName" value="'Get_Integration_Systems_Response__' # props.inWID # '.xml'"/>
        </cc:local-out>
        <cc:local-out id="GetIntegrationSystems_151" store-message="none" endpoint="vm://wcc/GetIntegrationSystems">
            <cc:set name="is.system.wid" value="props['inWID']"/>
        </cc:local-out>
        <cc:local-out id="Call_HandleError_InitializeAndFinalize_Error_151" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError">
            <cc:set name="inLogMessage" value="'GetIntegrationSystem Execution Error'"/>
            <cc:set name="inLogMessageDetail" value="'An error occurred while calling Get_Integration_Systems.'"/>
            <cc:set name="inLogLevel" value="'error'"/>
            <cc:set name="inExtraLocalIn" value="context.errorComponentId"/>
            <cc:set name="inExtraSupportData" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/>
            <cc:set name="inExtraErrorCode" value="(context.errorCode != null) ? String.valueOf(context.errorCode) : ''"/>
            <cc:set name="inFinallyEndpoint" value="'vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_151'"/>
            <cc:set name="inIsAbortOnError" value="props['inIsAbortOnError']"/>
            <cc:set name="inIncludeDebugOutput" value="false"/>
        <cc:set name="inLogTarget" value="props.inLogTarget"/></cc:local-out>
        <cc:sync-mediation id="InitializeAndFinalize_151" routes-to="Call_GetIntSys_151" handle-downstream-errors="true" routes-response-to="Call_Finally_151">
            <cc:request-steps/>
            <cc:response-steps/>
            <cc:send-error id="CatchError" routes-to="Call_HandleError_InitializeAndFinalize_Error_151"/>
        </cc:sync-mediation>
        <cc:local-out id="Call_Finally_151" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/Finally_151"/>
        <cc:local-in id="GetIntegrationAttachment" store-message="none" routes-to="InitializeAndFinalize_151" access="public" icon="icons/GetIntegrationAttachment.png">
            <cc:parameter default="lp.integrationSystemRefWID" documentation="WID of the Integration System from which the documents will be queried.  This is typically the current Integration System, and as such, is defaulted to the current Integration System WID.  However, changing this WID enables retrieving documents from another related Integration System for processing." name="inIntegrationSystemWID" required="true" type="string"/>
            <cc:parameter default="false" documentation="This parameter indicates that the Integration System identified by the inIntegrationSystemWID parameter has multiple Attachment Services, and that multiple attachments will be retrieved.  This will cause the component to cache the Integration System xml to improve performance for additional component usage to retrieve the other attachment(s)." name="inSystemHasMultipleAttachments" required="true" type="boolean"/>
            <cc:parameter documentation="The name of the Integration Service Attachment that is associated with the Integration System." name="inAttachmentServiceName" required="true" type="string"/>
            <cc:parameter default="'message'" documentation="Where the results of the response are returned.  If the value is &quot;message&quot;, then the message root will contain the results when the SSK Component ends and if the calling local-out is set to Clone Request = false.  Otherwise, the name will be interpreted as a variable name where the data can be found." name="inReturnResults" required="true" type="string"/>
            <cc:parameter documentation="The MIME Type of the file associated with the provided Attachment Service Name" name="inReturnResultsMimeType" required="true" type="string"/>
            <cc:parameter default="props['int0025IsDebugMode']" documentation="Controls whether or not the Attachment Service contents are output on debug." name="inDebugMode" required="true" type="boolean"/>
            <cc:parameter default="true" documentation="Controls whether or not the abort flag is set on the context upon an error.  If this is set to true and an error occurs, then...  If the calling local-out is set to Propagate Abort = true on the Advanced tab, then the calling assembly will also abort.  If the calling local-out is set to Propagate Abort = false, then the calling assembly will not be aborted.  However, further calls into this SSK Component will result in a &quot;Loop-detected in local-in&quot; exception being thrown to the top level error handler." name="inIsAbortOnError" required="false" type="boolean"/>
            <cc:parameter default="'primary'" documentation="In the event of an error, this parameter controls whether the message is logged to the primary or secondary logs." name="inLogTarget" required="true" type="string" validation="['primary', 'secondary'] contains props['inLogTarget'].trim().toLowerCase()"/>
            
            
            
            
            
        </cc:local-in>
        <cc:local-out id="Call_GetIntSys_151" store-message="none" execute-when="!props.inSystemHasMultipleAttachments" routes-response-to="Call_GetCachedIntSys_151" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/GetIntSys_151"><cc:set name="inWID" value="props.inIntegrationSystemWID"/></cc:local-out>
        <cc:local-in id="GetIntSys_151" routes-to="GetIntegrationSystems_151"><cc:parameter default="props.inIntegrationSystemWID" name="inWID" required="true" type="string"/></cc:local-in>
        <cc:local-in id="GetCachedIntSys_151" routes-to="IsCached_151"><cc:parameter default="props.inIntegrationSystemWID" name="inWID" required="true" type="string"/></cc:local-in>
        <cc:local-out id="Call_GetIntSys_Cache_151" store-message="none" execute-when="!props['localIsCached']" routes-response-to="SetCache_151" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/GetIntSys_151"><cc:set name="inWID" value="props.inWID"/></cc:local-out>
        <cc:local-out id="Call_GetCachedIntSys_151" store-message="none" execute-when="props.inSystemHasMultipleAttachments" routes-response-to="GetAndDecodeFile_151" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/GetCachedIntSys_151">
            <cc:set name="inWID" value="props.inIntegrationSystemWID"/>
        </cc:local-out>
        <cc:async-mediation id="IsCached_151" routes-to="Call_GetIntSys_Cache_151">
            <cc:steps>
                <cc:eval id="InitValues">
                    <cc:expression>cachedVarName = 'ssk151-' # props.inWID;&#xD;
props['localIsCached'] = vars.isVariable(cachedVarName);&#xD;
&#xD;
if (props['localIsCached']) {&#xD;
	message.setRootPart(vars[cachedVarName].source, vars[cachedVarName].mimeType);&#xD;
}</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:async-mediation id="SetCache_151" routes-to="Call_Debug_GetIntegrationSystems_151" execute-steps-when="!props['localIsCached']">
            <cc:steps>
                <cc:eval id="SetValues">
                    <cc:expression>cachedVarName = 'ssk151-' # props.inWID;&#xD;
vars.setVariable(cachedVarName, parts[0].source, parts[0].mimeType);</cc:expression>
                </cc:eval>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="GetCWRData" store-message="none" routes-response-to="LoadCWRData" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/GetDocumentList"><cc:set name="inEventWID" value="context.containsProperty('int0025DebugWID') ? props['int0025DebugWID'] : props['int0025EventWID']"/><cc:set name="inNoFileThrowsException" value="true"/><cc:set name="inMultipleFilesThrowsException" value="true"/><cc:set name="inReturnResults" value="'message'"/><cc:set name="inDebugMode" value="props['int0025IsDebugMode']"/><cc:set name="inLogLevelNoneFoundException" value="'error'"/><cc:set name="inLogLevelMultipleFoundException" value="'error'"/><cc:set name="inLogLevelMultipleCountException" value="'error'"/></cc:local-out>
        <cc:local-out id="LoadCWRData" store-message="none" routes-response-to="AsyncMediation" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/LoadFile" clone-request="false"><cc:set name="inFilename" value="parts[0].xpath('/Documents/Document/Filename')"/><cc:set name="inCollection" value="parts[0].xstream('Documents/Document/Collection')"/><cc:set name="inEntryID" value="parts[0].xstream('Documents/Document/EntryID')"/><cc:set name="inReturnResults" value="'message'"/></cc:local-out>
        <cc:local-out id="CallGetWebhookResponse" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/GetWebhookResponse"/>
        <cc:local-in id="GetWebhookResponse" routes-to="GetCWRData"/>
        <cc:async-mediation id="AsyncMediation" routes-to="CallWebhookTransformation">
            <cc:steps>
                <cc:validate-exp id="ValidateExp">
                    <cc:expression failure-message="File is empty">da.size() > 0</cc:expression>
                </cc:validate-exp>
                <cc:eval id="Eval">
                    <cc:expression>vars['WebhookResponse'] = da.toVar(0,'wd.retrieve.variable')</cc:expression>
                    <cc:expression>parts[0].setMimeType('application/json')</cc:expression>
                    <cc:expression>props['DecryptKey'] = intsys.getAttribute('Decryption Key')</cc:expression>
                </cc:eval>
                <cc:log id="Log0" input="message">
                    <cc:log-message>
                        <cc:text>&#xD;
***********************JSON************************&#xD;
props['DecryptKey'] -- @{props['DecryptKey']}&#xD;
******************************************&#xD;
&#xD;
@{vars['WebhookResponse'].text}&#xD;
&#xD;
************************JSON******************************************&#xD;
&#xD;
&#xD;
&#xD;
</cc:text>
                    </cc:log-message>
                </cc:log>
                <cc:json-to-xml id="JsonToXml" output="message" output-mimetype="text/xml" input="variable" input-variable="WebhookResponse" nested-object-name="CandidateData" root-element-name="Root"/>
                <cc:log id="Log">
                    <cc:log-message>
                        <cc:text>&#xD;
********************************************************XML**********************************************************</cc:text>
                        <cc:message-content/>
                        <cc:text>&#xD;
********************************************************XML**********************************************************</cc:text>
                    </cc:log-message>
                </cc:log>
            </cc:steps>
            <cc:send-error id="SendError" routes-to="CallSubRoutine0"/>
        </cc:async-mediation>
        <cc:local-out id="CallSubRoutine0" store-message="none" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/HandleError"><cc:set name="inLogMessage" value="'Error encountered when processing CWR Data'"/><cc:set name="inLogLevel" value="'error'"/><cc:set name="inIncludeDebugOutput" value="props['int0025IsDebugMode']"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inIsChildThreadContext" value="false"/><cc:set name="inLogMessageDetail" value="(context.getErrorMessage() != empty) ? context.getErrorMessage() : context.exception.message"/></cc:local-out>
        <cc:local-out id="CallWebhookTransformation" store-message="none" routes-response-to="AsyncMediation0" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/XsltPlus"><cc:set name="inDataLocation" value="'message'"/><cc:set name="inPathToXsltFile" value="'xslt/INT0025_WebhookResponseTransformation.xsl'"/><cc:set name="inReturnResults" value="'message'"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:async-mediation id="AsyncMediation0" routes-to="CallGetPassportVisa">
            <cc:steps>
                <cc:log id="Log">
                    <cc:log-message>
                        <cc:text>&#xD;
&#xD;
************Transformation************&#xD;
&#xD;
</cc:text>
                        <cc:message-content/>
                        <cc:text>&#xD;
&#xD;
************Transformation************&#xD;
&#xD;
</cc:text>
                    </cc:log-message>
                </cc:log>
                <cc:eval id="Eval">
                    <cc:expression>props['EmployeeId'] = parts[0].xpath('root/data/EmployeeId')</cc:expression>
                    <cc:expression>props['isVisaInfNull'] = parts[0].xpath('root/data/VisaInf').toString().equalsIgnoreCase('null')</cc:expression>
                    <cc:expression>props['isPassportInfNull'] = parts[0].xpath('root/data/PassportInf').toString().equalsIgnoreCase('null')</cc:expression>
                    <cc:expression>props['isPassportInfAussie'] = parts[0].xpath('root/data/PassportInf').toString().equalsIgnoreCase('Australian Citizen')</cc:expression>
                </cc:eval>
                <cc:log id="Log0">
                    <cc:log-message>
                        <cc:text>&#xD;
&#xD;
******************************************************************&#xD;
props['EmployeeId'] -- @{props['EmployeeId']}&#xD;
&#xD;
props['isVisaInfNull'] -- @{props['isVisaInfNull']}&#xD;
&#xD;
props['isPassportInfNull'] -- @{props['isPassportInfNull']}&#xD;
*******************************************************************&#xD;
&#xD;
&#xD;
</cc:text>
                    </cc:log-message>
                </cc:log>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-in id="UpdatePassportAndVisaInf" routes-to="AsyncMediation1"/>
        <cc:async-mediation id="AsyncMediation1" routes-to="CallSubRoutine">
            <cc:steps>
                <cc:eval id="Eval">
                    <cc:expression>props['VisaCountry'] = parts[0].xpath('root/data/VisaInf/Country')</cc:expression>
                    <cc:expression>props['VisaID'] = parts[0].xpath('root/data/VisaInf/VNumber')</cc:expression>
                    <cc:expression>props['VisaSubClass'] = parts[0].xpath('root/data/VisaInf/VisaSubclass')</cc:expression>
                    <cc:expression>props['VisaExpiry'] = parts[0].xpath('root/data/VisaInf/VisaExpiryDate')</cc:expression>
                    <cc:expression>props['PassportType'] = parts[0].xpath('root/data/PassportInf/PIDType')</cc:expression>
                    <cc:expression>props['PassportCountry'] = parts[0].xpath('root/data/PassportInf/PCountry')</cc:expression>
                    <cc:expression>props['PassportNumber'] = parts[0].xpath('root/data/PassportInf/PNumber')</cc:expression>
                    <cc:expression>props['PassportExpiry'] = parts[0].xpath('root/data/PassportInf/PExpiry')</cc:expression>
                </cc:eval>
                <cc:log id="Log">
                    <cc:log-message>
                        <cc:text>&#xD;
&#xD;
*********************************************&#xD;
&#xD;
props['EmployeeId'] -- @{props['EmployeeId']}&#xD;
&#xD;
**********************************************</cc:text>
                    </cc:log-message>
                </cc:log>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="CallSubRoutine1" store-message="none" routes-response-to="AsyncMediation2" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/CallSoap"><cc:set name="inApiVersion" value="props['globalApiVersion']"/><cc:set name="inWebServiceApplication" value="'Human_Resources'"/><cc:set name="inReturnResults" value="'WebServiceResponse'"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inValidateOnly" value="props['int0025IsValidationMode']"/><cc:set name="inDebugMode" value="props['int0025IsDebugMode']"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:async-mediation id="AsyncMediation2">
            <cc:steps>
                <cc:log id="Log">
                    <cc:log-message>
                        <cc:text>&#xD;
&#xD;
*********Webservice Response************&#xD;
&#xD;
@{vars['WebServiceResponse'].text}</cc:text>
                        <cc:text>&#xD;
&#xD;
*********Webservice Response************&#xD;
&#xD;
</cc:text>
                    </cc:log-message>
                </cc:log>
            </cc:steps>
        </cc:async-mediation>
        <cc:local-out id="CallGetPassportVisa" store-message="none" execute-when="props['isVisaInfNull'] == false &amp;&amp; props['isPassportInfNull'] == false" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/UpdatePassportAndVisaInf"/>
        <cc:local-out id="CallSubRoutine" store-message="none" routes-response-to="AsyncMediation3" endpoint="vm://INT0025_CheckWorkRights_VisaCheck_Inbound/XsltPlus"><cc:set name="inDataLocation" value="'message'"/><cc:set name="inPathToXsltFile" value="'xslt/PassportVisaWeService.xsl'"/><cc:set name="inIsUseETV" value="false"/><cc:set name="inIsUseXTT" value="false"/><cc:set name="inReturnResults" value="'WebServiceRequest'"/><cc:set name="inLogTarget" value="'primary'"/><cc:set name="inIsChildThreadContext" value="false"/></cc:local-out>
        <cc:async-mediation id="AsyncMediation3" routes-to="CallSubRoutine1">
            <cc:steps>
                <cc:log id="Log">
                    <cc:log-message>
                        <cc:text>&#xD;
&#xD;
******************** Request ****************&#xD;
&#xD;
</cc:text>
                        <cc:message-content/>
                        <cc:text>&#xD;
&#xD;
******************** Request ****************&#xD;
&#xD;
</cc:text>
                    </cc:log-message>
                </cc:log>
                <cc:write id="Write">
                    <cc:message>
                        <cc:text>@{vars['WebServiceRequest'].text}</cc:text>
                    </cc:message>
                </cc:write>
            </cc:steps>
        </cc:async-mediation>
    </cc:assembly>
    <bean id="SSK102SoapAuthorBean" class="com.workday.custom.int0025.ssk102.SoapAuthorBean" scope="prototype"/>
    <bean id="SSK109InitializeCore" class="com.workday.custom.int0025.ssk109.CoreInitializationBean" scope="prototype"/>
    <bean id="SSK115FileSplitter" class="com.workday.custom.int0025.ssk115.ParallelBlockSplitter">
        <property name="blockSize" value="1"/>
    </bean>
    <bean id="SSK116BlockSplitter" class="com.workday.custom.int0025.ssk116.ParallelBlockSplitter" scope="prototype">
        <property name="blockSize" value="1"/>
    </bean>
    <bean id="SSK144DebugBean" class="com.workday.custom.int0025.ssk144.DebugBean" scope="prototype"/>
    <bean id="SSK147FlexLogStorageSplitter" class="com.workday.custom.int0025.ssk147.FlexLogStreamSplitter" scope="prototype"/>
    <bean id="SSK148ProcessorBean" class="com.workday.custom.int0025.ssk148.CharacterEncodingBean" scope="prototype">
        <property name="propertyNameIsRemoveBOM" value="inIsRemoveBOM"/>
        <property name="propertyNameIsAddBOM" value="inIsAddBOM"/>
        <property name="propertyNameTargetContentType" value="inTargetContentType"/>
        <property name="propertyNameIsBOMRemoved" value="outIsBOMRemoved148"/>
        <property name="propertyNameIsBOMAdded" value="outIsBOMAdded148"/>
    </bean>
    <bean id="SSK149DataStructureBean" class="com.workday.custom.int0025.ssk149.mediations.DataStructureBean" scope="prototype">
        <property name="propertyNameHistoricIdList" value="outPropertyNameHistoricIdList149"/>
        <property name="propertyNameCurrentIdList" value="outPropertyNameCurrentIdList149"/>
    </bean>
    <bean id="SSK149ListBuilderBean" class="com.workday.custom.int0025.ssk149.mediations.ListBuilderBean" scope="prototype">
        <property name="propertyNameIdList" value="inPropertyWithIdList"/>
        <property name="propertyNameDataSource" value="inDataSource"/>
    </bean>
    <bean id="SSK149ReportDiffBean" class="com.workday.custom.int0025.ssk149.mediations.ReportDiffBean" scope="prototype">
        <property name="propertyNameDataSourceHistoric" value="inDataSourceHistoric"/>
        <property name="propertyNameDataSourceCurrent" value="inDataSourceCurrent"/>
        <property name="propertyNameHistoricIdList" value="inPropertyWithHistoricList"/>
        <property name="propertyNameCurrentIdList" value="inPropertyWithCurrentList"/>
        <property name="propertyNameDeltaOrFullFile" value="inIsReturnChangesOnly"/>
    </bean>
</beans>